/// generated by [parse_gen::generate]
pub mod parse {
    /// generated by [parse_gen::generate_parse]
    impl parse::Parse<crate::cst::data_structure::Heap>
    for tymetafuncspec_core::Cstfy<
        crate::cst::data_structure::Heap,
        crate::cst::data_structure::F,
    > {
        fn parse(
            source: &str,
            offset: parse::miette::SourceOffset,
            heap: &mut crate::cst::data_structure::Heap,
            errors: &mut Vec<parse::ParseError>,
        ) -> (
            tymetafuncspec_core::Cstfy<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::F,
            >,
            parse::miette::SourceOffset,
        ) {
            let mut ute = None;
            /// generated by [parse_gen::gen_parse_current]
            fn parse_directly(
                source: &str,
                initial_offset: parse::miette::SourceOffset,
                heap: &mut crate::cst::data_structure::Heap,
                errors: &mut Vec<parse::ParseError>,
                default_ret: parse::ParseError,
            ) -> (
                tymetafuncspec_core::Cstfy<
                    crate::cst::data_structure::Heap,
                    crate::cst::data_structure::F,
                >,
                parse::miette::SourceOffset,
            ) {
                match parse::unicode_segmentation::UnicodeSegmentation::unicode_words(
                        &source[initial_offset.offset()..],
                    )
                    .next()
                {
                    Some(stringify!(f)) => {
                        let mut offset = initial_offset;
                        let args = (
                            {
                                let (res, new_offset) = <tymetafuncspec_core::Either<
                                    crate::cst::data_structure::Heap,
                                    crate::cst::data_structure::Nat,
                                    std_parse_error::ParseError<
                                        crate::cst::data_structure::Heap,
                                    >,
                                > as parse::Parse<_>>::parse(source, offset, heap, errors);
                                offset = new_offset;
                                res
                            },
                        );
                        (
                            (|x| tymetafuncspec_core::cstfy_ok(
                                x,
                                initial_offset,
                                offset,
                            ))(
                                <crate::cst::data_structure::F as term::CanonicallyConstructibleFrom<
                                    (
                                        tymetafuncspec_core::Either<
                                            crate::cst::data_structure::Heap,
                                            crate::cst::data_structure::Nat,
                                            std_parse_error::ParseError<
                                                crate::cst::data_structure::Heap,
                                            >,
                                        >,
                                    ),
                                >>::construct(heap, args),
                            ),
                            offset,
                        )
                    }
                    None => {
                        (
                            tymetafuncspec_core::Either::Right(
                                std_parse_error::ParseError::new(
                                    parse::ParseError::UnexpectedEndOfInput(
                                        initial_offset.into(),
                                    ),
                                ),
                                std::marker::PhantomData,
                            ),
                            initial_offset,
                        )
                    }
                    _ => {
                        (
                            tymetafuncspec_core::Either::Right(
                                std_parse_error::ParseError::new(default_ret),
                                std::marker::PhantomData,
                            ),
                            initial_offset,
                        )
                    }
                }
            }
            parse_directly(source, offset, heap, errors, ute.unwrap())
        }
    }
    /// generated by [parse_gen::generate_parse]
    impl parse::Parse<crate::cst::data_structure::Heap>
    for tymetafuncspec_core::Cstfy<
        crate::cst::data_structure::Heap,
        crate::cst::data_structure::Plus,
    > {
        fn parse(
            source: &str,
            offset: parse::miette::SourceOffset,
            heap: &mut crate::cst::data_structure::Heap,
            errors: &mut Vec<parse::ParseError>,
        ) -> (
            tymetafuncspec_core::Cstfy<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::Plus,
            >,
            parse::miette::SourceOffset,
        ) {
            let mut ute = None;
            /// generated by [parse_gen::gen_parse_current]
            fn parse_directly(
                source: &str,
                initial_offset: parse::miette::SourceOffset,
                heap: &mut crate::cst::data_structure::Heap,
                errors: &mut Vec<parse::ParseError>,
                default_ret: parse::ParseError,
            ) -> (
                tymetafuncspec_core::Cstfy<
                    crate::cst::data_structure::Heap,
                    crate::cst::data_structure::Plus,
                >,
                parse::miette::SourceOffset,
            ) {
                match parse::unicode_segmentation::UnicodeSegmentation::unicode_words(
                        &source[initial_offset.offset()..],
                    )
                    .next()
                {
                    Some(stringify!(plus)) => {
                        let mut offset = initial_offset;
                        let args = (
                            {
                                let (res, new_offset) = <tymetafuncspec_core::Either<
                                    crate::cst::data_structure::Heap,
                                    tymetafuncspec_core::Pair<
                                        crate::cst::data_structure::Heap,
                                        crate::cst::data_structure::LeftOperand,
                                        tymetafuncspec_core::Maybe<
                                            crate::cst::data_structure::Heap,
                                            std_parse_metadata::ParseMetadata<
                                                crate::cst::data_structure::Heap,
                                            >,
                                        >,
                                    >,
                                    std_parse_error::ParseError<
                                        crate::cst::data_structure::Heap,
                                    >,
                                > as parse::Parse<_>>::parse(source, offset, heap, errors);
                                offset = new_offset;
                                res
                            },
                            {
                                let (res, new_offset) = <tymetafuncspec_core::Either<
                                    crate::cst::data_structure::Heap,
                                    tymetafuncspec_core::Pair<
                                        crate::cst::data_structure::Heap,
                                        crate::cst::data_structure::RightOperand,
                                        tymetafuncspec_core::Maybe<
                                            crate::cst::data_structure::Heap,
                                            std_parse_metadata::ParseMetadata<
                                                crate::cst::data_structure::Heap,
                                            >,
                                        >,
                                    >,
                                    std_parse_error::ParseError<
                                        crate::cst::data_structure::Heap,
                                    >,
                                > as parse::Parse<_>>::parse(source, offset, heap, errors);
                                offset = new_offset;
                                res
                            },
                        );
                        (
                            (|x| tymetafuncspec_core::cstfy_ok(
                                x,
                                initial_offset,
                                offset,
                            ))(
                                <crate::cst::data_structure::Plus as term::CanonicallyConstructibleFrom<
                                    (
                                        tymetafuncspec_core::Either<
                                            crate::cst::data_structure::Heap,
                                            tymetafuncspec_core::Pair<
                                                crate::cst::data_structure::Heap,
                                                crate::cst::data_structure::LeftOperand,
                                                tymetafuncspec_core::Maybe<
                                                    crate::cst::data_structure::Heap,
                                                    std_parse_metadata::ParseMetadata<
                                                        crate::cst::data_structure::Heap,
                                                    >,
                                                >,
                                            >,
                                            std_parse_error::ParseError<
                                                crate::cst::data_structure::Heap,
                                            >,
                                        >,
                                        tymetafuncspec_core::Either<
                                            crate::cst::data_structure::Heap,
                                            tymetafuncspec_core::Pair<
                                                crate::cst::data_structure::Heap,
                                                crate::cst::data_structure::RightOperand,
                                                tymetafuncspec_core::Maybe<
                                                    crate::cst::data_structure::Heap,
                                                    std_parse_metadata::ParseMetadata<
                                                        crate::cst::data_structure::Heap,
                                                    >,
                                                >,
                                            >,
                                            std_parse_error::ParseError<
                                                crate::cst::data_structure::Heap,
                                            >,
                                        >,
                                    ),
                                >>::construct(heap, args),
                            ),
                            offset,
                        )
                    }
                    None => {
                        (
                            tymetafuncspec_core::Either::Right(
                                std_parse_error::ParseError::new(
                                    parse::ParseError::UnexpectedEndOfInput(
                                        initial_offset.into(),
                                    ),
                                ),
                                std::marker::PhantomData,
                            ),
                            initial_offset,
                        )
                    }
                    _ => {
                        (
                            tymetafuncspec_core::Either::Right(
                                std_parse_error::ParseError::new(default_ret),
                                std::marker::PhantomData,
                            ),
                            initial_offset,
                        )
                    }
                }
            }
            parse_directly(source, offset, heap, errors, ute.unwrap())
        }
    }
    /// generated by [parse_gen::generate_parse]
    impl parse::Parse<crate::cst::data_structure::Heap>
    for tymetafuncspec_core::Cstfy<
        crate::cst::data_structure::Heap,
        crate::cst::data_structure::LeftOperand,
    > {
        fn parse(
            source: &str,
            offset: parse::miette::SourceOffset,
            heap: &mut crate::cst::data_structure::Heap,
            errors: &mut Vec<parse::ParseError>,
        ) -> (
            tymetafuncspec_core::Cstfy<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::LeftOperand,
            >,
            parse::miette::SourceOffset,
        ) {
            let mut ute = None;
            /// generated by [parse_gen::gen_parse_current]
            fn parse_directly(
                source: &str,
                initial_offset: parse::miette::SourceOffset,
                heap: &mut crate::cst::data_structure::Heap,
                errors: &mut Vec<parse::ParseError>,
                default_ret: parse::ParseError,
            ) -> (
                tymetafuncspec_core::Cstfy<
                    crate::cst::data_structure::Heap,
                    crate::cst::data_structure::LeftOperand,
                >,
                parse::miette::SourceOffset,
            ) {
                match parse::unicode_segmentation::UnicodeSegmentation::unicode_words(
                        &source[initial_offset.offset()..],
                    )
                    .next()
                {
                    Some(stringify!(left_operand)) => {
                        let mut offset = initial_offset;
                        let args = (
                            {
                                let (res, new_offset) = <tymetafuncspec_core::Either<
                                    crate::cst::data_structure::Heap,
                                    crate::cst::data_structure::Nat,
                                    std_parse_error::ParseError<
                                        crate::cst::data_structure::Heap,
                                    >,
                                > as parse::Parse<_>>::parse(source, offset, heap, errors);
                                offset = new_offset;
                                res
                            },
                        );
                        (
                            (|x| tymetafuncspec_core::cstfy_ok(
                                x,
                                initial_offset,
                                offset,
                            ))(
                                <crate::cst::data_structure::LeftOperand as term::CanonicallyConstructibleFrom<
                                    (
                                        tymetafuncspec_core::Either<
                                            crate::cst::data_structure::Heap,
                                            crate::cst::data_structure::Nat,
                                            std_parse_error::ParseError<
                                                crate::cst::data_structure::Heap,
                                            >,
                                        >,
                                    ),
                                >>::construct(heap, args),
                            ),
                            offset,
                        )
                    }
                    None => {
                        (
                            tymetafuncspec_core::Either::Right(
                                std_parse_error::ParseError::new(
                                    parse::ParseError::UnexpectedEndOfInput(
                                        initial_offset.into(),
                                    ),
                                ),
                                std::marker::PhantomData,
                            ),
                            initial_offset,
                        )
                    }
                    _ => {
                        (
                            tymetafuncspec_core::Either::Right(
                                std_parse_error::ParseError::new(default_ret),
                                std::marker::PhantomData,
                            ),
                            initial_offset,
                        )
                    }
                }
            }
            parse_directly(source, offset, heap, errors, ute.unwrap())
        }
    }
    /// generated by [parse_gen::generate_parse]
    impl parse::Parse<crate::cst::data_structure::Heap>
    for tymetafuncspec_core::Cstfy<
        crate::cst::data_structure::Heap,
        crate::cst::data_structure::RightOperand,
    > {
        fn parse(
            source: &str,
            offset: parse::miette::SourceOffset,
            heap: &mut crate::cst::data_structure::Heap,
            errors: &mut Vec<parse::ParseError>,
        ) -> (
            tymetafuncspec_core::Cstfy<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::RightOperand,
            >,
            parse::miette::SourceOffset,
        ) {
            let mut ute = None;
            /// generated by [parse_gen::gen_parse_current]
            fn parse_directly(
                source: &str,
                initial_offset: parse::miette::SourceOffset,
                heap: &mut crate::cst::data_structure::Heap,
                errors: &mut Vec<parse::ParseError>,
                default_ret: parse::ParseError,
            ) -> (
                tymetafuncspec_core::Cstfy<
                    crate::cst::data_structure::Heap,
                    crate::cst::data_structure::RightOperand,
                >,
                parse::miette::SourceOffset,
            ) {
                match parse::unicode_segmentation::UnicodeSegmentation::unicode_words(
                        &source[initial_offset.offset()..],
                    )
                    .next()
                {
                    Some(stringify!(right_operand)) => {
                        let mut offset = initial_offset;
                        let args = (
                            {
                                let (res, new_offset) = <tymetafuncspec_core::Either<
                                    crate::cst::data_structure::Heap,
                                    crate::cst::data_structure::Nat,
                                    std_parse_error::ParseError<
                                        crate::cst::data_structure::Heap,
                                    >,
                                > as parse::Parse<_>>::parse(source, offset, heap, errors);
                                offset = new_offset;
                                res
                            },
                        );
                        (
                            (|x| tymetafuncspec_core::cstfy_ok(
                                x,
                                initial_offset,
                                offset,
                            ))(
                                <crate::cst::data_structure::RightOperand as term::CanonicallyConstructibleFrom<
                                    (
                                        tymetafuncspec_core::Either<
                                            crate::cst::data_structure::Heap,
                                            crate::cst::data_structure::Nat,
                                            std_parse_error::ParseError<
                                                crate::cst::data_structure::Heap,
                                            >,
                                        >,
                                    ),
                                >>::construct(heap, args),
                            ),
                            offset,
                        )
                    }
                    None => {
                        (
                            tymetafuncspec_core::Either::Right(
                                std_parse_error::ParseError::new(
                                    parse::ParseError::UnexpectedEndOfInput(
                                        initial_offset.into(),
                                    ),
                                ),
                                std::marker::PhantomData,
                            ),
                            initial_offset,
                        )
                    }
                    _ => {
                        (
                            tymetafuncspec_core::Either::Right(
                                std_parse_error::ParseError::new(default_ret),
                                std::marker::PhantomData,
                            ),
                            initial_offset,
                        )
                    }
                }
            }
            parse_directly(source, offset, heap, errors, ute.unwrap())
        }
    }
    /// generated by [parse_gen::generate_parse]
    impl parse::Parse<crate::cst::data_structure::Heap>
    for tymetafuncspec_core::Cstfy<
        crate::cst::data_structure::Heap,
        crate::cst::data_structure::Sum,
    > {
        fn parse(
            source: &str,
            offset: parse::miette::SourceOffset,
            heap: &mut crate::cst::data_structure::Heap,
            errors: &mut Vec<parse::ParseError>,
        ) -> (
            tymetafuncspec_core::Cstfy<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::Sum,
            >,
            parse::miette::SourceOffset,
        ) {
            let mut ute = None;
            /// generated by [parse_gen::gen_parse_current]
            fn parse_directly(
                source: &str,
                initial_offset: parse::miette::SourceOffset,
                heap: &mut crate::cst::data_structure::Heap,
                errors: &mut Vec<parse::ParseError>,
                default_ret: parse::ParseError,
            ) -> (
                tymetafuncspec_core::Cstfy<
                    crate::cst::data_structure::Heap,
                    crate::cst::data_structure::Sum,
                >,
                parse::miette::SourceOffset,
            ) {
                match parse::unicode_segmentation::UnicodeSegmentation::unicode_words(
                        &source[initial_offset.offset()..],
                    )
                    .next()
                {
                    Some(stringify!(sum)) => {
                        let mut offset = initial_offset;
                        let args = (
                            {
                                let (res, new_offset) = <tymetafuncspec_core::Either<
                                    crate::cst::data_structure::Heap,
                                    tymetafuncspec_core::Pair<
                                        crate::cst::data_structure::Heap,
                                        tymetafuncspec_core::Set<
                                            crate::cst::data_structure::Heap,
                                            tymetafuncspec_core::Either<
                                                crate::cst::data_structure::Heap,
                                                crate::cst::data_structure::Nat,
                                                std_parse_error::ParseError<
                                                    crate::cst::data_structure::Heap,
                                                >,
                                            >,
                                        >,
                                        tymetafuncspec_core::Maybe<
                                            crate::cst::data_structure::Heap,
                                            std_parse_metadata::ParseMetadata<
                                                crate::cst::data_structure::Heap,
                                            >,
                                        >,
                                    >,
                                    std_parse_error::ParseError<
                                        crate::cst::data_structure::Heap,
                                    >,
                                > as parse::Parse<_>>::parse(source, offset, heap, errors);
                                offset = new_offset;
                                res
                            },
                        );
                        (
                            (|x| tymetafuncspec_core::cstfy_ok(
                                x,
                                initial_offset,
                                offset,
                            ))(
                                <crate::cst::data_structure::Sum as term::CanonicallyConstructibleFrom<
                                    (
                                        tymetafuncspec_core::Either<
                                            crate::cst::data_structure::Heap,
                                            tymetafuncspec_core::Pair<
                                                crate::cst::data_structure::Heap,
                                                tymetafuncspec_core::Set<
                                                    crate::cst::data_structure::Heap,
                                                    tymetafuncspec_core::Either<
                                                        crate::cst::data_structure::Heap,
                                                        crate::cst::data_structure::Nat,
                                                        std_parse_error::ParseError<
                                                            crate::cst::data_structure::Heap,
                                                        >,
                                                    >,
                                                >,
                                                tymetafuncspec_core::Maybe<
                                                    crate::cst::data_structure::Heap,
                                                    std_parse_metadata::ParseMetadata<
                                                        crate::cst::data_structure::Heap,
                                                    >,
                                                >,
                                            >,
                                            std_parse_error::ParseError<
                                                crate::cst::data_structure::Heap,
                                            >,
                                        >,
                                    ),
                                >>::construct(heap, args),
                            ),
                            offset,
                        )
                    }
                    None => {
                        (
                            tymetafuncspec_core::Either::Right(
                                std_parse_error::ParseError::new(
                                    parse::ParseError::UnexpectedEndOfInput(
                                        initial_offset.into(),
                                    ),
                                ),
                                std::marker::PhantomData,
                            ),
                            initial_offset,
                        )
                    }
                    _ => {
                        (
                            tymetafuncspec_core::Either::Right(
                                std_parse_error::ParseError::new(default_ret),
                                std::marker::PhantomData,
                            ),
                            initial_offset,
                        )
                    }
                }
            }
            parse_directly(source, offset, heap, errors, ute.unwrap())
        }
    }
    /// generated by [parse_gen::generate_parse]
    impl parse::Parse<crate::cst::data_structure::Heap>
    for tymetafuncspec_core::CstfyTransparent<
        crate::cst::data_structure::Heap,
        crate::cst::data_structure::Nat,
    > {
        fn parse(
            source: &str,
            offset: parse::miette::SourceOffset,
            heap: &mut crate::cst::data_structure::Heap,
            errors: &mut Vec<parse::ParseError>,
        ) -> (
            tymetafuncspec_core::CstfyTransparent<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::Nat,
            >,
            parse::miette::SourceOffset,
        ) {
            let mut ute = None;
            let parse_directly = |_, _, _, _, ret| ret;
            parse_directly(source, offset, heap, errors, ute.unwrap())
        }
    }
}
pub mod cst {
    /// generated by [term_specialized_gen::generate]
    pub mod data_structure {
        /// generated by [term_specialized_gen::gen_heap]
        #[derive(Default)]
        pub struct Heap {
            either: crate::cst::heap::either::Bak,
            parse_error: crate::cst::heap::parse_error::Bak,
            pair: crate::cst::heap::pair::Bak,
            maybe: crate::cst::heap::maybe::Bak,
            parse_metadata: crate::cst::heap::parse_metadata::Bak,
            set: crate::cst::heap::set::Bak,
            nat_lit: crate::cst::heap::nat_lit::Bak,
            idx_box: crate::cst::heap::idx_box::Bak,
        }
        pub mod heap {
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[derive(Default)]
            pub struct Bak {
                pub either: crate::cst::heap::either::Bak,
                pub parse_error: crate::cst::heap::parse_error::Bak,
                pub pair: crate::cst::heap::pair::Bak,
                pub maybe: crate::cst::heap::maybe::Bak,
                pub parse_metadata: crate::cst::heap::parse_metadata::Bak,
                pub set: crate::cst::heap::set::Bak,
                pub nat_lit: crate::cst::heap::nat_lit::Bak,
                pub idx_box: crate::cst::heap::idx_box::Bak,
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod either {
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[derive(Default)]
                pub struct Bak {
                    pub nat: crate::cst::heap::either::nat::Bak,
                    pub pair: crate::cst::heap::either::pair::Bak,
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod nat {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub parse_error: crate::cst::heap::either::nat::parse_error::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod parse_error {
                        /// generated by [term_specialized_gen::gen_heapbak_module]
                        #[derive(Default)]
                        pub struct Bak(
                            pub tymetafuncspec_core::EitherHeapBak<
                                crate::cst::Heap,
                                crate::cst::Nat,
                                std_parse_error::ParseError<crate::cst::Heap>,
                            >,
                        );
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod pair {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub left_operand: crate::cst::heap::either::pair::left_operand::Bak,
                        pub right_operand: crate::cst::heap::either::pair::right_operand::Bak,
                        pub set: crate::cst::heap::either::pair::set::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod left_operand {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub maybe: crate::cst::heap::either::pair::left_operand::maybe::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod maybe {
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[derive(Default)]
                            pub struct Bak {
                                pub parse_metadata: crate::cst::heap::either::pair::left_operand::maybe::parse_metadata::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            pub mod parse_metadata {
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub parse_error: crate::cst::heap::either::pair::left_operand::maybe::parse_metadata::parse_error::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                pub mod parse_error {
                                    /// generated by [term_specialized_gen::gen_heapbak_module]
                                    #[derive(Default)]
                                    pub struct Bak(
                                        pub tymetafuncspec_core::EitherHeapBak<
                                            crate::cst::Heap,
                                            tymetafuncspec_core::Pair<
                                                crate::cst::Heap,
                                                crate::cst::LeftOperand,
                                                tymetafuncspec_core::Maybe<
                                                    crate::cst::Heap,
                                                    std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                                                >,
                                            >,
                                            std_parse_error::ParseError<crate::cst::Heap>,
                                        >,
                                    );
                                }
                            }
                        }
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod right_operand {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub maybe: crate::cst::heap::either::pair::right_operand::maybe::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod maybe {
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[derive(Default)]
                            pub struct Bak {
                                pub parse_metadata: crate::cst::heap::either::pair::right_operand::maybe::parse_metadata::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            pub mod parse_metadata {
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub parse_error: crate::cst::heap::either::pair::right_operand::maybe::parse_metadata::parse_error::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                pub mod parse_error {
                                    /// generated by [term_specialized_gen::gen_heapbak_module]
                                    #[derive(Default)]
                                    pub struct Bak(
                                        pub tymetafuncspec_core::EitherHeapBak<
                                            crate::cst::Heap,
                                            tymetafuncspec_core::Pair<
                                                crate::cst::Heap,
                                                crate::cst::RightOperand,
                                                tymetafuncspec_core::Maybe<
                                                    crate::cst::Heap,
                                                    std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                                                >,
                                            >,
                                            std_parse_error::ParseError<crate::cst::Heap>,
                                        >,
                                    );
                                }
                            }
                        }
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod set {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub either: crate::cst::heap::either::pair::set::either::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod either {
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[derive(Default)]
                            pub struct Bak {
                                pub nat: crate::cst::heap::either::pair::set::either::nat::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            pub mod nat {
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub parse_error: crate::cst::heap::either::pair::set::either::nat::parse_error::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                pub mod parse_error {
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[derive(Default)]
                                    pub struct Bak {
                                        pub maybe: crate::cst::heap::either::pair::set::either::nat::parse_error::maybe::Bak,
                                    }
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    pub mod maybe {
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        #[derive(Default)]
                                        pub struct Bak {
                                            pub parse_metadata: crate::cst::heap::either::pair::set::either::nat::parse_error::maybe::parse_metadata::Bak,
                                        }
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        pub mod parse_metadata {
                                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                            #[derive(Default)]
                                            pub struct Bak {
                                                pub parse_error: crate::cst::heap::either::pair::set::either::nat::parse_error::maybe::parse_metadata::parse_error::Bak,
                                            }
                                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                            pub mod parse_error {
                                                /// generated by [term_specialized_gen::gen_heapbak_module]
                                                #[derive(Default)]
                                                pub struct Bak(
                                                    pub tymetafuncspec_core::EitherHeapBak<
                                                        crate::cst::Heap,
                                                        tymetafuncspec_core::Pair<
                                                            crate::cst::Heap,
                                                            tymetafuncspec_core::Set<
                                                                crate::cst::Heap,
                                                                tymetafuncspec_core::Either<
                                                                    crate::cst::Heap,
                                                                    crate::cst::Nat,
                                                                    std_parse_error::ParseError<crate::cst::Heap>,
                                                                >,
                                                            >,
                                                            tymetafuncspec_core::Maybe<
                                                                crate::cst::Heap,
                                                                std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                                                            >,
                                                        >,
                                                        std_parse_error::ParseError<crate::cst::Heap>,
                                                    >,
                                                );
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod parse_error {
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[derive(Default)]
                pub struct Bak(pub std_parse_error::ParseErrorBak<crate::cst::Heap>);
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod pair {
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[derive(Default)]
                pub struct Bak {
                    pub left_operand: crate::cst::heap::pair::left_operand::Bak,
                    pub right_operand: crate::cst::heap::pair::right_operand::Bak,
                    pub set: crate::cst::heap::pair::set::Bak,
                    pub nat_lit: crate::cst::heap::pair::nat_lit::Bak,
                    pub idx_box: crate::cst::heap::pair::idx_box::Bak,
                    pub f: crate::cst::heap::pair::f::Bak,
                    pub plus: crate::cst::heap::pair::plus::Bak,
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod left_operand {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub maybe: crate::cst::heap::pair::left_operand::maybe::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod maybe {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub parse_metadata: crate::cst::heap::pair::left_operand::maybe::parse_metadata::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod parse_metadata {
                            /// generated by [term_specialized_gen::gen_heapbak_module]
                            #[derive(Default)]
                            pub struct Bak(
                                pub tymetafuncspec_core::PairHeapBak<
                                    crate::cst::Heap,
                                    crate::cst::LeftOperand,
                                    tymetafuncspec_core::Maybe<
                                        crate::cst::Heap,
                                        std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                                    >,
                                >,
                            );
                        }
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod right_operand {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub maybe: crate::cst::heap::pair::right_operand::maybe::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod maybe {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub parse_metadata: crate::cst::heap::pair::right_operand::maybe::parse_metadata::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod parse_metadata {
                            /// generated by [term_specialized_gen::gen_heapbak_module]
                            #[derive(Default)]
                            pub struct Bak(
                                pub tymetafuncspec_core::PairHeapBak<
                                    crate::cst::Heap,
                                    crate::cst::RightOperand,
                                    tymetafuncspec_core::Maybe<
                                        crate::cst::Heap,
                                        std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                                    >,
                                >,
                            );
                        }
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod set {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub either: crate::cst::heap::pair::set::either::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod either {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub nat: crate::cst::heap::pair::set::either::nat::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod nat {
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[derive(Default)]
                            pub struct Bak {
                                pub parse_error: crate::cst::heap::pair::set::either::nat::parse_error::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            pub mod parse_error {
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub maybe: crate::cst::heap::pair::set::either::nat::parse_error::maybe::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                pub mod maybe {
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[derive(Default)]
                                    pub struct Bak {
                                        pub parse_metadata: crate::cst::heap::pair::set::either::nat::parse_error::maybe::parse_metadata::Bak,
                                    }
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    pub mod parse_metadata {
                                        /// generated by [term_specialized_gen::gen_heapbak_module]
                                        #[derive(Default)]
                                        pub struct Bak(
                                            pub tymetafuncspec_core::PairHeapBak<
                                                crate::cst::Heap,
                                                tymetafuncspec_core::Set<
                                                    crate::cst::Heap,
                                                    tymetafuncspec_core::Either<
                                                        crate::cst::Heap,
                                                        crate::cst::Nat,
                                                        std_parse_error::ParseError<crate::cst::Heap>,
                                                    >,
                                                >,
                                                tymetafuncspec_core::Maybe<
                                                    crate::cst::Heap,
                                                    std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                                                >,
                                            >,
                                        );
                                    }
                                }
                            }
                        }
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod nat_lit {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub maybe: crate::cst::heap::pair::nat_lit::maybe::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod maybe {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub parse_metadata: crate::cst::heap::pair::nat_lit::maybe::parse_metadata::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod parse_metadata {
                            /// generated by [term_specialized_gen::gen_heapbak_module]
                            #[derive(Default)]
                            pub struct Bak(
                                pub tymetafuncspec_core::PairHeapBak<
                                    crate::cst::Heap,
                                    tymetafuncspec_core::BoundedNat<crate::cst::Heap>,
                                    tymetafuncspec_core::Maybe<
                                        crate::cst::Heap,
                                        std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                                    >,
                                >,
                            );
                        }
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod idx_box {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub pair: crate::cst::heap::pair::idx_box::pair::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod pair {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub f: crate::cst::heap::pair::idx_box::pair::f::Bak,
                            pub plus: crate::cst::heap::pair::idx_box::pair::plus::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod f {
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[derive(Default)]
                            pub struct Bak {
                                pub maybe: crate::cst::heap::pair::idx_box::pair::f::maybe::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            pub mod maybe {
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub parse_metadata: crate::cst::heap::pair::idx_box::pair::f::maybe::parse_metadata::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                pub mod parse_metadata {
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[derive(Default)]
                                    pub struct Bak {
                                        pub maybe: crate::cst::heap::pair::idx_box::pair::f::maybe::parse_metadata::maybe::Bak,
                                    }
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    pub mod maybe {
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        #[derive(Default)]
                                        pub struct Bak {
                                            pub parse_metadata: crate::cst::heap::pair::idx_box::pair::f::maybe::parse_metadata::maybe::parse_metadata::Bak,
                                        }
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        pub mod parse_metadata {
                                            /// generated by [term_specialized_gen::gen_heapbak_module]
                                            #[derive(Default)]
                                            pub struct Bak(
                                                pub tymetafuncspec_core::PairHeapBak<
                                                    crate::cst::Heap,
                                                    tymetafuncspec_core::IdxBox<
                                                        crate::cst::Heap,
                                                        tymetafuncspec_core::Pair<
                                                            crate::cst::Heap,
                                                            crate::cst::F,
                                                            tymetafuncspec_core::Maybe<
                                                                crate::cst::Heap,
                                                                std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                                                            >,
                                                        >,
                                                    >,
                                                    tymetafuncspec_core::Maybe<
                                                        crate::cst::Heap,
                                                        std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                                                    >,
                                                >,
                                            );
                                        }
                                    }
                                }
                            }
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod plus {
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[derive(Default)]
                            pub struct Bak {
                                pub maybe: crate::cst::heap::pair::idx_box::pair::plus::maybe::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            pub mod maybe {
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub parse_metadata: crate::cst::heap::pair::idx_box::pair::plus::maybe::parse_metadata::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                pub mod parse_metadata {
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[derive(Default)]
                                    pub struct Bak {
                                        pub maybe: crate::cst::heap::pair::idx_box::pair::plus::maybe::parse_metadata::maybe::Bak,
                                    }
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    pub mod maybe {
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        #[derive(Default)]
                                        pub struct Bak {
                                            pub parse_metadata: crate::cst::heap::pair::idx_box::pair::plus::maybe::parse_metadata::maybe::parse_metadata::Bak,
                                        }
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        pub mod parse_metadata {
                                            /// generated by [term_specialized_gen::gen_heapbak_module]
                                            #[derive(Default)]
                                            pub struct Bak(
                                                pub tymetafuncspec_core::PairHeapBak<
                                                    crate::cst::Heap,
                                                    tymetafuncspec_core::IdxBox<
                                                        crate::cst::Heap,
                                                        tymetafuncspec_core::Pair<
                                                            crate::cst::Heap,
                                                            crate::cst::Plus,
                                                            tymetafuncspec_core::Maybe<
                                                                crate::cst::Heap,
                                                                std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                                                            >,
                                                        >,
                                                    >,
                                                    tymetafuncspec_core::Maybe<
                                                        crate::cst::Heap,
                                                        std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                                                    >,
                                                >,
                                            );
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod f {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub maybe: crate::cst::heap::pair::f::maybe::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod maybe {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub parse_metadata: crate::cst::heap::pair::f::maybe::parse_metadata::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod parse_metadata {
                            /// generated by [term_specialized_gen::gen_heapbak_module]
                            #[derive(Default)]
                            pub struct Bak(
                                pub tymetafuncspec_core::PairHeapBak<
                                    crate::cst::Heap,
                                    crate::cst::F,
                                    tymetafuncspec_core::Maybe<
                                        crate::cst::Heap,
                                        std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                                    >,
                                >,
                            );
                        }
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod plus {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub maybe: crate::cst::heap::pair::plus::maybe::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod maybe {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub parse_metadata: crate::cst::heap::pair::plus::maybe::parse_metadata::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod parse_metadata {
                            /// generated by [term_specialized_gen::gen_heapbak_module]
                            #[derive(Default)]
                            pub struct Bak(
                                pub tymetafuncspec_core::PairHeapBak<
                                    crate::cst::Heap,
                                    crate::cst::Plus,
                                    tymetafuncspec_core::Maybe<
                                        crate::cst::Heap,
                                        std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                                    >,
                                >,
                            );
                        }
                    }
                }
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod maybe {
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[derive(Default)]
                pub struct Bak {
                    pub parse_metadata: crate::cst::heap::maybe::parse_metadata::Bak,
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod parse_metadata {
                    /// generated by [term_specialized_gen::gen_heapbak_module]
                    #[derive(Default)]
                    pub struct Bak(
                        pub tymetafuncspec_core::MaybeHeapBak<
                            crate::cst::Heap,
                            std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                        >,
                    );
                }
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod parse_metadata {
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[derive(Default)]
                pub struct Bak(
                    pub std_parse_metadata::ParseMetadataBak<crate::cst::Heap>,
                );
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod set {
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[derive(Default)]
                pub struct Bak {
                    pub either: crate::cst::heap::set::either::Bak,
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod either {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub nat: crate::cst::heap::set::either::nat::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod nat {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub parse_error: crate::cst::heap::set::either::nat::parse_error::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod parse_error {
                            /// generated by [term_specialized_gen::gen_heapbak_module]
                            #[derive(Default)]
                            pub struct Bak(
                                pub tymetafuncspec_core::SetHeapBak<
                                    crate::cst::Heap,
                                    tymetafuncspec_core::Either<
                                        crate::cst::Heap,
                                        crate::cst::Nat,
                                        std_parse_error::ParseError<crate::cst::Heap>,
                                    >,
                                >,
                            );
                        }
                    }
                }
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod nat_lit {
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[derive(Default)]
                pub struct Bak(
                    pub tymetafuncspec_core::BoundedNatHeapBak<crate::cst::Heap>,
                );
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod idx_box {
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[derive(Default)]
                pub struct Bak {
                    pub pair: crate::cst::heap::idx_box::pair::Bak,
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod pair {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub f: crate::cst::heap::idx_box::pair::f::Bak,
                        pub plus: crate::cst::heap::idx_box::pair::plus::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod f {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub maybe: crate::cst::heap::idx_box::pair::f::maybe::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod maybe {
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[derive(Default)]
                            pub struct Bak {
                                pub parse_metadata: crate::cst::heap::idx_box::pair::f::maybe::parse_metadata::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            pub mod parse_metadata {
                                /// generated by [term_specialized_gen::gen_heapbak_module]
                                #[derive(Default)]
                                pub struct Bak(
                                    pub tymetafuncspec_core::IdxBoxHeapBak<
                                        crate::cst::Heap,
                                        tymetafuncspec_core::Pair<
                                            crate::cst::Heap,
                                            crate::cst::F,
                                            tymetafuncspec_core::Maybe<
                                                crate::cst::Heap,
                                                std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                                            >,
                                        >,
                                    >,
                                );
                            }
                        }
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod plus {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub maybe: crate::cst::heap::idx_box::pair::plus::maybe::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod maybe {
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[derive(Default)]
                            pub struct Bak {
                                pub parse_metadata: crate::cst::heap::idx_box::pair::plus::maybe::parse_metadata::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            pub mod parse_metadata {
                                /// generated by [term_specialized_gen::gen_heapbak_module]
                                #[derive(Default)]
                                pub struct Bak(
                                    pub tymetafuncspec_core::IdxBoxHeapBak<
                                        crate::cst::Heap,
                                        tymetafuncspec_core::Pair<
                                            crate::cst::Heap,
                                            crate::cst::Plus,
                                            tymetafuncspec_core::Maybe<
                                                crate::cst::Heap,
                                                std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                                            >,
                                        >,
                                    >,
                                );
                            }
                        }
                    }
                }
            }
        }
        pub mod superheap {
            term::impl_superheap!(
                crate ::cst::Heap; tymetafuncspec_core::EitherHeapBak < crate
                ::cst::Heap, crate ::cst::Nat, std_parse_error::ParseError < crate
                ::cst::Heap, > >; either nat parse_error
            );
            term::impl_superheap!(
                crate ::cst::Heap; std_parse_error::ParseErrorBak < crate ::cst::Heap, >;
                parse_error
            );
            term::impl_superheap!(
                crate ::cst::Heap; tymetafuncspec_core::EitherHeapBak < crate
                ::cst::Heap, tymetafuncspec_core::Pair < crate ::cst::Heap, crate
                ::cst::LeftOperand, tymetafuncspec_core::Maybe < crate ::cst::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::Heap, >, >, >,
                std_parse_error::ParseError < crate ::cst::Heap, > >; either pair
                left_operand maybe parse_metadata parse_error
            );
            term::impl_superheap!(
                crate ::cst::Heap; tymetafuncspec_core::PairHeapBak < crate ::cst::Heap,
                crate ::cst::LeftOperand, tymetafuncspec_core::Maybe < crate ::cst::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::Heap, >, > >; pair
                left_operand maybe parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::Heap; tymetafuncspec_core::MaybeHeapBak < crate ::cst::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::Heap, > >; maybe
                parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::Heap; std_parse_metadata::ParseMetadataBak < crate
                ::cst::Heap, >; parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::Heap; tymetafuncspec_core::EitherHeapBak < crate
                ::cst::Heap, tymetafuncspec_core::Pair < crate ::cst::Heap, crate
                ::cst::RightOperand, tymetafuncspec_core::Maybe < crate ::cst::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::Heap, >, >, >,
                std_parse_error::ParseError < crate ::cst::Heap, > >; either pair
                right_operand maybe parse_metadata parse_error
            );
            term::impl_superheap!(
                crate ::cst::Heap; tymetafuncspec_core::PairHeapBak < crate ::cst::Heap,
                crate ::cst::RightOperand, tymetafuncspec_core::Maybe < crate
                ::cst::Heap, std_parse_metadata::ParseMetadata < crate ::cst::Heap, >, >
                >; pair right_operand maybe parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::Heap; tymetafuncspec_core::EitherHeapBak < crate
                ::cst::Heap, tymetafuncspec_core::Pair < crate ::cst::Heap,
                tymetafuncspec_core::Set < crate ::cst::Heap, tymetafuncspec_core::Either
                < crate ::cst::Heap, crate ::cst::Nat, std_parse_error::ParseError <
                crate ::cst::Heap, >, >, >, tymetafuncspec_core::Maybe < crate
                ::cst::Heap, std_parse_metadata::ParseMetadata < crate ::cst::Heap, >, >,
                >, std_parse_error::ParseError < crate ::cst::Heap, > >; either pair set
                either nat parse_error maybe parse_metadata parse_error
            );
            term::impl_superheap!(
                crate ::cst::Heap; tymetafuncspec_core::PairHeapBak < crate ::cst::Heap,
                tymetafuncspec_core::Set < crate ::cst::Heap, tymetafuncspec_core::Either
                < crate ::cst::Heap, crate ::cst::Nat, std_parse_error::ParseError <
                crate ::cst::Heap, >, >, >, tymetafuncspec_core::Maybe < crate
                ::cst::Heap, std_parse_metadata::ParseMetadata < crate ::cst::Heap, >, >
                >; pair set either nat parse_error maybe parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::Heap; tymetafuncspec_core::SetHeapBak < crate ::cst::Heap,
                tymetafuncspec_core::Either < crate ::cst::Heap, crate ::cst::Nat,
                std_parse_error::ParseError < crate ::cst::Heap, >, > >; set either nat
                parse_error
            );
            term::impl_superheap!(
                crate ::cst::Heap; tymetafuncspec_core::PairHeapBak < crate ::cst::Heap,
                tymetafuncspec_core::BoundedNat < crate ::cst::Heap, >,
                tymetafuncspec_core::Maybe < crate ::cst::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::Heap, >, > >; pair
                nat_lit maybe parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::Heap; tymetafuncspec_core::BoundedNatHeapBak < crate
                ::cst::Heap, >; nat_lit
            );
            term::impl_superheap!(
                crate ::cst::Heap; tymetafuncspec_core::PairHeapBak < crate ::cst::Heap,
                tymetafuncspec_core::IdxBox < crate ::cst::Heap,
                tymetafuncspec_core::Pair < crate ::cst::Heap, crate ::cst::F,
                tymetafuncspec_core::Maybe < crate ::cst::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::Heap, >, >, >, >,
                tymetafuncspec_core::Maybe < crate ::cst::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::Heap, >, > >; pair
                idx_box pair f maybe parse_metadata maybe parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::Heap; tymetafuncspec_core::IdxBoxHeapBak < crate
                ::cst::Heap, tymetafuncspec_core::Pair < crate ::cst::Heap, crate
                ::cst::F, tymetafuncspec_core::Maybe < crate ::cst::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::Heap, >, >, > >; idx_box
                pair f maybe parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::Heap; tymetafuncspec_core::PairHeapBak < crate ::cst::Heap,
                crate ::cst::F, tymetafuncspec_core::Maybe < crate ::cst::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::Heap, >, > >; pair f
                maybe parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::Heap; tymetafuncspec_core::PairHeapBak < crate ::cst::Heap,
                tymetafuncspec_core::IdxBox < crate ::cst::Heap,
                tymetafuncspec_core::Pair < crate ::cst::Heap, crate ::cst::Plus,
                tymetafuncspec_core::Maybe < crate ::cst::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::Heap, >, >, >, >,
                tymetafuncspec_core::Maybe < crate ::cst::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::Heap, >, > >; pair
                idx_box pair plus maybe parse_metadata maybe parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::Heap; tymetafuncspec_core::IdxBoxHeapBak < crate
                ::cst::Heap, tymetafuncspec_core::Pair < crate ::cst::Heap, crate
                ::cst::Plus, tymetafuncspec_core::Maybe < crate ::cst::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::Heap, >, >, > >; idx_box
                pair plus maybe parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::Heap; tymetafuncspec_core::PairHeapBak < crate ::cst::Heap,
                crate ::cst::Plus, tymetafuncspec_core::Maybe < crate ::cst::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::Heap, >, > >; pair plus
                maybe parse_metadata
            );
        }
        pub struct F {
            pub nat: tymetafuncspec_core::Either<
                crate::cst::Heap,
                crate::cst::Nat,
                std_parse_error::ParseError<crate::cst::Heap>,
            >,
        }
        pub struct Plus {
            pub left_operand: tymetafuncspec_core::Either<
                crate::cst::Heap,
                tymetafuncspec_core::Pair<
                    crate::cst::Heap,
                    crate::cst::LeftOperand,
                    tymetafuncspec_core::Maybe<
                        crate::cst::Heap,
                        std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                    >,
                >,
                std_parse_error::ParseError<crate::cst::Heap>,
            >,
            pub right_operand: tymetafuncspec_core::Either<
                crate::cst::Heap,
                tymetafuncspec_core::Pair<
                    crate::cst::Heap,
                    crate::cst::RightOperand,
                    tymetafuncspec_core::Maybe<
                        crate::cst::Heap,
                        std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                    >,
                >,
                std_parse_error::ParseError<crate::cst::Heap>,
            >,
        }
        pub struct LeftOperand {
            pub nat: tymetafuncspec_core::Either<
                crate::cst::Heap,
                crate::cst::Nat,
                std_parse_error::ParseError<crate::cst::Heap>,
            >,
        }
        pub struct RightOperand {
            pub nat: tymetafuncspec_core::Either<
                crate::cst::Heap,
                crate::cst::Nat,
                std_parse_error::ParseError<crate::cst::Heap>,
            >,
        }
        pub struct Sum {
            pub set: tymetafuncspec_core::Either<
                crate::cst::Heap,
                tymetafuncspec_core::Pair<
                    crate::cst::Heap,
                    tymetafuncspec_core::Set<
                        crate::cst::Heap,
                        tymetafuncspec_core::Either<
                            crate::cst::Heap,
                            crate::cst::Nat,
                            std_parse_error::ParseError<crate::cst::Heap>,
                        >,
                    >,
                    tymetafuncspec_core::Maybe<
                        crate::cst::Heap,
                        std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                    >,
                >,
                std_parse_error::ParseError<crate::cst::Heap>,
            >,
        }
        pub enum Nat {
            NatLit(
                tymetafuncspec_core::Pair<
                    crate::cst::Heap,
                    tymetafuncspec_core::BoundedNat<crate::cst::Heap>,
                    tymetafuncspec_core::Maybe<
                        crate::cst::Heap,
                        std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                    >,
                >,
            ),
            F(
                tymetafuncspec_core::Pair<
                    crate::cst::Heap,
                    tymetafuncspec_core::IdxBox<
                        crate::cst::Heap,
                        tymetafuncspec_core::Pair<
                            crate::cst::Heap,
                            crate::cst::F,
                            tymetafuncspec_core::Maybe<
                                crate::cst::Heap,
                                std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                            >,
                        >,
                    >,
                    tymetafuncspec_core::Maybe<
                        crate::cst::Heap,
                        std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                    >,
                >,
            ),
            Plus(
                tymetafuncspec_core::Pair<
                    crate::cst::Heap,
                    tymetafuncspec_core::IdxBox<
                        crate::cst::Heap,
                        tymetafuncspec_core::Pair<
                            crate::cst::Heap,
                            crate::cst::Plus,
                            tymetafuncspec_core::Maybe<
                                crate::cst::Heap,
                                std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                            >,
                        >,
                    >,
                    tymetafuncspec_core::Maybe<
                        crate::cst::Heap,
                        std_parse_metadata::ParseMetadata<crate::cst::Heap>,
                    >,
                >,
            ),
        }
        /// generated by [term_specialized_gen::gen_heaped_impls]
        pub mod heaped {
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::F {
                type Heap = crate::cst::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::Plus {
                type Heap = crate::cst::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::LeftOperand {
                type Heap = crate::cst::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::RightOperand {
                type Heap = crate::cst::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::Sum {
                type Heap = crate::cst::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::Nat {
                type Heap = crate::cst::Heap;
            }
        }
    }
    /// generated by [term_trait_gen::generate]
    pub mod extension_of {
        /// generated by [term_trait_gen::heap_trait]
        pub trait Heap: term::SuperHeap<
                tymetafuncspec_core::EitherHeapBak<
                    Self,
                    Self::Nat,
                    std_parse_error::ParseError<Self>,
                >,
            > + term::SuperHeap<
                std_parse_error::ParseErrorBak<Self>,
            > + term::SuperHeap<
                tymetafuncspec_core::EitherHeapBak<
                    Self,
                    tymetafuncspec_core::Pair<
                        Self,
                        Self::LeftOperand,
                        tymetafuncspec_core::Maybe<
                            Self,
                            std_parse_metadata::ParseMetadata<Self>,
                        >,
                    >,
                    std_parse_error::ParseError<Self>,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::PairHeapBak<
                    Self,
                    Self::LeftOperand,
                    tymetafuncspec_core::Maybe<
                        Self,
                        std_parse_metadata::ParseMetadata<Self>,
                    >,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::MaybeHeapBak<
                    Self,
                    std_parse_metadata::ParseMetadata<Self>,
                >,
            > + term::SuperHeap<
                std_parse_metadata::ParseMetadataBak<Self>,
            > + term::SuperHeap<
                tymetafuncspec_core::EitherHeapBak<
                    Self,
                    tymetafuncspec_core::Pair<
                        Self,
                        Self::RightOperand,
                        tymetafuncspec_core::Maybe<
                            Self,
                            std_parse_metadata::ParseMetadata<Self>,
                        >,
                    >,
                    std_parse_error::ParseError<Self>,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::PairHeapBak<
                    Self,
                    Self::RightOperand,
                    tymetafuncspec_core::Maybe<
                        Self,
                        std_parse_metadata::ParseMetadata<Self>,
                    >,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::EitherHeapBak<
                    Self,
                    tymetafuncspec_core::Pair<
                        Self,
                        tymetafuncspec_core::Set<
                            Self,
                            tymetafuncspec_core::Either<
                                Self,
                                Self::Nat,
                                std_parse_error::ParseError<Self>,
                            >,
                        >,
                        tymetafuncspec_core::Maybe<
                            Self,
                            std_parse_metadata::ParseMetadata<Self>,
                        >,
                    >,
                    std_parse_error::ParseError<Self>,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::PairHeapBak<
                    Self,
                    tymetafuncspec_core::Set<
                        Self,
                        tymetafuncspec_core::Either<
                            Self,
                            Self::Nat,
                            std_parse_error::ParseError<Self>,
                        >,
                    >,
                    tymetafuncspec_core::Maybe<
                        Self,
                        std_parse_metadata::ParseMetadata<Self>,
                    >,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::SetHeapBak<
                    Self,
                    tymetafuncspec_core::Either<
                        Self,
                        Self::Nat,
                        std_parse_error::ParseError<Self>,
                    >,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::PairHeapBak<
                    Self,
                    tymetafuncspec_core::BoundedNat<Self>,
                    tymetafuncspec_core::Maybe<
                        Self,
                        std_parse_metadata::ParseMetadata<Self>,
                    >,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::BoundedNatHeapBak<Self>,
            > + term::SuperHeap<
                tymetafuncspec_core::PairHeapBak<
                    Self,
                    tymetafuncspec_core::IdxBox<
                        Self,
                        tymetafuncspec_core::Pair<
                            Self,
                            Self::F,
                            tymetafuncspec_core::Maybe<
                                Self,
                                std_parse_metadata::ParseMetadata<Self>,
                            >,
                        >,
                    >,
                    tymetafuncspec_core::Maybe<
                        Self,
                        std_parse_metadata::ParseMetadata<Self>,
                    >,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::IdxBoxHeapBak<
                    Self,
                    tymetafuncspec_core::Pair<
                        Self,
                        Self::F,
                        tymetafuncspec_core::Maybe<
                            Self,
                            std_parse_metadata::ParseMetadata<Self>,
                        >,
                    >,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::PairHeapBak<
                    Self,
                    Self::F,
                    tymetafuncspec_core::Maybe<
                        Self,
                        std_parse_metadata::ParseMetadata<Self>,
                    >,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::PairHeapBak<
                    Self,
                    tymetafuncspec_core::IdxBox<
                        Self,
                        tymetafuncspec_core::Pair<
                            Self,
                            Self::Plus,
                            tymetafuncspec_core::Maybe<
                                Self,
                                std_parse_metadata::ParseMetadata<Self>,
                            >,
                        >,
                    >,
                    tymetafuncspec_core::Maybe<
                        Self,
                        std_parse_metadata::ParseMetadata<Self>,
                    >,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::IdxBoxHeapBak<
                    Self,
                    tymetafuncspec_core::Pair<
                        Self,
                        Self::Plus,
                        tymetafuncspec_core::Maybe<
                            Self,
                            std_parse_metadata::ParseMetadata<Self>,
                        >,
                    >,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::PairHeapBak<
                    Self,
                    Self::Plus,
                    tymetafuncspec_core::Maybe<
                        Self,
                        std_parse_metadata::ParseMetadata<Self>,
                    >,
                >,
            > + Sized {
            type F: crate::cst::owned::F<Heap = Self>;
            type Plus: crate::cst::owned::Plus<Heap = Self>;
            type LeftOperand: crate::cst::owned::LeftOperand<Heap = Self>;
            type RightOperand: crate::cst::owned::RightOperand<Heap = Self>;
            type Sum: crate::cst::owned::Sum<Heap = Self>;
            type Nat: crate::cst::owned::Nat<Heap = Self>;
        }
        /// generated by [term_trait_gen::owned::generate]
        pub mod owned {
            pub trait F: term::Heaped + term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            <<Self as term::Heaped>::Heap as crate::cst::Heap>::Nat,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                    ),
                >
            where
                <Self as term::Heaped>::Heap: crate::cst::Heap,
            {}
            pub trait Plus: term::Heaped + term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::Pair<
                                <Self as term::Heaped>::Heap,
                                <<Self as term::Heaped>::Heap as crate::cst::Heap>::LeftOperand,
                                tymetafuncspec_core::Maybe<
                                    <Self as term::Heaped>::Heap,
                                    std_parse_metadata::ParseMetadata<
                                        <Self as term::Heaped>::Heap,
                                    >,
                                >,
                            >,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::Pair<
                                <Self as term::Heaped>::Heap,
                                <<Self as term::Heaped>::Heap as crate::cst::Heap>::RightOperand,
                                tymetafuncspec_core::Maybe<
                                    <Self as term::Heaped>::Heap,
                                    std_parse_metadata::ParseMetadata<
                                        <Self as term::Heaped>::Heap,
                                    >,
                                >,
                            >,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                    ),
                >
            where
                <Self as term::Heaped>::Heap: crate::cst::Heap,
            {}
            pub trait LeftOperand: term::Heaped + term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            <<Self as term::Heaped>::Heap as crate::cst::Heap>::Nat,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                    ),
                >
            where
                <Self as term::Heaped>::Heap: crate::cst::Heap,
            {}
            pub trait RightOperand: term::Heaped + term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            <<Self as term::Heaped>::Heap as crate::cst::Heap>::Nat,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                    ),
                >
            where
                <Self as term::Heaped>::Heap: crate::cst::Heap,
            {}
            pub trait Sum: term::Heaped + term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::Pair<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Set<
                                    <Self as term::Heaped>::Heap,
                                    tymetafuncspec_core::Either<
                                        <Self as term::Heaped>::Heap,
                                        <<Self as term::Heaped>::Heap as crate::cst::Heap>::Nat,
                                        std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                                    >,
                                >,
                                tymetafuncspec_core::Maybe<
                                    <Self as term::Heaped>::Heap,
                                    std_parse_metadata::ParseMetadata<
                                        <Self as term::Heaped>::Heap,
                                    >,
                                >,
                            >,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                    ),
                >
            where
                <Self as term::Heaped>::Heap: crate::cst::Heap,
            {}
            pub trait Nat: term::Heaped + term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Pair<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::BoundedNat<
                                <Self as term::Heaped>::Heap,
                            >,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                std_parse_metadata::ParseMetadata<
                                    <Self as term::Heaped>::Heap,
                                >,
                            >,
                        >,
                    ),
                > + term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Pair<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::IdxBox<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Pair<
                                    <Self as term::Heaped>::Heap,
                                    <<Self as term::Heaped>::Heap as crate::cst::Heap>::F,
                                    tymetafuncspec_core::Maybe<
                                        <Self as term::Heaped>::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            <Self as term::Heaped>::Heap,
                                        >,
                                    >,
                                >,
                            >,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                std_parse_metadata::ParseMetadata<
                                    <Self as term::Heaped>::Heap,
                                >,
                            >,
                        >,
                    ),
                > + term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Pair<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::IdxBox<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Pair<
                                    <Self as term::Heaped>::Heap,
                                    <<Self as term::Heaped>::Heap as crate::cst::Heap>::Plus,
                                    tymetafuncspec_core::Maybe<
                                        <Self as term::Heaped>::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            <Self as term::Heaped>::Heap,
                                        >,
                                    >,
                                >,
                            >,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                std_parse_metadata::ParseMetadata<
                                    <Self as term::Heaped>::Heap,
                                >,
                            >,
                        >,
                    ),
                >
            where
                <Self as term::Heaped>::Heap: crate::cst::Heap,
            {}
        }
        /// generated by [term_trait_gen::reference::generate]
        pub mod reference {}
    }
    /// generated by [term_specialized_impl_gen::generate]
    pub mod term_impls {
        /// generated by [term_specialized_impl_gen::gen_heap_impl]
        impl crate::cst::Heap for crate::cst::Heap {
            type F = crate::cst::F;
            type Plus = crate::cst::Plus;
            type LeftOperand = crate::cst::LeftOperand;
            type RightOperand = crate::cst::RightOperand;
            type Sum = crate::cst::Sum;
            type Nat = crate::cst::Nat;
        }
        /// generated by [term_specialized_impl_gen::gen_owned_mod]
        pub mod owned_impls {
            impl crate::cst::owned::F for crate::cst::F {}
            impl crate::cst::owned::Plus for crate::cst::Plus {}
            impl crate::cst::owned::LeftOperand for crate::cst::LeftOperand {}
            impl crate::cst::owned::RightOperand for crate::cst::RightOperand {}
            impl crate::cst::owned::Sum for crate::cst::Sum {}
            impl crate::cst::owned::Nat for crate::cst::Nat {}
        }
        /// generated by [term_specialized_impl_gen::gen_ccf_mod]
        pub mod ccf_impls {
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod f {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                impl term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            crate::cst::Nat,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                    ),
                > for crate::cst::F {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::Either<
                                <Self as term::Heaped>::Heap,
                                crate::cst::Nat,
                                std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                            >,
                        ),
                    ) -> Self {
                        crate::cst::F { nat: t.0 }
                    }
                    fn deconstruct_succeeds(&self, heap: &Self::Heap) -> bool {
                        true
                    }
                    fn deconstruct(
                        self,
                        heap: &Self::Heap,
                    ) -> (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            crate::cst::Nat,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                    ) {
                        (self.nat,)
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod plus {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                impl term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::Pair<
                                <Self as term::Heaped>::Heap,
                                crate::cst::LeftOperand,
                                tymetafuncspec_core::Maybe<
                                    <Self as term::Heaped>::Heap,
                                    std_parse_metadata::ParseMetadata<
                                        <Self as term::Heaped>::Heap,
                                    >,
                                >,
                            >,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::Pair<
                                <Self as term::Heaped>::Heap,
                                crate::cst::RightOperand,
                                tymetafuncspec_core::Maybe<
                                    <Self as term::Heaped>::Heap,
                                    std_parse_metadata::ParseMetadata<
                                        <Self as term::Heaped>::Heap,
                                    >,
                                >,
                            >,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                    ),
                > for crate::cst::Plus {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::Either<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Pair<
                                    <Self as term::Heaped>::Heap,
                                    crate::cst::LeftOperand,
                                    tymetafuncspec_core::Maybe<
                                        <Self as term::Heaped>::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            <Self as term::Heaped>::Heap,
                                        >,
                                    >,
                                >,
                                std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                            >,
                            tymetafuncspec_core::Either<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Pair<
                                    <Self as term::Heaped>::Heap,
                                    crate::cst::RightOperand,
                                    tymetafuncspec_core::Maybe<
                                        <Self as term::Heaped>::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            <Self as term::Heaped>::Heap,
                                        >,
                                    >,
                                >,
                                std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                            >,
                        ),
                    ) -> Self {
                        crate::cst::Plus {
                            left_operand: t.0,
                            right_operand: t.1,
                        }
                    }
                    fn deconstruct_succeeds(&self, heap: &Self::Heap) -> bool {
                        true
                    }
                    fn deconstruct(
                        self,
                        heap: &Self::Heap,
                    ) -> (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::Pair<
                                <Self as term::Heaped>::Heap,
                                crate::cst::LeftOperand,
                                tymetafuncspec_core::Maybe<
                                    <Self as term::Heaped>::Heap,
                                    std_parse_metadata::ParseMetadata<
                                        <Self as term::Heaped>::Heap,
                                    >,
                                >,
                            >,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::Pair<
                                <Self as term::Heaped>::Heap,
                                crate::cst::RightOperand,
                                tymetafuncspec_core::Maybe<
                                    <Self as term::Heaped>::Heap,
                                    std_parse_metadata::ParseMetadata<
                                        <Self as term::Heaped>::Heap,
                                    >,
                                >,
                            >,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                    ) {
                        (self.left_operand, self.right_operand)
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod left_operand {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                impl term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            crate::cst::Nat,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                    ),
                > for crate::cst::LeftOperand {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::Either<
                                <Self as term::Heaped>::Heap,
                                crate::cst::Nat,
                                std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                            >,
                        ),
                    ) -> Self {
                        crate::cst::LeftOperand {
                            nat: t.0,
                        }
                    }
                    fn deconstruct_succeeds(&self, heap: &Self::Heap) -> bool {
                        true
                    }
                    fn deconstruct(
                        self,
                        heap: &Self::Heap,
                    ) -> (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            crate::cst::Nat,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                    ) {
                        (self.nat,)
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod right_operand {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                impl term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            crate::cst::Nat,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                    ),
                > for crate::cst::RightOperand {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::Either<
                                <Self as term::Heaped>::Heap,
                                crate::cst::Nat,
                                std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                            >,
                        ),
                    ) -> Self {
                        crate::cst::RightOperand {
                            nat: t.0,
                        }
                    }
                    fn deconstruct_succeeds(&self, heap: &Self::Heap) -> bool {
                        true
                    }
                    fn deconstruct(
                        self,
                        heap: &Self::Heap,
                    ) -> (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            crate::cst::Nat,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                    ) {
                        (self.nat,)
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod sum {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                impl term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::Pair<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Set<
                                    <Self as term::Heaped>::Heap,
                                    tymetafuncspec_core::Either<
                                        <Self as term::Heaped>::Heap,
                                        crate::cst::Nat,
                                        std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                                    >,
                                >,
                                tymetafuncspec_core::Maybe<
                                    <Self as term::Heaped>::Heap,
                                    std_parse_metadata::ParseMetadata<
                                        <Self as term::Heaped>::Heap,
                                    >,
                                >,
                            >,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                    ),
                > for crate::cst::Sum {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::Either<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Pair<
                                    <Self as term::Heaped>::Heap,
                                    tymetafuncspec_core::Set<
                                        <Self as term::Heaped>::Heap,
                                        tymetafuncspec_core::Either<
                                            <Self as term::Heaped>::Heap,
                                            crate::cst::Nat,
                                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                                        >,
                                    >,
                                    tymetafuncspec_core::Maybe<
                                        <Self as term::Heaped>::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            <Self as term::Heaped>::Heap,
                                        >,
                                    >,
                                >,
                                std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                            >,
                        ),
                    ) -> Self {
                        crate::cst::Sum { set: t.0 }
                    }
                    fn deconstruct_succeeds(&self, heap: &Self::Heap) -> bool {
                        true
                    }
                    fn deconstruct(
                        self,
                        heap: &Self::Heap,
                    ) -> (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::Pair<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Set<
                                    <Self as term::Heaped>::Heap,
                                    tymetafuncspec_core::Either<
                                        <Self as term::Heaped>::Heap,
                                        crate::cst::Nat,
                                        std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                                    >,
                                >,
                                tymetafuncspec_core::Maybe<
                                    <Self as term::Heaped>::Heap,
                                    std_parse_metadata::ParseMetadata<
                                        <Self as term::Heaped>::Heap,
                                    >,
                                >,
                            >,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                    ) {
                        (self.set,)
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod nat {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
                impl term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Pair<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::BoundedNat<
                                <Self as term::Heaped>::Heap,
                            >,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                std_parse_metadata::ParseMetadata<
                                    <Self as term::Heaped>::Heap,
                                >,
                            >,
                        >,
                    ),
                > for crate::cst::Nat {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::Pair<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::BoundedNat<
                                    <Self as term::Heaped>::Heap,
                                >,
                                tymetafuncspec_core::Maybe<
                                    <Self as term::Heaped>::Heap,
                                    std_parse_metadata::ParseMetadata<
                                        <Self as term::Heaped>::Heap,
                                    >,
                                >,
                            >,
                        ),
                    ) -> Self {
                        crate::cst::Nat::NatLit(t.0)
                    }
                    fn deconstruct_succeeds(&self, heap: &Self::Heap) -> bool {
                        match self {
                            crate::cst::Nat::NatLit(_) => true,
                            _ => false,
                        }
                    }
                    fn deconstruct(
                        self,
                        heap: &Self::Heap,
                    ) -> (
                        tymetafuncspec_core::Pair<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::BoundedNat<
                                <Self as term::Heaped>::Heap,
                            >,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                std_parse_metadata::ParseMetadata<
                                    <Self as term::Heaped>::Heap,
                                >,
                            >,
                        >,
                    ) {
                        match self {
                            crate::cst::Nat::NatLit(t) => (t,),
                            _ => panic!("conversion failure"),
                        }
                    }
                }
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
                impl term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Pair<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::IdxBox<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Pair<
                                    <Self as term::Heaped>::Heap,
                                    crate::cst::F,
                                    tymetafuncspec_core::Maybe<
                                        <Self as term::Heaped>::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            <Self as term::Heaped>::Heap,
                                        >,
                                    >,
                                >,
                            >,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                std_parse_metadata::ParseMetadata<
                                    <Self as term::Heaped>::Heap,
                                >,
                            >,
                        >,
                    ),
                > for crate::cst::Nat {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::Pair<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::IdxBox<
                                    <Self as term::Heaped>::Heap,
                                    tymetafuncspec_core::Pair<
                                        <Self as term::Heaped>::Heap,
                                        crate::cst::F,
                                        tymetafuncspec_core::Maybe<
                                            <Self as term::Heaped>::Heap,
                                            std_parse_metadata::ParseMetadata<
                                                <Self as term::Heaped>::Heap,
                                            >,
                                        >,
                                    >,
                                >,
                                tymetafuncspec_core::Maybe<
                                    <Self as term::Heaped>::Heap,
                                    std_parse_metadata::ParseMetadata<
                                        <Self as term::Heaped>::Heap,
                                    >,
                                >,
                            >,
                        ),
                    ) -> Self {
                        crate::cst::Nat::F(t.0)
                    }
                    fn deconstruct_succeeds(&self, heap: &Self::Heap) -> bool {
                        match self {
                            crate::cst::Nat::F(_) => true,
                            _ => false,
                        }
                    }
                    fn deconstruct(
                        self,
                        heap: &Self::Heap,
                    ) -> (
                        tymetafuncspec_core::Pair<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::IdxBox<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Pair<
                                    <Self as term::Heaped>::Heap,
                                    crate::cst::F,
                                    tymetafuncspec_core::Maybe<
                                        <Self as term::Heaped>::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            <Self as term::Heaped>::Heap,
                                        >,
                                    >,
                                >,
                            >,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                std_parse_metadata::ParseMetadata<
                                    <Self as term::Heaped>::Heap,
                                >,
                            >,
                        >,
                    ) {
                        match self {
                            crate::cst::Nat::F(t) => (t,),
                            _ => panic!("conversion failure"),
                        }
                    }
                }
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
                impl term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Pair<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::IdxBox<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Pair<
                                    <Self as term::Heaped>::Heap,
                                    crate::cst::Plus,
                                    tymetafuncspec_core::Maybe<
                                        <Self as term::Heaped>::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            <Self as term::Heaped>::Heap,
                                        >,
                                    >,
                                >,
                            >,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                std_parse_metadata::ParseMetadata<
                                    <Self as term::Heaped>::Heap,
                                >,
                            >,
                        >,
                    ),
                > for crate::cst::Nat {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::Pair<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::IdxBox<
                                    <Self as term::Heaped>::Heap,
                                    tymetafuncspec_core::Pair<
                                        <Self as term::Heaped>::Heap,
                                        crate::cst::Plus,
                                        tymetafuncspec_core::Maybe<
                                            <Self as term::Heaped>::Heap,
                                            std_parse_metadata::ParseMetadata<
                                                <Self as term::Heaped>::Heap,
                                            >,
                                        >,
                                    >,
                                >,
                                tymetafuncspec_core::Maybe<
                                    <Self as term::Heaped>::Heap,
                                    std_parse_metadata::ParseMetadata<
                                        <Self as term::Heaped>::Heap,
                                    >,
                                >,
                            >,
                        ),
                    ) -> Self {
                        crate::cst::Nat::Plus(t.0)
                    }
                    fn deconstruct_succeeds(&self, heap: &Self::Heap) -> bool {
                        match self {
                            crate::cst::Nat::Plus(_) => true,
                            _ => false,
                        }
                    }
                    fn deconstruct(
                        self,
                        heap: &Self::Heap,
                    ) -> (
                        tymetafuncspec_core::Pair<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::IdxBox<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Pair<
                                    <Self as term::Heaped>::Heap,
                                    crate::cst::Plus,
                                    tymetafuncspec_core::Maybe<
                                        <Self as term::Heaped>::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            <Self as term::Heaped>::Heap,
                                        >,
                                    >,
                                >,
                            >,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                std_parse_metadata::ParseMetadata<
                                    <Self as term::Heaped>::Heap,
                                >,
                            >,
                        >,
                    ) {
                        match self {
                            crate::cst::Nat::Plus(t) => (t,),
                            _ => panic!("conversion failure"),
                        }
                    }
                }
            }
        }
        /// generated by [term_specialized_impl_gen::gen_mct_mod]
        pub mod mct_impls {}
    }
}
