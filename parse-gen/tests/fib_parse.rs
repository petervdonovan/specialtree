/// generated by [parse_gen::generate]
pub mod parse {
    /// generated by [parse_gen::generate_parse]
    impl parse::Parse for crate::cst::data_structure::F {
        fn parse(
            source: &str,
            offset: parse::miette::SourceOffset,
            heap: &mut crate::cst::data_structure::Heap,
            errors: &mut Vec<parse::ParseError>,
        ) -> Result<(crate::cst::data_structure::F, parse::miette::SourceOffset), parse::ParseError>
        {
            let mut ute = None;
            /// generated by [parse_gen::gen_parse_current]
            fn parse_directly(
                source: &str,
                offset: parse::miette::SourceOffset,
                heap: &mut crate::cst::data_structure::Heap,
                errors: &mut Vec<parse::ParseError>,
                default_ret: Result<
                    (crate::cst::data_structure::F, parse::miette::SourceOffset),
                    parse::ParseError,
                >,
            ) -> Result<
                (crate::cst::data_structure::F, parse::miette::SourceOffset),
                parse::ParseError,
            > {
                match parse::unicode_segmentation::UnicodeSegmentation::unicode_words(
                    &source[offset.offset()..],
                )
                .next()
                {
                    Some(stringify!(f)) => {
                        let mut offset = offset;
                        let args = (
                            {
                                let res = <tymetafuncspec_core::Either<
                                    crate::cst::data_structure::Heap,
                                    crate::cst::data_structure::Nat,
                                    crate::cst::data_structure::Error,
                                > as parse::Parse>::parse(
                                    source, offset, heap, errors
                                );
                                match res {
                                    Ok((cst, new_offset)) => {
                                        offset = new_offset;
                                        cst
                                    }
                                    Err(e) => {
                                        errors.push(e);
                                        tymetafuncspec_core::Either::Right(
                                            <crate::cst::data_structure::Error as term::CanonicallyConstructibleFrom<
                                                (
                                                    tymetafuncspec_core::Maybe<
                                                        crate::cst::data_structure::Heap,
                                                        crate::cst::data_structure::Metadata,
                                                    >,
                                                ),
                                            >>::construct(heap, (tymetafuncspec_core::Maybe::Nothing,)),
                                            std::marker::PhantomData,
                                        )
                                    }
                                }
                            },
                            tymetafuncspec_core::Maybe::Nothing,
                        );
                        Ok((
                            <crate::cst::data_structure::F as term::CanonicallyConstructibleFrom<
                                (
                                    tymetafuncspec_core::Either<
                                        crate::cst::data_structure::Heap,
                                        crate::cst::data_structure::Nat,
                                        crate::cst::data_structure::Error,
                                    >,
                                    tymetafuncspec_core::Maybe<
                                        crate::cst::data_structure::Heap,
                                        crate::cst::data_structure::Metadata,
                                    >,
                                ),
                            >>::construct(heap, args),
                            offset,
                        ))
                    }
                    None => Err(parse::ParseError::UnexpectedEndOfInput(offset.into())),
                    _ => default_ret,
                }
            }
            parse_directly(source, offset, heap, errors, Err(ute.unwrap()))
        }
    }
    /// generated by [parse_gen::generate_parse]
    impl parse::Parse for crate::cst::data_structure::Plus {
        fn parse(
            source: &str,
            offset: parse::miette::SourceOffset,
            heap: &mut crate::cst::data_structure::Heap,
            errors: &mut Vec<parse::ParseError>,
        ) -> Result<
            (
                crate::cst::data_structure::Plus,
                parse::miette::SourceOffset,
            ),
            parse::ParseError,
        > {
            let mut ute = None;
            /// generated by [parse_gen::gen_parse_current]
            fn parse_directly(
                source: &str,
                offset: parse::miette::SourceOffset,
                heap: &mut crate::cst::data_structure::Heap,
                errors: &mut Vec<parse::ParseError>,
                default_ret: Result<
                    (
                        crate::cst::data_structure::Plus,
                        parse::miette::SourceOffset,
                    ),
                    parse::ParseError,
                >,
            ) -> Result<
                (
                    crate::cst::data_structure::Plus,
                    parse::miette::SourceOffset,
                ),
                parse::ParseError,
            > {
                match parse::unicode_segmentation::UnicodeSegmentation::unicode_words(
                    &source[offset.offset()..],
                )
                .next()
                {
                    Some(stringify!(plus)) => {
                        let mut offset = offset;
                        let args = (
                            {
                                let res = <tymetafuncspec_core::Either<
                                    crate::cst::data_structure::Heap,
                                    crate::cst::data_structure::LeftOperand,
                                    crate::cst::data_structure::Error,
                                > as parse::Parse>::parse(
                                    source, offset, heap, errors
                                );
                                match res {
                                    Ok((cst, new_offset)) => {
                                        offset = new_offset;
                                        cst
                                    }
                                    Err(e) => {
                                        errors.push(e);
                                        tymetafuncspec_core::Either::Right(
                                            <crate::cst::data_structure::Error as term::CanonicallyConstructibleFrom<
                                                (
                                                    tymetafuncspec_core::Maybe<
                                                        crate::cst::data_structure::Heap,
                                                        crate::cst::data_structure::Metadata,
                                                    >,
                                                ),
                                            >>::construct(heap, (tymetafuncspec_core::Maybe::Nothing,)),
                                            std::marker::PhantomData,
                                        )
                                    }
                                }
                            },
                            {
                                let res = <tymetafuncspec_core::Either<
                                    crate::cst::data_structure::Heap,
                                    crate::cst::data_structure::RightOperand,
                                    crate::cst::data_structure::Error,
                                > as parse::Parse>::parse(
                                    source, offset, heap, errors
                                );
                                match res {
                                    Ok((cst, new_offset)) => {
                                        offset = new_offset;
                                        cst
                                    }
                                    Err(e) => {
                                        errors.push(e);
                                        tymetafuncspec_core::Either::Right(
                                            <crate::cst::data_structure::Error as term::CanonicallyConstructibleFrom<
                                                (
                                                    tymetafuncspec_core::Maybe<
                                                        crate::cst::data_structure::Heap,
                                                        crate::cst::data_structure::Metadata,
                                                    >,
                                                ),
                                            >>::construct(heap, (tymetafuncspec_core::Maybe::Nothing,)),
                                            std::marker::PhantomData,
                                        )
                                    }
                                }
                            },
                            tymetafuncspec_core::Maybe::Nothing,
                        );
                        Ok((
                            <crate::cst::data_structure::Plus as term::CanonicallyConstructibleFrom<
                                (
                                    tymetafuncspec_core::Either<
                                        crate::cst::data_structure::Heap,
                                        crate::cst::data_structure::LeftOperand,
                                        crate::cst::data_structure::Error,
                                    >,
                                    tymetafuncspec_core::Either<
                                        crate::cst::data_structure::Heap,
                                        crate::cst::data_structure::RightOperand,
                                        crate::cst::data_structure::Error,
                                    >,
                                    tymetafuncspec_core::Maybe<
                                        crate::cst::data_structure::Heap,
                                        crate::cst::data_structure::Metadata,
                                    >,
                                ),
                            >>::construct(heap, args),
                            offset,
                        ))
                    }
                    None => Err(parse::ParseError::UnexpectedEndOfInput(offset.into())),
                    _ => default_ret,
                }
            }
            parse_directly(source, offset, heap, errors, Err(ute.unwrap()))
        }
    }
    /// generated by [parse_gen::generate_parse]
    impl parse::Parse for crate::cst::data_structure::LeftOperand {
        fn parse(
            source: &str,
            offset: parse::miette::SourceOffset,
            heap: &mut crate::cst::data_structure::Heap,
            errors: &mut Vec<parse::ParseError>,
        ) -> Result<
            (
                crate::cst::data_structure::LeftOperand,
                parse::miette::SourceOffset,
            ),
            parse::ParseError,
        > {
            let mut ute = None;
            /// generated by [parse_gen::gen_parse_current]
            fn parse_directly(
                source: &str,
                offset: parse::miette::SourceOffset,
                heap: &mut crate::cst::data_structure::Heap,
                errors: &mut Vec<parse::ParseError>,
                default_ret: Result<
                    (
                        crate::cst::data_structure::LeftOperand,
                        parse::miette::SourceOffset,
                    ),
                    parse::ParseError,
                >,
            ) -> Result<
                (
                    crate::cst::data_structure::LeftOperand,
                    parse::miette::SourceOffset,
                ),
                parse::ParseError,
            > {
                match parse::unicode_segmentation::UnicodeSegmentation::unicode_words(
                    &source[offset.offset()..],
                )
                .next()
                {
                    Some(stringify!(left_operand)) => {
                        let mut offset = offset;
                        let args = (
                            {
                                let res = <tymetafuncspec_core::Either<
                                    crate::cst::data_structure::Heap,
                                    crate::cst::data_structure::Nat,
                                    crate::cst::data_structure::Error,
                                > as parse::Parse>::parse(
                                    source, offset, heap, errors
                                );
                                match res {
                                    Ok((cst, new_offset)) => {
                                        offset = new_offset;
                                        cst
                                    }
                                    Err(e) => {
                                        errors.push(e);
                                        tymetafuncspec_core::Either::Right(
                                            <crate::cst::data_structure::Error as term::CanonicallyConstructibleFrom<
                                                (
                                                    tymetafuncspec_core::Maybe<
                                                        crate::cst::data_structure::Heap,
                                                        crate::cst::data_structure::Metadata,
                                                    >,
                                                ),
                                            >>::construct(heap, (tymetafuncspec_core::Maybe::Nothing,)),
                                            std::marker::PhantomData,
                                        )
                                    }
                                }
                            },
                            tymetafuncspec_core::Maybe::Nothing,
                        );
                        Ok((
                            <crate::cst::data_structure::LeftOperand as term::CanonicallyConstructibleFrom<
                                (
                                    tymetafuncspec_core::Either<
                                        crate::cst::data_structure::Heap,
                                        crate::cst::data_structure::Nat,
                                        crate::cst::data_structure::Error,
                                    >,
                                    tymetafuncspec_core::Maybe<
                                        crate::cst::data_structure::Heap,
                                        crate::cst::data_structure::Metadata,
                                    >,
                                ),
                            >>::construct(heap, args),
                            offset,
                        ))
                    }
                    None => Err(parse::ParseError::UnexpectedEndOfInput(offset.into())),
                    _ => default_ret,
                }
            }
            parse_directly(source, offset, heap, errors, Err(ute.unwrap()))
        }
    }
    /// generated by [parse_gen::generate_parse]
    impl parse::Parse for crate::cst::data_structure::RightOperand {
        fn parse(
            source: &str,
            offset: parse::miette::SourceOffset,
            heap: &mut crate::cst::data_structure::Heap,
            errors: &mut Vec<parse::ParseError>,
        ) -> Result<
            (
                crate::cst::data_structure::RightOperand,
                parse::miette::SourceOffset,
            ),
            parse::ParseError,
        > {
            let mut ute = None;
            /// generated by [parse_gen::gen_parse_current]
            fn parse_directly(
                source: &str,
                offset: parse::miette::SourceOffset,
                heap: &mut crate::cst::data_structure::Heap,
                errors: &mut Vec<parse::ParseError>,
                default_ret: Result<
                    (
                        crate::cst::data_structure::RightOperand,
                        parse::miette::SourceOffset,
                    ),
                    parse::ParseError,
                >,
            ) -> Result<
                (
                    crate::cst::data_structure::RightOperand,
                    parse::miette::SourceOffset,
                ),
                parse::ParseError,
            > {
                match parse::unicode_segmentation::UnicodeSegmentation::unicode_words(
                    &source[offset.offset()..],
                )
                .next()
                {
                    Some(stringify!(right_operand)) => {
                        let mut offset = offset;
                        let args = (
                            {
                                let res = <tymetafuncspec_core::Either<
                                    crate::cst::data_structure::Heap,
                                    crate::cst::data_structure::Nat,
                                    crate::cst::data_structure::Error,
                                > as parse::Parse>::parse(
                                    source, offset, heap, errors
                                );
                                match res {
                                    Ok((cst, new_offset)) => {
                                        offset = new_offset;
                                        cst
                                    }
                                    Err(e) => {
                                        errors.push(e);
                                        tymetafuncspec_core::Either::Right(
                                            <crate::cst::data_structure::Error as term::CanonicallyConstructibleFrom<
                                                (
                                                    tymetafuncspec_core::Maybe<
                                                        crate::cst::data_structure::Heap,
                                                        crate::cst::data_structure::Metadata,
                                                    >,
                                                ),
                                            >>::construct(heap, (tymetafuncspec_core::Maybe::Nothing,)),
                                            std::marker::PhantomData,
                                        )
                                    }
                                }
                            },
                            tymetafuncspec_core::Maybe::Nothing,
                        );
                        Ok((
                            <crate::cst::data_structure::RightOperand as term::CanonicallyConstructibleFrom<
                                (
                                    tymetafuncspec_core::Either<
                                        crate::cst::data_structure::Heap,
                                        crate::cst::data_structure::Nat,
                                        crate::cst::data_structure::Error,
                                    >,
                                    tymetafuncspec_core::Maybe<
                                        crate::cst::data_structure::Heap,
                                        crate::cst::data_structure::Metadata,
                                    >,
                                ),
                            >>::construct(heap, args),
                            offset,
                        ))
                    }
                    None => Err(parse::ParseError::UnexpectedEndOfInput(offset.into())),
                    _ => default_ret,
                }
            }
            parse_directly(source, offset, heap, errors, Err(ute.unwrap()))
        }
    }
    /// generated by [parse_gen::generate_parse]
    impl parse::Parse for crate::cst::data_structure::Sum {
        fn parse(
            source: &str,
            offset: parse::miette::SourceOffset,
            heap: &mut crate::cst::data_structure::Heap,
            errors: &mut Vec<parse::ParseError>,
        ) -> Result<(crate::cst::data_structure::Sum, parse::miette::SourceOffset), parse::ParseError>
        {
            let mut ute = None;
            /// generated by [parse_gen::gen_parse_current]
            fn parse_directly(
                source: &str,
                offset: parse::miette::SourceOffset,
                heap: &mut crate::cst::data_structure::Heap,
                errors: &mut Vec<parse::ParseError>,
                default_ret: Result<
                    (crate::cst::data_structure::Sum, parse::miette::SourceOffset),
                    parse::ParseError,
                >,
            ) -> Result<
                (crate::cst::data_structure::Sum, parse::miette::SourceOffset),
                parse::ParseError,
            > {
                match parse::unicode_segmentation::UnicodeSegmentation::unicode_words(
                    &source[offset.offset()..],
                )
                .next()
                {
                    Some(stringify!(sum)) => {
                        let mut offset = offset;
                        let args = (
                            {
                                let res = <tymetafuncspec_core::Either<
                                    crate::cst::data_structure::Heap,
                                    tymetafuncspec_core::Set<
                                        crate::cst::data_structure::Heap,
                                        tymetafuncspec_core::Either<
                                            crate::cst::data_structure::Heap,
                                            crate::cst::data_structure::Nat,
                                            crate::cst::data_structure::Error,
                                        >,
                                    >,
                                    crate::cst::data_structure::Error,
                                > as parse::Parse>::parse(
                                    source, offset, heap, errors
                                );
                                match res {
                                    Ok((cst, new_offset)) => {
                                        offset = new_offset;
                                        cst
                                    }
                                    Err(e) => {
                                        errors.push(e);
                                        tymetafuncspec_core::Either::Right(
                                            <crate::cst::data_structure::Error as term::CanonicallyConstructibleFrom<
                                                (
                                                    tymetafuncspec_core::Maybe<
                                                        crate::cst::data_structure::Heap,
                                                        crate::cst::data_structure::Metadata,
                                                    >,
                                                ),
                                            >>::construct(heap, (tymetafuncspec_core::Maybe::Nothing,)),
                                            std::marker::PhantomData,
                                        )
                                    }
                                }
                            },
                            tymetafuncspec_core::Maybe::Nothing,
                        );
                        Ok((
                            <crate::cst::data_structure::Sum as term::CanonicallyConstructibleFrom<
                                (
                                    tymetafuncspec_core::Either<
                                        crate::cst::data_structure::Heap,
                                        tymetafuncspec_core::Set<
                                            crate::cst::data_structure::Heap,
                                            tymetafuncspec_core::Either<
                                                crate::cst::data_structure::Heap,
                                                crate::cst::data_structure::Nat,
                                                crate::cst::data_structure::Error,
                                            >,
                                        >,
                                        crate::cst::data_structure::Error,
                                    >,
                                    tymetafuncspec_core::Maybe<
                                        crate::cst::data_structure::Heap,
                                        crate::cst::data_structure::Metadata,
                                    >,
                                ),
                            >>::construct(heap, args),
                            offset,
                        ))
                    }
                    None => Err(parse::ParseError::UnexpectedEndOfInput(offset.into())),
                    _ => default_ret,
                }
            }
            parse_directly(source, offset, heap, errors, Err(ute.unwrap()))
        }
    }
    /// generated by [parse_gen::generate_parse]
    impl parse::Parse for crate::cst::data_structure::Nat {
        fn parse(
            source: &str,
            offset: parse::miette::SourceOffset,
            heap: &mut crate::cst::data_structure::Heap,
            errors: &mut Vec<parse::ParseError>,
        ) -> Result<(crate::cst::data_structure::Nat, parse::miette::SourceOffset), parse::ParseError>
        {
            let mut ute = None;
            let parse_directly = |_, _, _, _, ret| ret;
            match <tymetafuncspec_core::Maybe<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::Metadata,
            > as parse::Parse>::parse(source, offset, heap, errors)
            {
                Ok((cst, offset)) => {
                    return Ok((
                        <crate::cst::data_structure::Nat as term::CanonicallyConstructibleFrom<
                            (
                                tymetafuncspec_core::Maybe<
                                    crate::cst::data_structure::Heap,
                                    crate::cst::data_structure::Metadata,
                                >,
                            ),
                        >>::construct(
                            heap,
                            (
                                tymetafuncspec_core::Either::Left(cst, std::marker::PhantomData),
                                tymetafuncspec_core::Maybe::Nothing,
                            ),
                        ),
                        offset,
                    ));
                }
                Err(e) => {
                    ute = parse::ParseError::merge_over(e, ute);
                }
            }
            parse_directly(source, offset, heap, errors, Err(ute.unwrap()))
        }
    }
}
pub mod cst {
    /// generated by [term_specialized_gen::generate]
    pub mod data_structure {
        /// generated by [term_specialized_gen::gen_heap]
        #[derive(Default)]
        pub struct Heap {
            either: crate::cst::data_structure::heap::either::Bak,
            maybe: crate::cst::data_structure::heap::maybe::Bak,
            nat_lit: crate::cst::data_structure::heap::nat_lit::Bak,
            idx_box: crate::cst::data_structure::heap::idx_box::Bak,
        }
        pub mod heap {
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[derive(Default)]
            pub struct Bak {
                pub either: crate::cst::data_structure::heap::either::Bak,
                pub maybe: crate::cst::data_structure::heap::maybe::Bak,
                pub nat_lit: crate::cst::data_structure::heap::nat_lit::Bak,
                pub idx_box: crate::cst::data_structure::heap::idx_box::Bak,
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod either {
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[derive(Default)]
                pub struct Bak {
                    pub nat: crate::cst::data_structure::heap::either::nat::Bak,
                    pub left_operand: crate::cst::data_structure::heap::either::left_operand::Bak,
                    pub right_operand: crate::cst::data_structure::heap::either::right_operand::Bak,
                    pub set: crate::cst::data_structure::heap::either::set::Bak,
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod nat {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub error: crate::cst::data_structure::heap::either::nat::error::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod error {
                        /// generated by [term_specialized_gen::gen_heapbak_module]
                        #[derive(Default)]
                        pub struct Bak(
                            pub  tymetafuncspec_core::EitherHeapBak<
                                crate::cst::data_structure::Heap,
                                crate::cst::data_structure::Nat,
                                crate::cst::data_structure::Error,
                            >,
                        );
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod left_operand {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub error:
                            crate::cst::data_structure::heap::either::left_operand::error::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod error {
                        /// generated by [term_specialized_gen::gen_heapbak_module]
                        #[derive(Default)]
                        pub struct Bak(
                            pub  tymetafuncspec_core::EitherHeapBak<
                                crate::cst::data_structure::Heap,
                                crate::cst::data_structure::LeftOperand,
                                crate::cst::data_structure::Error,
                            >,
                        );
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod right_operand {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub error:
                            crate::cst::data_structure::heap::either::right_operand::error::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod error {
                        /// generated by [term_specialized_gen::gen_heapbak_module]
                        #[derive(Default)]
                        pub struct Bak(
                            pub  tymetafuncspec_core::EitherHeapBak<
                                crate::cst::data_structure::Heap,
                                crate::cst::data_structure::RightOperand,
                                crate::cst::data_structure::Error,
                            >,
                        );
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod set {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub error: crate::cst::data_structure::heap::either::set::error::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod error {
                        /// generated by [term_specialized_gen::gen_heapbak_module]
                        #[derive(Default)]
                        pub struct Bak(
                            pub  tymetafuncspec_core::EitherHeapBak<
                                crate::cst::data_structure::Heap,
                                tymetafuncspec_core::Set<
                                    crate::cst::data_structure::Heap,
                                    tymetafuncspec_core::Either<
                                        crate::cst::data_structure::Heap,
                                        crate::cst::data_structure::Nat,
                                        crate::cst::data_structure::Error,
                                    >,
                                >,
                                crate::cst::data_structure::Error,
                            >,
                        );
                    }
                }
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod maybe {
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[derive(Default)]
                pub struct Bak {
                    pub metadata: crate::cst::data_structure::heap::maybe::metadata::Bak,
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod metadata {
                    /// generated by [term_specialized_gen::gen_heapbak_module]
                    #[derive(Default)]
                    pub struct Bak(
                        pub  tymetafuncspec_core::MaybeHeapBak<
                            crate::cst::data_structure::Heap,
                            crate::cst::data_structure::Metadata,
                        >,
                    );
                }
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod nat_lit {
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[derive(Default)]
                pub struct Bak(
                    pub tymetafuncspec_core::BoundedNatHeapBak<crate::cst::data_structure::Heap>,
                );
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod idx_box {
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[derive(Default)]
                pub struct Bak {
                    pub f: crate::cst::data_structure::heap::idx_box::f::Bak,
                    pub plus: crate::cst::data_structure::heap::idx_box::plus::Bak,
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod f {
                    /// generated by [term_specialized_gen::gen_heapbak_module]
                    #[derive(Default)]
                    pub struct Bak(
                        pub  tymetafuncspec_core::IdxBoxHeapBak<
                            crate::cst::data_structure::Heap,
                            crate::cst::data_structure::F,
                        >,
                    );
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod plus {
                    /// generated by [term_specialized_gen::gen_heapbak_module]
                    #[derive(Default)]
                    pub struct Bak(
                        pub  tymetafuncspec_core::IdxBoxHeapBak<
                            crate::cst::data_structure::Heap,
                            crate::cst::data_structure::Plus,
                        >,
                    );
                }
            }
        }
        pub mod superheap {
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::EitherHeapBak <
                crate ::cst::data_structure::Heap, crate ::cst::data_structure::Nat,
                crate ::cst::data_structure::Error >; either nat error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::MaybeHeapBak <
                crate ::cst::data_structure::Heap, crate ::cst::data_structure::Metadata
                >; maybe metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::EitherHeapBak <
                crate ::cst::data_structure::Heap, crate
                ::cst::data_structure::LeftOperand, crate ::cst::data_structure::Error >;
                either left_operand error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::EitherHeapBak <
                crate ::cst::data_structure::Heap, crate
                ::cst::data_structure::RightOperand, crate ::cst::data_structure::Error
                >; either right_operand error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::EitherHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Set < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Nat, crate
                ::cst::data_structure::Error, >, >, crate ::cst::data_structure::Error >;
                either set error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::BoundedNatHeapBak
                < crate ::cst::data_structure::Heap, >; nat_lit
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::IdxBoxHeapBak <
                crate ::cst::data_structure::Heap, crate ::cst::data_structure::F >;
                idx_box f
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::IdxBoxHeapBak <
                crate ::cst::data_structure::Heap, crate ::cst::data_structure::Plus >;
                idx_box plus
            );
        }
        pub struct F {
            pub nat: tymetafuncspec_core::Either<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::Nat,
                crate::cst::data_structure::Error,
            >,
            pub metadata: tymetafuncspec_core::Maybe<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::Metadata,
            >,
        }
        pub struct Plus {
            pub left_operand: tymetafuncspec_core::Either<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::LeftOperand,
                crate::cst::data_structure::Error,
            >,
            pub right_operand: tymetafuncspec_core::Either<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::RightOperand,
                crate::cst::data_structure::Error,
            >,
            pub metadata: tymetafuncspec_core::Maybe<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::Metadata,
            >,
        }
        pub struct LeftOperand {
            pub nat: tymetafuncspec_core::Either<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::Nat,
                crate::cst::data_structure::Error,
            >,
            pub metadata: tymetafuncspec_core::Maybe<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::Metadata,
            >,
        }
        pub struct RightOperand {
            pub nat: tymetafuncspec_core::Either<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::Nat,
                crate::cst::data_structure::Error,
            >,
            pub metadata: tymetafuncspec_core::Maybe<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::Metadata,
            >,
        }
        pub struct Sum {
            pub set: tymetafuncspec_core::Either<
                crate::cst::data_structure::Heap,
                tymetafuncspec_core::Set<
                    crate::cst::data_structure::Heap,
                    tymetafuncspec_core::Either<
                        crate::cst::data_structure::Heap,
                        crate::cst::data_structure::Nat,
                        crate::cst::data_structure::Error,
                    >,
                >,
                crate::cst::data_structure::Error,
            >,
            pub metadata: tymetafuncspec_core::Maybe<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::Metadata,
            >,
        }
        pub struct Error {
            pub metadata: tymetafuncspec_core::Maybe<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::Metadata,
            >,
        }
        pub struct Column {
            pub nat_lit: tymetafuncspec_core::BoundedNat<crate::cst::data_structure::Heap>,
        }
        pub struct EndPosition {
            pub line: crate::cst::data_structure::Line,
            pub column: crate::cst::data_structure::Column,
        }
        pub struct Line {
            pub nat_lit: tymetafuncspec_core::BoundedNat<crate::cst::data_structure::Heap>,
        }
        pub struct Metadata {
            pub start_position: crate::cst::data_structure::StartPosition,
            pub end_position: crate::cst::data_structure::EndPosition,
        }
        pub struct StartPosition {
            pub line: crate::cst::data_structure::Line,
            pub column: crate::cst::data_structure::Column,
        }
        pub enum Nat {
            NatLit(tymetafuncspec_core::BoundedNat<crate::cst::data_structure::Heap>),
            F(
                tymetafuncspec_core::IdxBox<
                    crate::cst::data_structure::Heap,
                    crate::cst::data_structure::F,
                >,
            ),
            Plus(
                tymetafuncspec_core::IdxBox<
                    crate::cst::data_structure::Heap,
                    crate::cst::data_structure::Plus,
                >,
            ),
        }
        /// generated by [term_specialized_gen::gen_heaped_impls]
        pub mod heaped {
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::data_structure::F {
                type Heap = crate::cst::data_structure::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::data_structure::Plus {
                type Heap = crate::cst::data_structure::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::data_structure::LeftOperand {
                type Heap = crate::cst::data_structure::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::data_structure::RightOperand {
                type Heap = crate::cst::data_structure::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::data_structure::Sum {
                type Heap = crate::cst::data_structure::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::data_structure::Error {
                type Heap = crate::cst::data_structure::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::data_structure::Column {
                type Heap = crate::cst::data_structure::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::data_structure::EndPosition {
                type Heap = crate::cst::data_structure::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::data_structure::Line {
                type Heap = crate::cst::data_structure::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::data_structure::Metadata {
                type Heap = crate::cst::data_structure::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::data_structure::StartPosition {
                type Heap = crate::cst::data_structure::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::data_structure::Nat {
                type Heap = crate::cst::data_structure::Heap;
            }
        }
    }
    /// generated by [term_trait_gen::generate]
    pub mod extension_of {
        /// generated by [term_trait_gen::heap_trait]
        pub trait Heap:
            term::SuperHeap<tymetafuncspec_core::EitherHeapBak<Self, Self::Nat, Self::Error>>
            + term::SuperHeap<tymetafuncspec_core::MaybeHeapBak<Self, Self::Metadata>>
            + term::SuperHeap<
                tymetafuncspec_core::EitherHeapBak<Self, Self::LeftOperand, Self::Error>,
            > + term::SuperHeap<
                tymetafuncspec_core::EitherHeapBak<Self, Self::RightOperand, Self::Error>,
            > + term::SuperHeap<
                tymetafuncspec_core::EitherHeapBak<
                    Self,
                    tymetafuncspec_core::Set<
                        Self,
                        tymetafuncspec_core::Either<Self, Self::Nat, Self::Error>,
                    >,
                    Self::Error,
                >,
            > + term::SuperHeap<tymetafuncspec_core::BoundedNatHeapBak<Self>>
            + term::SuperHeap<tymetafuncspec_core::IdxBoxHeapBak<Self, Self::F>>
            + term::SuperHeap<tymetafuncspec_core::IdxBoxHeapBak<Self, Self::Plus>>
            + Sized
        {
            type F: crate::cst::extension_of::owned::F<Heap = Self>;
            type Plus: crate::cst::extension_of::owned::Plus<Heap = Self>;
            type LeftOperand: crate::cst::extension_of::owned::LeftOperand<Heap = Self>;
            type RightOperand: crate::cst::extension_of::owned::RightOperand<Heap = Self>;
            type Sum: crate::cst::extension_of::owned::Sum<Heap = Self>;
            type Error: crate::cst::extension_of::owned::Error<Heap = Self>;
            type Column: crate::cst::extension_of::owned::Column<Heap = Self>;
            type EndPosition: crate::cst::extension_of::owned::EndPosition<Heap = Self>;
            type Line: crate::cst::extension_of::owned::Line<Heap = Self>;
            type Metadata: crate::cst::extension_of::owned::Metadata<Heap = Self>;
            type StartPosition: crate::cst::extension_of::owned::StartPosition<Heap = Self>;
            type Nat: crate::cst::extension_of::owned::Nat<Heap = Self>;
        }
        /// generated by [term_trait_gen::owned::generate]
        pub mod owned {
            pub trait F:
                term::Heaped
                + term::CanonicallyConstructibleFrom<(
                    tymetafuncspec_core::Either<
                        <Self as term::Heaped>::Heap,
                        <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Nat,
                        <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Error,
                    >,
                    tymetafuncspec_core::Maybe<
                        <Self as term::Heaped>::Heap,
                        <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Metadata,
                    >,
                )> where
                <Self as term::Heaped>::Heap: crate::cst::extension_of::Heap,
            {
            }
            pub trait Plus: term::Heaped + term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::LeftOperand,
                            <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Error,
                        >,
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::RightOperand,
                            <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Error,
                        >,
                        tymetafuncspec_core::Maybe<
                            <Self as term::Heaped>::Heap,
                            <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Metadata,
                        >,
                    ),
                >
            where
                <Self as term::Heaped>::Heap: crate::cst::extension_of::Heap,
            {}
            pub trait LeftOperand:
                term::Heaped
                + term::CanonicallyConstructibleFrom<(
                    tymetafuncspec_core::Either<
                        <Self as term::Heaped>::Heap,
                        <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Nat,
                        <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Error,
                    >,
                    tymetafuncspec_core::Maybe<
                        <Self as term::Heaped>::Heap,
                        <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Metadata,
                    >,
                )>
            where
                <Self as term::Heaped>::Heap: crate::cst::extension_of::Heap,
            {
            }
            pub trait RightOperand:
                term::Heaped
                + term::CanonicallyConstructibleFrom<(
                    tymetafuncspec_core::Either<
                        <Self as term::Heaped>::Heap,
                        <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Nat,
                        <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Error,
                    >,
                    tymetafuncspec_core::Maybe<
                        <Self as term::Heaped>::Heap,
                        <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Metadata,
                    >,
                )>
            where
                <Self as term::Heaped>::Heap: crate::cst::extension_of::Heap,
            {
            }
            pub trait Sum: term::Heaped + term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::Set<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Either<
                                    <Self as term::Heaped>::Heap,
                                    <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Nat,
                                    <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Error,
                                >,
                            >,
                            <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Error,
                        >,
                        tymetafuncspec_core::Maybe<
                            <Self as term::Heaped>::Heap,
                            <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Metadata,
                        >,
                    ),
                >
            where
                <Self as term::Heaped>::Heap: crate::cst::extension_of::Heap,
            {}
            pub trait Error:
                term::Heaped
                + term::CanonicallyConstructibleFrom<(
                    tymetafuncspec_core::Maybe<
                        <Self as term::Heaped>::Heap,
                        <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Metadata,
                    >,
                )>
            where
                <Self as term::Heaped>::Heap: crate::cst::extension_of::Heap,
            {
            }
            pub trait Column:
                term::Heaped
                + term::CanonicallyConstructibleFrom<(
                    tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>,
                )>
            where
                <Self as term::Heaped>::Heap: crate::cst::extension_of::Heap,
            {
            }
            pub trait EndPosition:
                term::Heaped
                + term::CanonicallyConstructibleFrom<(
                    <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Line,
                    <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Column,
                )>
            where
                <Self as term::Heaped>::Heap: crate::cst::extension_of::Heap,
            {
            }
            pub trait Line:
                term::Heaped
                + term::CanonicallyConstructibleFrom<(
                    tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>,
                )>
            where
                <Self as term::Heaped>::Heap: crate::cst::extension_of::Heap,
            {
            }
            pub trait Metadata:
                term::Heaped
                + term::CanonicallyConstructibleFrom<(
                    <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::StartPosition,
                    <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::EndPosition,
                )>
            where
                <Self as term::Heaped>::Heap: crate::cst::extension_of::Heap,
            {
            }
            pub trait StartPosition:
                term::Heaped
                + term::CanonicallyConstructibleFrom<(
                    <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Line,
                    <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Column,
                )>
            where
                <Self as term::Heaped>::Heap: crate::cst::extension_of::Heap,
            {
            }
            pub trait Nat:
                term::Heaped
                + term::CanonicallyConstructibleFrom<(
                    tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>,
                )> + term::CanonicallyConstructibleFrom<(
                    tymetafuncspec_core::IdxBox<
                        <Self as term::Heaped>::Heap,
                        <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::F,
                    >,
                )> + term::CanonicallyConstructibleFrom<(
                    tymetafuncspec_core::IdxBox<
                        <Self as term::Heaped>::Heap,
                        <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Plus,
                    >,
                )>
            where
                <Self as term::Heaped>::Heap: crate::cst::extension_of::Heap,
            {
            }
        }
        /// generated by [term_trait_gen::reference::generate]
        pub mod reference {}
    }
    /// generated by [term_specialized_impl_gen::generate]
    pub mod term_impls {
        /// generated by [term_specialized_impl_gen::gen_heap_impl]
        impl crate::cst::extension_of::Heap for crate::cst::data_structure::Heap {
            type F = crate::cst::data_structure::F;
            type Plus = crate::cst::data_structure::Plus;
            type LeftOperand = crate::cst::data_structure::LeftOperand;
            type RightOperand = crate::cst::data_structure::RightOperand;
            type Sum = crate::cst::data_structure::Sum;
            type Error = crate::cst::data_structure::Error;
            type Column = crate::cst::data_structure::Column;
            type EndPosition = crate::cst::data_structure::EndPosition;
            type Line = crate::cst::data_structure::Line;
            type Metadata = crate::cst::data_structure::Metadata;
            type StartPosition = crate::cst::data_structure::StartPosition;
            type Nat = crate::cst::data_structure::Nat;
        }
        /// generated by [term_specialized_impl_gen::gen_owned_mod]
        pub mod owned_impls {
            impl crate::cst::extension_of::owned::F for crate::cst::data_structure::F {}
            impl crate::cst::extension_of::owned::Plus for crate::cst::data_structure::Plus {}
            impl crate::cst::extension_of::owned::LeftOperand for crate::cst::data_structure::LeftOperand {}
            impl crate::cst::extension_of::owned::RightOperand for crate::cst::data_structure::RightOperand {}
            impl crate::cst::extension_of::owned::Sum for crate::cst::data_structure::Sum {}
            impl crate::cst::extension_of::owned::Error for crate::cst::data_structure::Error {}
            impl crate::cst::extension_of::owned::Column for crate::cst::data_structure::Column {}
            impl crate::cst::extension_of::owned::EndPosition for crate::cst::data_structure::EndPosition {}
            impl crate::cst::extension_of::owned::Line for crate::cst::data_structure::Line {}
            impl crate::cst::extension_of::owned::Metadata for crate::cst::data_structure::Metadata {}
            impl crate::cst::extension_of::owned::StartPosition for crate::cst::data_structure::StartPosition {}
            impl crate::cst::extension_of::owned::Nat for crate::cst::data_structure::Nat {}
        }
        /// generated by [term_specialized_impl_gen::gen_ccf_mod]
        pub mod ccf_impls {
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod f {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                impl
                    term::CanonicallyConstructibleFrom<(
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Nat,
                            crate::cst::data_structure::Error,
                        >,
                        tymetafuncspec_core::Maybe<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Metadata,
                        >,
                    )> for crate::cst::data_structure::F
                {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::Either<
                                <Self as term::Heaped>::Heap,
                                crate::cst::data_structure::Nat,
                                crate::cst::data_structure::Error,
                            >,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                crate::cst::data_structure::Metadata,
                            >,
                        ),
                    ) -> Self {
                        crate::cst::data_structure::F {
                            nat: t.0,
                            metadata: t.1,
                        }
                    }
                    fn deconstruct(
                        self,
                        heap: &mut Self::Heap,
                    ) -> (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Nat,
                            crate::cst::data_structure::Error,
                        >,
                        tymetafuncspec_core::Maybe<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Metadata,
                        >,
                    ) {
                        (self.nat, self.metadata)
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod plus {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                impl
                    term::CanonicallyConstructibleFrom<(
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::LeftOperand,
                            crate::cst::data_structure::Error,
                        >,
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::RightOperand,
                            crate::cst::data_structure::Error,
                        >,
                        tymetafuncspec_core::Maybe<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Metadata,
                        >,
                    )> for crate::cst::data_structure::Plus
                {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::Either<
                                <Self as term::Heaped>::Heap,
                                crate::cst::data_structure::LeftOperand,
                                crate::cst::data_structure::Error,
                            >,
                            tymetafuncspec_core::Either<
                                <Self as term::Heaped>::Heap,
                                crate::cst::data_structure::RightOperand,
                                crate::cst::data_structure::Error,
                            >,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                crate::cst::data_structure::Metadata,
                            >,
                        ),
                    ) -> Self {
                        crate::cst::data_structure::Plus {
                            left_operand: t.0,
                            right_operand: t.1,
                            metadata: t.2,
                        }
                    }
                    fn deconstruct(
                        self,
                        heap: &mut Self::Heap,
                    ) -> (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::LeftOperand,
                            crate::cst::data_structure::Error,
                        >,
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::RightOperand,
                            crate::cst::data_structure::Error,
                        >,
                        tymetafuncspec_core::Maybe<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Metadata,
                        >,
                    ) {
                        (self.left_operand, self.right_operand, self.metadata)
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod left_operand {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                impl
                    term::CanonicallyConstructibleFrom<(
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Nat,
                            crate::cst::data_structure::Error,
                        >,
                        tymetafuncspec_core::Maybe<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Metadata,
                        >,
                    )> for crate::cst::data_structure::LeftOperand
                {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::Either<
                                <Self as term::Heaped>::Heap,
                                crate::cst::data_structure::Nat,
                                crate::cst::data_structure::Error,
                            >,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                crate::cst::data_structure::Metadata,
                            >,
                        ),
                    ) -> Self {
                        crate::cst::data_structure::LeftOperand {
                            nat: t.0,
                            metadata: t.1,
                        }
                    }
                    fn deconstruct(
                        self,
                        heap: &mut Self::Heap,
                    ) -> (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Nat,
                            crate::cst::data_structure::Error,
                        >,
                        tymetafuncspec_core::Maybe<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Metadata,
                        >,
                    ) {
                        (self.nat, self.metadata)
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod right_operand {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                impl
                    term::CanonicallyConstructibleFrom<(
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Nat,
                            crate::cst::data_structure::Error,
                        >,
                        tymetafuncspec_core::Maybe<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Metadata,
                        >,
                    )> for crate::cst::data_structure::RightOperand
                {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::Either<
                                <Self as term::Heaped>::Heap,
                                crate::cst::data_structure::Nat,
                                crate::cst::data_structure::Error,
                            >,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                crate::cst::data_structure::Metadata,
                            >,
                        ),
                    ) -> Self {
                        crate::cst::data_structure::RightOperand {
                            nat: t.0,
                            metadata: t.1,
                        }
                    }
                    fn deconstruct(
                        self,
                        heap: &mut Self::Heap,
                    ) -> (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Nat,
                            crate::cst::data_structure::Error,
                        >,
                        tymetafuncspec_core::Maybe<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Metadata,
                        >,
                    ) {
                        (self.nat, self.metadata)
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod sum {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                impl
                    term::CanonicallyConstructibleFrom<(
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::Set<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Either<
                                    <Self as term::Heaped>::Heap,
                                    crate::cst::data_structure::Nat,
                                    crate::cst::data_structure::Error,
                                >,
                            >,
                            crate::cst::data_structure::Error,
                        >,
                        tymetafuncspec_core::Maybe<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Metadata,
                        >,
                    )> for crate::cst::data_structure::Sum
                {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::Either<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Set<
                                    <Self as term::Heaped>::Heap,
                                    tymetafuncspec_core::Either<
                                        <Self as term::Heaped>::Heap,
                                        crate::cst::data_structure::Nat,
                                        crate::cst::data_structure::Error,
                                    >,
                                >,
                                crate::cst::data_structure::Error,
                            >,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                crate::cst::data_structure::Metadata,
                            >,
                        ),
                    ) -> Self {
                        crate::cst::data_structure::Sum {
                            set: t.0,
                            metadata: t.1,
                        }
                    }
                    fn deconstruct(
                        self,
                        heap: &mut Self::Heap,
                    ) -> (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::Set<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Either<
                                    <Self as term::Heaped>::Heap,
                                    crate::cst::data_structure::Nat,
                                    crate::cst::data_structure::Error,
                                >,
                            >,
                            crate::cst::data_structure::Error,
                        >,
                        tymetafuncspec_core::Maybe<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Metadata,
                        >,
                    ) {
                        (self.set, self.metadata)
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod error {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                impl
                    term::CanonicallyConstructibleFrom<(
                        tymetafuncspec_core::Maybe<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Metadata,
                        >,
                    )> for crate::cst::data_structure::Error
                {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                crate::cst::data_structure::Metadata,
                            >,
                        ),
                    ) -> Self {
                        crate::cst::data_structure::Error { metadata: t.0 }
                    }
                    fn deconstruct(
                        self,
                        heap: &mut Self::Heap,
                    ) -> (
                        tymetafuncspec_core::Maybe<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Metadata,
                        >,
                    ) {
                        (self.metadata,)
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod column {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                impl
                    term::CanonicallyConstructibleFrom<(
                        tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>,
                    )> for crate::cst::data_structure::Column
                {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>,),
                    ) -> Self {
                        crate::cst::data_structure::Column { nat_lit: t.0 }
                    }
                    fn deconstruct(
                        self,
                        heap: &mut Self::Heap,
                    ) -> (tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>,)
                    {
                        (self.nat_lit,)
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod end_position {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                impl
                    term::CanonicallyConstructibleFrom<(
                        crate::cst::data_structure::Line,
                        crate::cst::data_structure::Column,
                    )> for crate::cst::data_structure::EndPosition
                {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            crate::cst::data_structure::Line,
                            crate::cst::data_structure::Column,
                        ),
                    ) -> Self {
                        crate::cst::data_structure::EndPosition {
                            line: t.0,
                            column: t.1,
                        }
                    }
                    fn deconstruct(
                        self,
                        heap: &mut Self::Heap,
                    ) -> (
                        crate::cst::data_structure::Line,
                        crate::cst::data_structure::Column,
                    ) {
                        (self.line, self.column)
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod line {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                impl
                    term::CanonicallyConstructibleFrom<(
                        tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>,
                    )> for crate::cst::data_structure::Line
                {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>,),
                    ) -> Self {
                        crate::cst::data_structure::Line { nat_lit: t.0 }
                    }
                    fn deconstruct(
                        self,
                        heap: &mut Self::Heap,
                    ) -> (tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>,)
                    {
                        (self.nat_lit,)
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod metadata {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                impl
                    term::CanonicallyConstructibleFrom<(
                        crate::cst::data_structure::StartPosition,
                        crate::cst::data_structure::EndPosition,
                    )> for crate::cst::data_structure::Metadata
                {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            crate::cst::data_structure::StartPosition,
                            crate::cst::data_structure::EndPosition,
                        ),
                    ) -> Self {
                        crate::cst::data_structure::Metadata {
                            start_position: t.0,
                            end_position: t.1,
                        }
                    }
                    fn deconstruct(
                        self,
                        heap: &mut Self::Heap,
                    ) -> (
                        crate::cst::data_structure::StartPosition,
                        crate::cst::data_structure::EndPosition,
                    ) {
                        (self.start_position, self.end_position)
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod start_position {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                impl
                    term::CanonicallyConstructibleFrom<(
                        crate::cst::data_structure::Line,
                        crate::cst::data_structure::Column,
                    )> for crate::cst::data_structure::StartPosition
                {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            crate::cst::data_structure::Line,
                            crate::cst::data_structure::Column,
                        ),
                    ) -> Self {
                        crate::cst::data_structure::StartPosition {
                            line: t.0,
                            column: t.1,
                        }
                    }
                    fn deconstruct(
                        self,
                        heap: &mut Self::Heap,
                    ) -> (
                        crate::cst::data_structure::Line,
                        crate::cst::data_structure::Column,
                    ) {
                        (self.line, self.column)
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod nat {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
                impl
                    term::CanonicallyConstructibleFrom<(
                        tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>,
                    )> for crate::cst::data_structure::Nat
                {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>,),
                    ) -> Self {
                        crate::cst::data_structure::Nat::NatLit(t.0)
                    }
                    fn deconstruct(
                        self,
                        heap: &mut Self::Heap,
                    ) -> (tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>,)
                    {
                        match self {
                            crate::cst::data_structure::Nat::NatLit(t) => (t,),
                            _ => panic!("conversion failure"),
                        }
                    }
                }
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
                impl
                    term::CanonicallyConstructibleFrom<(
                        tymetafuncspec_core::IdxBox<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::F,
                        >,
                    )> for crate::cst::data_structure::Nat
                {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::IdxBox<
                                <Self as term::Heaped>::Heap,
                                crate::cst::data_structure::F,
                            >,
                        ),
                    ) -> Self {
                        crate::cst::data_structure::Nat::F(t.0)
                    }
                    fn deconstruct(
                        self,
                        heap: &mut Self::Heap,
                    ) -> (
                        tymetafuncspec_core::IdxBox<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::F,
                        >,
                    ) {
                        match self {
                            crate::cst::data_structure::Nat::F(t) => (t,),
                            _ => panic!("conversion failure"),
                        }
                    }
                }
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
                impl
                    term::CanonicallyConstructibleFrom<(
                        tymetafuncspec_core::IdxBox<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Plus,
                        >,
                    )> for crate::cst::data_structure::Nat
                {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::IdxBox<
                                <Self as term::Heaped>::Heap,
                                crate::cst::data_structure::Plus,
                            >,
                        ),
                    ) -> Self {
                        crate::cst::data_structure::Nat::Plus(t.0)
                    }
                    fn deconstruct(
                        self,
                        heap: &mut Self::Heap,
                    ) -> (
                        tymetafuncspec_core::IdxBox<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Plus,
                        >,
                    ) {
                        match self {
                            crate::cst::data_structure::Nat::Plus(t) => (t,),
                            _ => panic!("conversion failure"),
                        }
                    }
                }
            }
        }
        /// generated by [term_specialized_impl_gen::gen_mct_mod]
        pub mod mct_impls {}
    }
}
