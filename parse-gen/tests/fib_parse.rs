use crate::pattern_match_strategy as pms;
use cst::data_structure::Heap;
use cst::data_structure::Nat;
use cst::data_structure::Plus;
use cst::data_structure::F;
use parse_adt::cstfy::Cstfy;
use parse_adt::cstfy::CstfyTransparent;
use parse_adt::Parser;
/// generated by [parse_gen::formatted]
#[rustfmt::skip]
fn test() {
    let mut parser = parse_adt::Parser::new("test");
    let mut heap = cst::data_structure::Heap::default();
    // <CstfyTransparent<
    //     Heap,
    //     Nat,
    // > as term::co_visit::CoVisitable<
    //     Parser<'_, ()>,
    //     pms::PatternMatchStrategyProvider<Heap>,
    //     Heap,
    // >>::co_visit(&mut parser, &mut heap);
    <Cstfy<
        Heap,
        F,
    > as term::co_visit::CoVisitable<
        Parser<'_, ()>,
        pms::PatternMatchStrategyProvider<Heap>,
        Heap,
    >>::co_visit(&mut parser, &mut heap);
    // <Cstfy<
    //     Heap,
    //     cst::data_structure::Sum,
    // > as term::co_visit::CoVisitable<
    //     Parser<'_, ()>,
    //     pms::PatternMatchStrategyProvider<Heap>,
    //     Heap,
    // >>::co_visit(&mut parser, &mut heap);
    <Cstfy<
        Heap,
        tymetafuncspec_core::Set<Heap, tymetafuncspec_core::Either<Heap, Nat, std_parse_error::ParseError<Heap>>>,
    > as term::co_visit::CoVisitable<
        Parser<'_, ()>,
        pms::PatternMatchStrategyProvider<Heap>,
        Heap,
    >>::co_visit(&mut parser, &mut heap);
    // <Parser<'_> as term::select::AcceptingCases<((tymetafuncspec_core::Either<cst::data_structure::Heap, tymetafuncspec_core::Pair<cst::data_structure::Heap, tymetafuncspec_core::BoundedNat<cst::data_structure::Heap>, tymetafuncspec_core::Maybe<cst::data_structure::Heap, std_parse_metadata::ParseMetadata<cst::data_structure::Heap>>>, std_parse_error::ParseError<cst::data_structure::Heap>>, ()), ((tymetafuncspec_core::Either<cst::data_structure::Heap, tymetafuncspec_core::Pair<cst::data_structure::Heap, tymetafuncspec_core::IdxBox<cst::data_structure::Heap, tymetafuncspec_core::Either<cst::data_structure::Heap, tymetafuncspec_core::Pair<cst::data_structure::Heap, cst::data_structure::F, tymetafuncspec_core::Maybe<cst::data_structure::Heap, std_parse_metadata::ParseMetadata<cst::data_structure::Heap>>>, std_parse_error::ParseError<cst::data_structure::Heap>>>, tymetafuncspec_core::Maybe<cst::data_structure::Heap, std_parse_metadata::ParseMetadata<cst::data_structure::Heap>>>, std_parse_error::ParseError<cst::data_structure::Heap>>, ()), ((tymetafuncspec_core::Either<cst::data_structure::Heap, tymetafuncspec_core::Pair<cst::data_structure::Heap, tymetafuncspec_core::IdxBox<cst::data_structure::Heap, tymetafuncspec_core::Either<cst::data_structure::Heap, tymetafuncspec_core::Pair<cst::data_structure::Heap, cst::data_structure::Plus, tymetafuncspec_core::Maybe<cst::data_structure::Heap, std_parse_metadata::ParseMetadata<cst::data_structure::Heap>>>, std_parse_error::ParseError<cst::data_structure::Heap>>>, tymetafuncspec_core::Maybe<cst::data_structure::Heap, std_parse_metadata::ParseMetadata<cst::data_structure::Heap>>>, std_parse_error::ParseError<cst::data_structure::Heap>>, ()), ((tymetafuncspec_core::Either<cst::data_structure::Heap, tymetafuncspec_core::Pair<cst::data_structure::Heap, tymetafuncspec_core::IdxBox<cst::data_structure::Heap, tymetafuncspec_core::Either<cst::data_structure::Heap, tymetafuncspec_core::Pair<cst::data_structure::Heap, cst::data_structure::Sum, tymetafuncspec_core::Maybe<cst::data_structure::Heap, std_parse_metadata::ParseMetadata<cst::data_structure::Heap>>>, std_parse_error::ParseError<cst::data_structure::Heap>>>, tymetafuncspec_core::Maybe<cst::data_structure::Heap, std_parse_metadata::ParseMetadata<cst::data_structure::Heap>>>, std_parse_error::ParseError<cst::data_structure::Heap>>, ()), ()))))>>::try_case(&mut parser)
    //     .unwrap();
}
/// generated by [parse_gen::generate]
#[rustfmt::skip]
pub mod parse {
    use parse::KeywordSequence;
    use crate::cst::data_structure as cds;
    impl parse_adt::ParseLL for cds::F {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(f))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[parse::Keyword::new(";")]);
    }
    impl parse_adt::ParseLL for cds::Plus {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(plus))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[parse::Keyword::new(";")]);
    }
    impl parse_adt::ParseLL for cds::LeftOperand {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(left_operand))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[parse::Keyword::new(";")]);
    }
    impl parse_adt::ParseLL for cds::RightOperand {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(right_operand))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[parse::Keyword::new(";")]);
    }
    impl parse_adt::ParseLL for cds::Sum {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(sum))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[parse::Keyword::new(";")]);
    }
    impl parse_adt::ParseLL for cds::Nat {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(nat))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[parse::Keyword::new(";")]);
    }
}
/// generated by [parse_gen::formatted]
#[rustfmt::skip]
pub mod cst {
    /// generated by [term_specialized_gen::generate]
    #[rustfmt::skip]
    pub mod data_structure {
        use tymetafuncspec_core::BoundedNat;
        use std_parse_metadata::ParseMetadata;
        use crate::cst::data_structure::heap::nat_lit as cdshnl;
        use crate::cst::data_structure::heap::idx_box as cdshib;
        use tymetafuncspec_core::IdxBox;
        use crate::cst::data_structure::heap::set as cdshs;
        use tymetafuncspec_core::Pair;
        use tymetafuncspec_core::Maybe;
        use tymetafuncspec_core::Either;
        use std_parse_error::ParseError;
        use crate::cst::data_structure::heap::parse_metadata as cdshpm;
        use crate::cst::data_structure as cds;
        use tymetafuncspec_core::Set;
        use crate::cst::data_structure::heap::either as cdshe;
        use crate::cst::data_structure::heap::maybe as cdshm;
        use crate::cst::data_structure::heap::pair as cdshp;
        use crate::cst::data_structure::heap::parse_error as cdshpe;
        /// generated by [term_specialized_gen::gen_heap]
        #[rustfmt::skip]
        #[derive(Default)]
        pub struct Heap {
            either: cdshe::Bak,
            parse_error: cdshpe::Bak,
            pair: cdshp::Bak,
            maybe: cdshm::Bak,
            parse_metadata: cdshpm::Bak,
            set: cdshs::Bak,
            nat_lit: cdshnl::Bak,
            idx_box: cdshib::Bak,
        }
        /// generated by [term_specialized_gen::gen_heap]
        #[rustfmt::skip]
        pub mod heap {
            use crate::cst::data_structure::heap::set as cdshs;
            use crate::cst::data_structure::heap::idx_box as cdshib;
            use crate::cst::data_structure::heap::parse_error as cdshpe;
            use crate::cst::data_structure::heap::nat_lit as cdshnl;
            use crate::cst::data_structure::heap::pair as cdshp;
            use crate::cst::data_structure::heap::either as cdshe;
            use crate::cst::data_structure::heap::maybe as cdshm;
            use crate::cst::data_structure::heap::parse_metadata as cdshpm;
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[rustfmt::skip]
            #[derive(Default)]
            pub struct Bak {
                pub either: cdshe::Bak,
                pub parse_error: cdshpe::Bak,
                pub pair: cdshp::Bak,
                pub maybe: cdshm::Bak,
                pub parse_metadata: cdshpm::Bak,
                pub set: cdshs::Bak,
                pub nat_lit: cdshnl::Bak,
                pub idx_box: cdshib::Bak,
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[rustfmt::skip]
            pub mod either {
                use crate::cst::data_structure::heap::either::pair as cdshep;
                use crate::cst::data_structure::heap::either::nat as cdshen;
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[rustfmt::skip]
                #[derive(Default)]
                pub struct Bak {
                    pub nat: cdshen::Bak,
                    pub pair: cdshep::Bak,
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[rustfmt::skip]
                pub mod nat {
                    use crate::cst::data_structure::heap::either::nat::parse_error as cdshenpe;
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    #[derive(Default)]
                    pub struct Bak {
                        pub parse_error: cdshenpe::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    pub mod parse_error {
                        use tymetafuncspec_core::EitherHeapBak;
                        use std_parse_error::ParseError;
                        use crate::cst::data_structure as cds;
                        /// generated by [term_specialized_gen::gen_heapbak_module]
                        #[rustfmt::skip]
                        #[derive(Default)]
                        pub struct Bak(
                            pub EitherHeapBak<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
                        );
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[rustfmt::skip]
                pub mod pair {
                    use crate::cst::data_structure::heap::either::pair::nat_lit as cdshepnl;
                    use crate::cst::data_structure::heap::either::pair::set as cdsheps;
                    use crate::cst::data_structure::heap::either::pair::right_operand as cdshepro;
                    use crate::cst::data_structure::heap::either::pair::plus as cdshepp;
                    use crate::cst::data_structure::heap::either::pair::left_operand as cdsheplo;
                    use crate::cst::data_structure::heap::either::pair::idx_box as cdshepib;
                    use crate::cst::data_structure::heap::either::pair::f as cdshepf;
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    #[derive(Default)]
                    pub struct Bak {
                        pub left_operand: cdsheplo::Bak,
                        pub right_operand: cdshepro::Bak,
                        pub set: cdsheps::Bak,
                        pub nat_lit: cdshepnl::Bak,
                        pub idx_box: cdshepib::Bak,
                        pub f: cdshepf::Bak,
                        pub plus: cdshepp::Bak,
                        pub sum: crate::cst::data_structure::heap::either::pair::sum::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    pub mod left_operand {
                        use crate::cst::data_structure::heap::either::pair::left_operand::maybe as cdsheplom;
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        #[derive(Default)]
                        pub struct Bak {
                            pub maybe: cdsheplom::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        pub mod maybe {
                            use crate::cst::data_structure::heap::either::pair::left_operand::maybe::parse_metadata as cdsheplompm;
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            #[derive(Default)]
                            pub struct Bak {
                                pub parse_metadata: cdsheplompm::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            pub mod parse_metadata {
                                use crate::cst::data_structure::heap::either::pair::left_operand::maybe::parse_metadata::parse_error as cdsheplompmpe;
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub parse_error: cdsheplompmpe::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                pub mod parse_error {
                                    use tymetafuncspec_core::Maybe;
                                    use tymetafuncspec_core::EitherHeapBak;
                                    use std_parse_metadata::ParseMetadata;
                                    use std_parse_error::ParseError;
                                    use tymetafuncspec_core::Pair;
                                    use crate::cst::data_structure as cds;
                                    /// generated by [term_specialized_gen::gen_heapbak_module]
                                    #[rustfmt::skip]
                                    #[derive(Default)]
                                    pub struct Bak(
                                        pub EitherHeapBak<
                                            cds::Heap,
                                            Pair<
                                                cds::Heap,
                                                cds::LeftOperand,
                                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                            >,
                                            ParseError<cds::Heap>,
                                        >,
                                    );
                                }
                            }
                        }
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    pub mod right_operand {
                        use crate::cst::data_structure::heap::either::pair::right_operand::maybe as cdsheprom;
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        #[derive(Default)]
                        pub struct Bak {
                            pub maybe: cdsheprom::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        pub mod maybe {
                            use crate::cst::data_structure::heap::either::pair::right_operand::maybe::parse_metadata as cdsheprompm;
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            #[derive(Default)]
                            pub struct Bak {
                                pub parse_metadata: cdsheprompm::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            pub mod parse_metadata {
                                use crate::cst::data_structure::heap::either::pair::right_operand::maybe::parse_metadata::parse_error as cdsheprompmpe;
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub parse_error: cdsheprompmpe::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                pub mod parse_error {
                                    use tymetafuncspec_core::Pair;
                                    use tymetafuncspec_core::Maybe;
                                    use crate::cst::data_structure as cds;
                                    use std_parse_error::ParseError;
                                    use std_parse_metadata::ParseMetadata;
                                    use tymetafuncspec_core::EitherHeapBak;
                                    /// generated by [term_specialized_gen::gen_heapbak_module]
                                    #[rustfmt::skip]
                                    #[derive(Default)]
                                    pub struct Bak(
                                        pub EitherHeapBak<
                                            cds::Heap,
                                            Pair<
                                                cds::Heap,
                                                cds::RightOperand,
                                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                            >,
                                            ParseError<cds::Heap>,
                                        >,
                                    );
                                }
                            }
                        }
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    pub mod set {
                        use crate::cst::data_structure::heap::either::pair::set::either as cdshepse;
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        #[derive(Default)]
                        pub struct Bak {
                            pub either: cdshepse::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        pub mod either {
                            use crate::cst::data_structure::heap::either::pair::set::either::nat as cdshepsen;
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            #[derive(Default)]
                            pub struct Bak {
                                pub nat: cdshepsen::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            pub mod nat {
                                use crate::cst::data_structure::heap::either::pair::set::either::nat::parse_error as cdshepsenpe;
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub parse_error: cdshepsenpe::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                pub mod parse_error {
                                    use crate::cst::data_structure::heap::either::pair::set::either::nat::parse_error::maybe as cdshepsenpem;
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[rustfmt::skip]
                                    #[derive(Default)]
                                    pub struct Bak {
                                        pub maybe: cdshepsenpem::Bak,
                                    }
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[rustfmt::skip]
                                    pub mod maybe {
                                        use crate::cst::data_structure::heap::either::pair::set::either::nat::parse_error::maybe::parse_metadata as cdshepsenpempm;
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        #[rustfmt::skip]
                                        #[derive(Default)]
                                        pub struct Bak {
                                            pub parse_metadata: cdshepsenpempm::Bak,
                                        }
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        #[rustfmt::skip]
                                        pub mod parse_metadata {
                                            use crate::cst::data_structure::heap::either::pair::set::either::nat::parse_error::maybe::parse_metadata::parse_error as cdshepsenpempmpe;
                                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                            #[rustfmt::skip]
                                            #[derive(Default)]
                                            pub struct Bak {
                                                pub parse_error: cdshepsenpempmpe::Bak,
                                            }
                                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                            #[rustfmt::skip]
                                            pub mod parse_error {
                                                use tymetafuncspec_core::Set;
                                                use std_parse_metadata::ParseMetadata;
                                                use crate::cst::data_structure as cds;
                                                use tymetafuncspec_core::Either;
                                                use std_parse_error::ParseError;
                                                use tymetafuncspec_core::Pair;
                                                use tymetafuncspec_core::Maybe;
                                                use tymetafuncspec_core::EitherHeapBak;
                                                /// generated by [term_specialized_gen::gen_heapbak_module]
                                                #[rustfmt::skip]
                                                #[derive(Default)]
                                                pub struct Bak(
                                                    pub EitherHeapBak<
                                                        cds::Heap,
                                                        Pair<
                                                            cds::Heap,
                                                            Set<
                                                                cds::Heap,
                                                                Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
                                                            >,
                                                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                                        >,
                                                        ParseError<cds::Heap>,
                                                    >,
                                                );
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    pub mod nat_lit {
                        use crate::cst::data_structure::heap::either::pair::nat_lit::maybe as cdshepnlm;
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        #[derive(Default)]
                        pub struct Bak {
                            pub maybe: cdshepnlm::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        pub mod maybe {
                            use crate::cst::data_structure::heap::either::pair::nat_lit::maybe::parse_metadata as cdshepnlmpm;
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            #[derive(Default)]
                            pub struct Bak {
                                pub parse_metadata: cdshepnlmpm::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            pub mod parse_metadata {
                                use crate::cst::data_structure::heap::either::pair::nat_lit::maybe::parse_metadata::parse_error as cdshepnlmpmpe;
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub parse_error: cdshepnlmpmpe::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                pub mod parse_error {
                                    use tymetafuncspec_core::BoundedNat;
                                    use crate::cst::data_structure as cds;
                                    use std_parse_metadata::ParseMetadata;
                                    use std_parse_error::ParseError;
                                    use tymetafuncspec_core::Pair;
                                    use tymetafuncspec_core::Maybe;
                                    use tymetafuncspec_core::EitherHeapBak;
                                    /// generated by [term_specialized_gen::gen_heapbak_module]
                                    #[rustfmt::skip]
                                    #[derive(Default)]
                                    pub struct Bak(
                                        pub EitherHeapBak<
                                            cds::Heap,
                                            Pair<
                                                cds::Heap,
                                                BoundedNat<cds::Heap>,
                                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                            >,
                                            ParseError<cds::Heap>,
                                        >,
                                    );
                                }
                            }
                        }
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    pub mod idx_box {
                        use crate::cst::data_structure::heap::either::pair::idx_box::either as cdshepibe;
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        #[derive(Default)]
                        pub struct Bak {
                            pub either: cdshepibe::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        pub mod either {
                            use crate::cst::data_structure::heap::either::pair::idx_box::either::pair as cdshepibep;
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            #[derive(Default)]
                            pub struct Bak {
                                pub pair: cdshepibep::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            pub mod pair {
                                use crate::cst::data_structure::heap::either::pair::idx_box::either::pair::f as cdshepibepf;
                                use crate::cst::data_structure::heap::either::pair::idx_box::either::pair::sum as cdshepibeps;
                                use crate::cst::data_structure::heap::either::pair::idx_box::either::pair::plus as cdshepibepp;
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub f: cdshepibepf::Bak,
                                    pub plus: cdshepibepp::Bak,
                                    pub sum: cdshepibeps::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                pub mod f {
                                    use crate::cst::data_structure::heap::either::pair::idx_box::either::pair::f::maybe as cdshepibepfm;
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[rustfmt::skip]
                                    #[derive(Default)]
                                    pub struct Bak {
                                        pub maybe: cdshepibepfm::Bak,
                                    }
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[rustfmt::skip]
                                    pub mod maybe {
                                        use crate::cst::data_structure::heap::either::pair::idx_box::either::pair::f::maybe::parse_metadata as cdshepibepfmpm;
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        #[rustfmt::skip]
                                        #[derive(Default)]
                                        pub struct Bak {
                                            pub parse_metadata: cdshepibepfmpm::Bak,
                                        }
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        #[rustfmt::skip]
                                        pub mod parse_metadata {
                                            use crate::cst::data_structure::heap::either::pair::idx_box::either::pair::f::maybe::parse_metadata::parse_error as cdshepibepfmpmpe;
                                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                            #[rustfmt::skip]
                                            #[derive(Default)]
                                            pub struct Bak {
                                                pub parse_error: cdshepibepfmpmpe::Bak,
                                            }
                                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                            #[rustfmt::skip]
                                            pub mod parse_error {
                                                use crate::cst::data_structure::heap::either::pair::idx_box::either::pair::f::maybe::parse_metadata::parse_error::maybe as cdshepibepfmpmpem;
                                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                #[rustfmt::skip]
                                                #[derive(Default)]
                                                pub struct Bak {
                                                    pub maybe: cdshepibepfmpmpem::Bak,
                                                }
                                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                #[rustfmt::skip]
                                                pub mod maybe {
                                                    use crate::cst::data_structure::heap::either::pair::idx_box::either::pair::f::maybe::parse_metadata::parse_error::maybe::parse_metadata as cdshepibepfmpmpempm;
                                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                    #[rustfmt::skip]
                                                    #[derive(Default)]
                                                    pub struct Bak {
                                                        pub parse_metadata: cdshepibepfmpmpempm::Bak,
                                                    }
                                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                    #[rustfmt::skip]
                                                    pub mod parse_metadata {
                                                        use crate::cst::data_structure::heap::either::pair::idx_box::either::pair::f::maybe::parse_metadata::parse_error::maybe::parse_metadata::parse_error as cdshepibepfmpmpempmpe;
                                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                        #[rustfmt::skip]
                                                        #[derive(Default)]
                                                        pub struct Bak {
                                                            pub parse_error: cdshepibepfmpmpempmpe::Bak,
                                                        }
                                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                        #[rustfmt::skip]
                                                        pub mod parse_error {
                                                            use crate::cst::data_structure as cds;
                                                            use tymetafuncspec_core::Pair;
                                                            use tymetafuncspec_core::EitherHeapBak;
                                                            use tymetafuncspec_core::Either;
                                                            use std_parse_error::ParseError;
                                                            use tymetafuncspec_core::Maybe;
                                                            use tymetafuncspec_core::IdxBox;
                                                            use std_parse_metadata::ParseMetadata;
                                                            /// generated by [term_specialized_gen::gen_heapbak_module]
                                                            #[rustfmt::skip]
                                                            #[derive(Default)]
                                                            pub struct Bak(
                                                                pub EitherHeapBak<
                                                                    cds::Heap,
                                                                    Pair<
                                                                        cds::Heap,
                                                                        IdxBox<
                                                                            cds::Heap,
                                                                            Either<
                                                                                cds::Heap,
                                                                                Pair<
                                                                                    cds::Heap,
                                                                                    cds::F,
                                                                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                                                                >,
                                                                                ParseError<cds::Heap>,
                                                                            >,
                                                                        >,
                                                                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                                                    >,
                                                                    ParseError<cds::Heap>,
                                                                >,
                                                            );
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                pub mod plus {
                                    use crate::cst::data_structure::heap::either::pair::idx_box::either::pair::plus::maybe as cdshepibeppm;
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[rustfmt::skip]
                                    #[derive(Default)]
                                    pub struct Bak {
                                        pub maybe: cdshepibeppm::Bak,
                                    }
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[rustfmt::skip]
                                    pub mod maybe {
                                        use crate::cst::data_structure::heap::either::pair::idx_box::either::pair::plus::maybe::parse_metadata as cdshepibeppmpm;
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        #[rustfmt::skip]
                                        #[derive(Default)]
                                        pub struct Bak {
                                            pub parse_metadata: cdshepibeppmpm::Bak,
                                        }
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        #[rustfmt::skip]
                                        pub mod parse_metadata {
                                            use crate::cst::data_structure::heap::either::pair::idx_box::either::pair::plus::maybe::parse_metadata::parse_error as cdshepibeppmpmpe;
                                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                            #[rustfmt::skip]
                                            #[derive(Default)]
                                            pub struct Bak {
                                                pub parse_error: cdshepibeppmpmpe::Bak,
                                            }
                                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                            #[rustfmt::skip]
                                            pub mod parse_error {
                                                use crate::cst::data_structure::heap::either::pair::idx_box::either::pair::plus::maybe::parse_metadata::parse_error::maybe as cdshepibeppmpmpem;
                                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                #[rustfmt::skip]
                                                #[derive(Default)]
                                                pub struct Bak {
                                                    pub maybe: cdshepibeppmpmpem::Bak,
                                                }
                                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                #[rustfmt::skip]
                                                pub mod maybe {
                                                    use crate::cst::data_structure::heap::either::pair::idx_box::either::pair::plus::maybe::parse_metadata::parse_error::maybe::parse_metadata as cdshepibeppmpmpempm;
                                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                    #[rustfmt::skip]
                                                    #[derive(Default)]
                                                    pub struct Bak {
                                                        pub parse_metadata: cdshepibeppmpmpempm::Bak,
                                                    }
                                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                    #[rustfmt::skip]
                                                    pub mod parse_metadata {
                                                        use crate::cst::data_structure::heap::either::pair::idx_box::either::pair::plus::maybe::parse_metadata::parse_error::maybe::parse_metadata::parse_error as cdshepibeppmpmpempmpe;
                                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                        #[rustfmt::skip]
                                                        #[derive(Default)]
                                                        pub struct Bak {
                                                            pub parse_error: cdshepibeppmpmpempmpe::Bak,
                                                        }
                                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                        #[rustfmt::skip]
                                                        pub mod parse_error {
                                                            use tymetafuncspec_core::Pair;
                                                            use tymetafuncspec_core::Maybe;
                                                            use crate::cst::data_structure as cds;
                                                            use std_parse_error::ParseError;
                                                            use std_parse_metadata::ParseMetadata;
                                                            use tymetafuncspec_core::IdxBox;
                                                            use tymetafuncspec_core::Either;
                                                            use tymetafuncspec_core::EitherHeapBak;
                                                            /// generated by [term_specialized_gen::gen_heapbak_module]
                                                            #[rustfmt::skip]
                                                            #[derive(Default)]
                                                            pub struct Bak(
                                                                pub EitherHeapBak<
                                                                    cds::Heap,
                                                                    Pair<
                                                                        cds::Heap,
                                                                        IdxBox<
                                                                            cds::Heap,
                                                                            Either<
                                                                                cds::Heap,
                                                                                Pair<
                                                                                    cds::Heap,
                                                                                    cds::Plus,
                                                                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                                                                >,
                                                                                ParseError<cds::Heap>,
                                                                            >,
                                                                        >,
                                                                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                                                    >,
                                                                    ParseError<cds::Heap>,
                                                                >,
                                                            );
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                pub mod sum {
                                    use crate::cst::data_structure::heap::either::pair::idx_box::either::pair::sum::maybe as cdshepibepsm;
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[rustfmt::skip]
                                    #[derive(Default)]
                                    pub struct Bak {
                                        pub maybe: cdshepibepsm::Bak,
                                    }
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[rustfmt::skip]
                                    pub mod maybe {
                                        use crate::cst::data_structure::heap::either::pair::idx_box::either::pair::sum::maybe::parse_metadata as cdshepibepsmpm;
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        #[rustfmt::skip]
                                        #[derive(Default)]
                                        pub struct Bak {
                                            pub parse_metadata: cdshepibepsmpm::Bak,
                                        }
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        #[rustfmt::skip]
                                        pub mod parse_metadata {
                                            use crate::cst::data_structure::heap::either::pair::idx_box::either::pair::sum::maybe::parse_metadata::parse_error as cdshepibepsmpmpe;
                                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                            #[rustfmt::skip]
                                            #[derive(Default)]
                                            pub struct Bak {
                                                pub parse_error: cdshepibepsmpmpe::Bak,
                                            }
                                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                            #[rustfmt::skip]
                                            pub mod parse_error {
                                                use crate::cst::data_structure::heap::either::pair::idx_box::either::pair::sum::maybe::parse_metadata::parse_error::maybe as cdshepibepsmpmpem;
                                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                #[rustfmt::skip]
                                                #[derive(Default)]
                                                pub struct Bak {
                                                    pub maybe: cdshepibepsmpmpem::Bak,
                                                }
                                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                #[rustfmt::skip]
                                                pub mod maybe {
                                                    use crate::cst::data_structure::heap::either::pair::idx_box::either::pair::sum::maybe::parse_metadata::parse_error::maybe::parse_metadata as cdshepibepsmpmpempm;
                                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                    #[rustfmt::skip]
                                                    #[derive(Default)]
                                                    pub struct Bak {
                                                        pub parse_metadata: cdshepibepsmpmpempm::Bak,
                                                    }
                                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                    #[rustfmt::skip]
                                                    pub mod parse_metadata {
                                                        use crate::cst::data_structure::heap::either::pair::idx_box::either::pair::sum::maybe::parse_metadata::parse_error::maybe::parse_metadata::parse_error as cdshepibepsmpmpempmpe;
                                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                        #[rustfmt::skip]
                                                        #[derive(Default)]
                                                        pub struct Bak {
                                                            pub parse_error: cdshepibepsmpmpempmpe::Bak,
                                                        }
                                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                        #[rustfmt::skip]
                                                        pub mod parse_error {
                                                            use crate::cst::data_structure as cds;
                                                            use std_parse_metadata::ParseMetadata;
                                                            use tymetafuncspec_core::Pair;
                                                            use std_parse_error::ParseError;
                                                            use tymetafuncspec_core::EitherHeapBak;
                                                            use tymetafuncspec_core::IdxBox;
                                                            use tymetafuncspec_core::Maybe;
                                                            use tymetafuncspec_core::Either;
                                                            /// generated by [term_specialized_gen::gen_heapbak_module]
                                                            #[rustfmt::skip]
                                                            #[derive(Default)]
                                                            pub struct Bak(
                                                                pub EitherHeapBak<
                                                                    cds::Heap,
                                                                    Pair<
                                                                        cds::Heap,
                                                                        IdxBox<
                                                                            cds::Heap,
                                                                            Either<
                                                                                cds::Heap,
                                                                                Pair<
                                                                                    cds::Heap,
                                                                                    cds::Sum,
                                                                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                                                                >,
                                                                                ParseError<cds::Heap>,
                                                                            >,
                                                                        >,
                                                                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                                                    >,
                                                                    ParseError<cds::Heap>,
                                                                >,
                                                            );
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    pub mod f {
                        use crate::cst::data_structure::heap::either::pair::f::maybe as cdshepfm;
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        #[derive(Default)]
                        pub struct Bak {
                            pub maybe: cdshepfm::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        pub mod maybe {
                            use crate::cst::data_structure::heap::either::pair::f::maybe::parse_metadata as cdshepfmpm;
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            #[derive(Default)]
                            pub struct Bak {
                                pub parse_metadata: cdshepfmpm::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            pub mod parse_metadata {
                                use crate::cst::data_structure::heap::either::pair::f::maybe::parse_metadata::parse_error as cdshepfmpmpe;
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub parse_error: cdshepfmpmpe::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                pub mod parse_error {
                                    use tymetafuncspec_core::Maybe;
                                    use tymetafuncspec_core::Pair;
                                    use crate::cst::data_structure as cds;
                                    use std_parse_error::ParseError;
                                    use tymetafuncspec_core::EitherHeapBak;
                                    use std_parse_metadata::ParseMetadata;
                                    /// generated by [term_specialized_gen::gen_heapbak_module]
                                    #[rustfmt::skip]
                                    #[derive(Default)]
                                    pub struct Bak(
                                        pub EitherHeapBak<
                                            cds::Heap,
                                            Pair<
                                                cds::Heap,
                                                cds::F,
                                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                            >,
                                            ParseError<cds::Heap>,
                                        >,
                                    );
                                }
                            }
                        }
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    pub mod plus {
                        use crate::cst::data_structure::heap::either::pair::plus::maybe as cdsheppm;
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        #[derive(Default)]
                        pub struct Bak {
                            pub maybe: cdsheppm::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        pub mod maybe {
                            use crate::cst::data_structure::heap::either::pair::plus::maybe::parse_metadata as cdsheppmpm;
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            #[derive(Default)]
                            pub struct Bak {
                                pub parse_metadata: cdsheppmpm::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            pub mod parse_metadata {
                                use crate::cst::data_structure::heap::either::pair::plus::maybe::parse_metadata::parse_error as cdsheppmpmpe;
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub parse_error: cdsheppmpmpe::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                pub mod parse_error {
                                    use tymetafuncspec_core::Pair;
                                    use tymetafuncspec_core::Maybe;
                                    use std_parse_metadata::ParseMetadata;
                                    use tymetafuncspec_core::EitherHeapBak;
                                    use crate::cst::data_structure as cds;
                                    use std_parse_error::ParseError;
                                    /// generated by [term_specialized_gen::gen_heapbak_module]
                                    #[rustfmt::skip]
                                    #[derive(Default)]
                                    pub struct Bak(
                                        pub EitherHeapBak<
                                            cds::Heap,
                                            Pair<
                                                cds::Heap,
                                                cds::Plus,
                                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                            >,
                                            ParseError<cds::Heap>,
                                        >,
                                    );
                                }
                            }
                        }
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    pub mod sum {
                        use crate::cst::data_structure::heap::either::pair::sum::maybe as cdshepsm;
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        #[derive(Default)]
                        pub struct Bak {
                            pub maybe: cdshepsm::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        pub mod maybe {
                            use crate::cst::data_structure::heap::either::pair::sum::maybe::parse_metadata as cdshepsmpm;
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            #[derive(Default)]
                            pub struct Bak {
                                pub parse_metadata: cdshepsmpm::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            pub mod parse_metadata {
                                use crate::cst::data_structure::heap::either::pair::sum::maybe::parse_metadata::parse_error as cdshepsmpmpe;
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub parse_error: cdshepsmpmpe::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                pub mod parse_error {
                                    use tymetafuncspec_core::Pair;
                                    use std_parse_metadata::ParseMetadata;
                                    use crate::cst::data_structure as cds;
                                    use std_parse_error::ParseError;
                                    use tymetafuncspec_core::Maybe;
                                    use tymetafuncspec_core::EitherHeapBak;
                                    /// generated by [term_specialized_gen::gen_heapbak_module]
                                    #[rustfmt::skip]
                                    #[derive(Default)]
                                    pub struct Bak(
                                        pub EitherHeapBak<
                                            cds::Heap,
                                            Pair<
                                                cds::Heap,
                                                cds::Sum,
                                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                            >,
                                            ParseError<cds::Heap>,
                                        >,
                                    );
                                }
                            }
                        }
                    }
                }
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[rustfmt::skip]
            pub mod parse_error {
                use std_parse_error::ParseErrorBak;
                use crate::cst::data_structure as cds;
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[rustfmt::skip]
                #[derive(Default)]
                pub struct Bak(pub ParseErrorBak<cds::Heap>);
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[rustfmt::skip]
            pub mod pair {
                use crate::cst::data_structure::heap::pair::plus as cdshpp;
                use crate::cst::data_structure::heap::pair::left_operand as cdshplo;
                use crate::cst::data_structure::heap::pair::idx_box as cdshpib;
                use crate::cst::data_structure::heap::pair::f as cdshpf;
                use crate::cst::data_structure::heap::pair::right_operand as cdshpro;
                use crate::cst::data_structure::heap::pair::set as cdshps;
                use crate::cst::data_structure::heap::pair::nat_lit as cdshpnl;
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[rustfmt::skip]
                #[derive(Default)]
                pub struct Bak {
                    pub left_operand: cdshplo::Bak,
                    pub right_operand: cdshpro::Bak,
                    pub set: cdshps::Bak,
                    pub nat_lit: cdshpnl::Bak,
                    pub idx_box: cdshpib::Bak,
                    pub f: cdshpf::Bak,
                    pub plus: cdshpp::Bak,
                    pub sum: crate::cst::data_structure::heap::pair::sum::Bak,
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[rustfmt::skip]
                pub mod left_operand {
                    use crate::cst::data_structure::heap::pair::left_operand::maybe as cdshplom;
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    #[derive(Default)]
                    pub struct Bak {
                        pub maybe: cdshplom::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    pub mod maybe {
                        use crate::cst::data_structure::heap::pair::left_operand::maybe::parse_metadata as cdshplompm;
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        #[derive(Default)]
                        pub struct Bak {
                            pub parse_metadata: cdshplompm::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        pub mod parse_metadata {
                            use tymetafuncspec_core::Maybe;
                            use std_parse_metadata::ParseMetadata;
                            use tymetafuncspec_core::PairHeapBak;
                            use crate::cst::data_structure as cds;
                            /// generated by [term_specialized_gen::gen_heapbak_module]
                            #[rustfmt::skip]
                            #[derive(Default)]
                            pub struct Bak(
                                pub PairHeapBak<
                                    cds::Heap,
                                    cds::LeftOperand,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                            );
                        }
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[rustfmt::skip]
                pub mod right_operand {
                    use crate::cst::data_structure::heap::pair::right_operand::maybe as cdshprom;
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    #[derive(Default)]
                    pub struct Bak {
                        pub maybe: cdshprom::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    pub mod maybe {
                        use crate::cst::data_structure::heap::pair::right_operand::maybe::parse_metadata as cdshprompm;
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        #[derive(Default)]
                        pub struct Bak {
                            pub parse_metadata: cdshprompm::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        pub mod parse_metadata {
                            use crate::cst::data_structure as cds;
                            use std_parse_metadata::ParseMetadata;
                            use tymetafuncspec_core::Maybe;
                            use tymetafuncspec_core::PairHeapBak;
                            /// generated by [term_specialized_gen::gen_heapbak_module]
                            #[rustfmt::skip]
                            #[derive(Default)]
                            pub struct Bak(
                                pub PairHeapBak<
                                    cds::Heap,
                                    cds::RightOperand,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                            );
                        }
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[rustfmt::skip]
                pub mod set {
                    use crate::cst::data_structure::heap::pair::set::either as cdshpse;
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    #[derive(Default)]
                    pub struct Bak {
                        pub either: cdshpse::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    pub mod either {
                        use crate::cst::data_structure::heap::pair::set::either::nat as cdshpsen;
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        #[derive(Default)]
                        pub struct Bak {
                            pub nat: cdshpsen::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        pub mod nat {
                            use crate::cst::data_structure::heap::pair::set::either::nat::parse_error as cdshpsenpe;
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            #[derive(Default)]
                            pub struct Bak {
                                pub parse_error: cdshpsenpe::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            pub mod parse_error {
                                use crate::cst::data_structure::heap::pair::set::either::nat::parse_error::maybe as cdshpsenpem;
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub maybe: cdshpsenpem::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                pub mod maybe {
                                    use crate::cst::data_structure::heap::pair::set::either::nat::parse_error::maybe::parse_metadata as cdshpsenpempm;
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[rustfmt::skip]
                                    #[derive(Default)]
                                    pub struct Bak {
                                        pub parse_metadata: cdshpsenpempm::Bak,
                                    }
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[rustfmt::skip]
                                    pub mod parse_metadata {
                                        use tymetafuncspec_core::Set;
                                        use tymetafuncspec_core::PairHeapBak;
                                        use tymetafuncspec_core::Either;
                                        use tymetafuncspec_core::Maybe;
                                        use crate::cst::data_structure as cds;
                                        use std_parse_metadata::ParseMetadata;
                                        use std_parse_error::ParseError;
                                        /// generated by [term_specialized_gen::gen_heapbak_module]
                                        #[rustfmt::skip]
                                        #[derive(Default)]
                                        pub struct Bak(
                                            pub PairHeapBak<
                                                cds::Heap,
                                                Set<
                                                    cds::Heap,
                                                    Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
                                                >,
                                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                            >,
                                        );
                                    }
                                }
                            }
                        }
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[rustfmt::skip]
                pub mod nat_lit {
                    use crate::cst::data_structure::heap::pair::nat_lit::maybe as cdshpnlm;
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    #[derive(Default)]
                    pub struct Bak {
                        pub maybe: cdshpnlm::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    pub mod maybe {
                        use crate::cst::data_structure::heap::pair::nat_lit::maybe::parse_metadata as cdshpnlmpm;
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        #[derive(Default)]
                        pub struct Bak {
                            pub parse_metadata: cdshpnlmpm::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        pub mod parse_metadata {
                            use tymetafuncspec_core::BoundedNat;
                            use std_parse_metadata::ParseMetadata;
                            use crate::cst::data_structure as cds;
                            use tymetafuncspec_core::PairHeapBak;
                            use tymetafuncspec_core::Maybe;
                            /// generated by [term_specialized_gen::gen_heapbak_module]
                            #[rustfmt::skip]
                            #[derive(Default)]
                            pub struct Bak(
                                pub PairHeapBak<
                                    cds::Heap,
                                    BoundedNat<cds::Heap>,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                            );
                        }
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[rustfmt::skip]
                pub mod idx_box {
                    use crate::cst::data_structure::heap::pair::idx_box::either as cdshpibe;
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    #[derive(Default)]
                    pub struct Bak {
                        pub either: cdshpibe::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    pub mod either {
                        use crate::cst::data_structure::heap::pair::idx_box::either::pair as cdshpibep;
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        #[derive(Default)]
                        pub struct Bak {
                            pub pair: cdshpibep::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        pub mod pair {
                            use crate::cst::data_structure::heap::pair::idx_box::either::pair::plus as cdshpibepp;
                            use crate::cst::data_structure::heap::pair::idx_box::either::pair::f as cdshpibepf;
                            use crate::cst::data_structure::heap::pair::idx_box::either::pair::sum as cdshpibeps;
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            #[derive(Default)]
                            pub struct Bak {
                                pub f: cdshpibepf::Bak,
                                pub plus: cdshpibepp::Bak,
                                pub sum: cdshpibeps::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            pub mod f {
                                use crate::cst::data_structure::heap::pair::idx_box::either::pair::f::maybe as cdshpibepfm;
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub maybe: cdshpibepfm::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                pub mod maybe {
                                    use crate::cst::data_structure::heap::pair::idx_box::either::pair::f::maybe::parse_metadata as cdshpibepfmpm;
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[rustfmt::skip]
                                    #[derive(Default)]
                                    pub struct Bak {
                                        pub parse_metadata: cdshpibepfmpm::Bak,
                                    }
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[rustfmt::skip]
                                    pub mod parse_metadata {
                                        use crate::cst::data_structure::heap::pair::idx_box::either::pair::f::maybe::parse_metadata::parse_error as cdshpibepfmpmpe;
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        #[rustfmt::skip]
                                        #[derive(Default)]
                                        pub struct Bak {
                                            pub parse_error: cdshpibepfmpmpe::Bak,
                                        }
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        #[rustfmt::skip]
                                        pub mod parse_error {
                                            use crate::cst::data_structure::heap::pair::idx_box::either::pair::f::maybe::parse_metadata::parse_error::maybe as cdshpibepfmpmpem;
                                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                            #[rustfmt::skip]
                                            #[derive(Default)]
                                            pub struct Bak {
                                                pub maybe: cdshpibepfmpmpem::Bak,
                                            }
                                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                            #[rustfmt::skip]
                                            pub mod maybe {
                                                use crate::cst::data_structure::heap::pair::idx_box::either::pair::f::maybe::parse_metadata::parse_error::maybe::parse_metadata as cdshpibepfmpmpempm;
                                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                #[rustfmt::skip]
                                                #[derive(Default)]
                                                pub struct Bak {
                                                    pub parse_metadata: cdshpibepfmpmpempm::Bak,
                                                }
                                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                #[rustfmt::skip]
                                                pub mod parse_metadata {
                                                    use tymetafuncspec_core::Pair;
                                                    use tymetafuncspec_core::Either;
                                                    use std_parse_error::ParseError;
                                                    use tymetafuncspec_core::Maybe;
                                                    use crate::cst::data_structure as cds;
                                                    use tymetafuncspec_core::IdxBox;
                                                    use std_parse_metadata::ParseMetadata;
                                                    use tymetafuncspec_core::PairHeapBak;
                                                    /// generated by [term_specialized_gen::gen_heapbak_module]
                                                    #[rustfmt::skip]
                                                    #[derive(Default)]
                                                    pub struct Bak(
                                                        pub PairHeapBak<
                                                            cds::Heap,
                                                            IdxBox<
                                                                cds::Heap,
                                                                Either<
                                                                    cds::Heap,
                                                                    Pair<
                                                                        cds::Heap,
                                                                        cds::F,
                                                                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                                                    >,
                                                                    ParseError<cds::Heap>,
                                                                >,
                                                            >,
                                                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                                        >,
                                                    );
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            pub mod plus {
                                use crate::cst::data_structure::heap::pair::idx_box::either::pair::plus::maybe as cdshpibeppm;
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub maybe: cdshpibeppm::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                pub mod maybe {
                                    use crate::cst::data_structure::heap::pair::idx_box::either::pair::plus::maybe::parse_metadata as cdshpibeppmpm;
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[rustfmt::skip]
                                    #[derive(Default)]
                                    pub struct Bak {
                                        pub parse_metadata: cdshpibeppmpm::Bak,
                                    }
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[rustfmt::skip]
                                    pub mod parse_metadata {
                                        use crate::cst::data_structure::heap::pair::idx_box::either::pair::plus::maybe::parse_metadata::parse_error as cdshpibeppmpmpe;
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        #[rustfmt::skip]
                                        #[derive(Default)]
                                        pub struct Bak {
                                            pub parse_error: cdshpibeppmpmpe::Bak,
                                        }
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        #[rustfmt::skip]
                                        pub mod parse_error {
                                            use crate::cst::data_structure::heap::pair::idx_box::either::pair::plus::maybe::parse_metadata::parse_error::maybe as cdshpibeppmpmpem;
                                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                            #[rustfmt::skip]
                                            #[derive(Default)]
                                            pub struct Bak {
                                                pub maybe: cdshpibeppmpmpem::Bak,
                                            }
                                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                            #[rustfmt::skip]
                                            pub mod maybe {
                                                use crate::cst::data_structure::heap::pair::idx_box::either::pair::plus::maybe::parse_metadata::parse_error::maybe::parse_metadata as cdshpibeppmpmpempm;
                                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                #[rustfmt::skip]
                                                #[derive(Default)]
                                                pub struct Bak {
                                                    pub parse_metadata: cdshpibeppmpmpempm::Bak,
                                                }
                                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                #[rustfmt::skip]
                                                pub mod parse_metadata {
                                                    use tymetafuncspec_core::IdxBox;
                                                    use tymetafuncspec_core::PairHeapBak;
                                                    use tymetafuncspec_core::Pair;
                                                    use crate::cst::data_structure as cds;
                                                    use std_parse_error::ParseError;
                                                    use std_parse_metadata::ParseMetadata;
                                                    use tymetafuncspec_core::Either;
                                                    use tymetafuncspec_core::Maybe;
                                                    /// generated by [term_specialized_gen::gen_heapbak_module]
                                                    #[rustfmt::skip]
                                                    #[derive(Default)]
                                                    pub struct Bak(
                                                        pub PairHeapBak<
                                                            cds::Heap,
                                                            IdxBox<
                                                                cds::Heap,
                                                                Either<
                                                                    cds::Heap,
                                                                    Pair<
                                                                        cds::Heap,
                                                                        cds::Plus,
                                                                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                                                    >,
                                                                    ParseError<cds::Heap>,
                                                                >,
                                                            >,
                                                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                                        >,
                                                    );
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            pub mod sum {
                                use crate::cst::data_structure::heap::pair::idx_box::either::pair::sum::maybe as cdshpibepsm;
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub maybe: cdshpibepsm::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                pub mod maybe {
                                    use crate::cst::data_structure::heap::pair::idx_box::either::pair::sum::maybe::parse_metadata as cdshpibepsmpm;
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[rustfmt::skip]
                                    #[derive(Default)]
                                    pub struct Bak {
                                        pub parse_metadata: cdshpibepsmpm::Bak,
                                    }
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[rustfmt::skip]
                                    pub mod parse_metadata {
                                        use crate::cst::data_structure::heap::pair::idx_box::either::pair::sum::maybe::parse_metadata::parse_error as cdshpibepsmpmpe;
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        #[rustfmt::skip]
                                        #[derive(Default)]
                                        pub struct Bak {
                                            pub parse_error: cdshpibepsmpmpe::Bak,
                                        }
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        #[rustfmt::skip]
                                        pub mod parse_error {
                                            use crate::cst::data_structure::heap::pair::idx_box::either::pair::sum::maybe::parse_metadata::parse_error::maybe as cdshpibepsmpmpem;
                                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                            #[rustfmt::skip]
                                            #[derive(Default)]
                                            pub struct Bak {
                                                pub maybe: cdshpibepsmpmpem::Bak,
                                            }
                                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                            #[rustfmt::skip]
                                            pub mod maybe {
                                                use crate::cst::data_structure::heap::pair::idx_box::either::pair::sum::maybe::parse_metadata::parse_error::maybe::parse_metadata as cdshpibepsmpmpempm;
                                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                #[rustfmt::skip]
                                                #[derive(Default)]
                                                pub struct Bak {
                                                    pub parse_metadata: cdshpibepsmpmpempm::Bak,
                                                }
                                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                                #[rustfmt::skip]
                                                pub mod parse_metadata {
                                                    use tymetafuncspec_core::Either;
                                                    use tymetafuncspec_core::Maybe;
                                                    use std_parse_error::ParseError;
                                                    use tymetafuncspec_core::IdxBox;
                                                    use std_parse_metadata::ParseMetadata;
                                                    use tymetafuncspec_core::Pair;
                                                    use tymetafuncspec_core::PairHeapBak;
                                                    use crate::cst::data_structure as cds;
                                                    /// generated by [term_specialized_gen::gen_heapbak_module]
                                                    #[rustfmt::skip]
                                                    #[derive(Default)]
                                                    pub struct Bak(
                                                        pub PairHeapBak<
                                                            cds::Heap,
                                                            IdxBox<
                                                                cds::Heap,
                                                                Either<
                                                                    cds::Heap,
                                                                    Pair<
                                                                        cds::Heap,
                                                                        cds::Sum,
                                                                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                                                    >,
                                                                    ParseError<cds::Heap>,
                                                                >,
                                                            >,
                                                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                                        >,
                                                    );
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[rustfmt::skip]
                pub mod f {
                    use crate::cst::data_structure::heap::pair::f::maybe as cdshpfm;
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    #[derive(Default)]
                    pub struct Bak {
                        pub maybe: cdshpfm::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    pub mod maybe {
                        use crate::cst::data_structure::heap::pair::f::maybe::parse_metadata as cdshpfmpm;
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        #[derive(Default)]
                        pub struct Bak {
                            pub parse_metadata: cdshpfmpm::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        pub mod parse_metadata {
                            use tymetafuncspec_core::PairHeapBak;
                            use std_parse_metadata::ParseMetadata;
                            use crate::cst::data_structure as cds;
                            use tymetafuncspec_core::Maybe;
                            /// generated by [term_specialized_gen::gen_heapbak_module]
                            #[rustfmt::skip]
                            #[derive(Default)]
                            pub struct Bak(
                                pub PairHeapBak<
                                    cds::Heap,
                                    cds::F,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                            );
                        }
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[rustfmt::skip]
                pub mod plus {
                    use crate::cst::data_structure::heap::pair::plus::maybe as cdshppm;
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    #[derive(Default)]
                    pub struct Bak {
                        pub maybe: cdshppm::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    pub mod maybe {
                        use crate::cst::data_structure::heap::pair::plus::maybe::parse_metadata as cdshppmpm;
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        #[derive(Default)]
                        pub struct Bak {
                            pub parse_metadata: cdshppmpm::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        pub mod parse_metadata {
                            use tymetafuncspec_core::PairHeapBak;
                            use tymetafuncspec_core::Maybe;
                            use std_parse_metadata::ParseMetadata;
                            use crate::cst::data_structure as cds;
                            /// generated by [term_specialized_gen::gen_heapbak_module]
                            #[rustfmt::skip]
                            #[derive(Default)]
                            pub struct Bak(
                                pub PairHeapBak<
                                    cds::Heap,
                                    cds::Plus,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                            );
                        }
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[rustfmt::skip]
                pub mod sum {
                    use crate::cst::data_structure::heap::pair::sum::maybe as cdshpsm;
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    #[derive(Default)]
                    pub struct Bak {
                        pub maybe: cdshpsm::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    pub mod maybe {
                        use crate::cst::data_structure::heap::pair::sum::maybe::parse_metadata as cdshpsmpm;
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        #[derive(Default)]
                        pub struct Bak {
                            pub parse_metadata: cdshpsmpm::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        pub mod parse_metadata {
                            use crate::cst::data_structure as cds;
                            use tymetafuncspec_core::Maybe;
                            use tymetafuncspec_core::PairHeapBak;
                            use std_parse_metadata::ParseMetadata;
                            /// generated by [term_specialized_gen::gen_heapbak_module]
                            #[rustfmt::skip]
                            #[derive(Default)]
                            pub struct Bak(
                                pub PairHeapBak<
                                    cds::Heap,
                                    cds::Sum,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                            );
                        }
                    }
                }
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[rustfmt::skip]
            pub mod maybe {
                use crate::cst::data_structure::heap::maybe::parse_metadata as cdshmpm;
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[rustfmt::skip]
                #[derive(Default)]
                pub struct Bak {
                    pub parse_metadata: cdshmpm::Bak,
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[rustfmt::skip]
                pub mod parse_metadata {
                    use crate::cst::data_structure as cds;
                    use tymetafuncspec_core::MaybeHeapBak;
                    use std_parse_metadata::ParseMetadata;
                    /// generated by [term_specialized_gen::gen_heapbak_module]
                    #[rustfmt::skip]
                    #[derive(Default)]
                    pub struct Bak(
                        pub MaybeHeapBak<cds::Heap, ParseMetadata<cds::Heap>>,
                    );
                }
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[rustfmt::skip]
            pub mod parse_metadata {
                use crate::cst::data_structure as cds;
                use std_parse_metadata::ParseMetadataBak;
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[rustfmt::skip]
                #[derive(Default)]
                pub struct Bak(pub ParseMetadataBak<cds::Heap>);
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[rustfmt::skip]
            pub mod set {
                use crate::cst::data_structure::heap::set::either as cdshse;
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[rustfmt::skip]
                #[derive(Default)]
                pub struct Bak {
                    pub either: cdshse::Bak,
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[rustfmt::skip]
                pub mod either {
                    use crate::cst::data_structure::heap::set::either::nat as cdshsen;
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    #[derive(Default)]
                    pub struct Bak {
                        pub nat: cdshsen::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    pub mod nat {
                        use crate::cst::data_structure::heap::set::either::nat::parse_error as cdshsenpe;
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        #[derive(Default)]
                        pub struct Bak {
                            pub parse_error: cdshsenpe::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        pub mod parse_error {
                            use crate::cst::data_structure as cds;
                            use std_parse_error::ParseError;
                            use tymetafuncspec_core::Either;
                            use tymetafuncspec_core::SetHeapBak;
                            /// generated by [term_specialized_gen::gen_heapbak_module]
                            #[rustfmt::skip]
                            #[derive(Default)]
                            pub struct Bak(
                                pub SetHeapBak<
                                    cds::Heap,
                                    Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
                                >,
                            );
                        }
                    }
                }
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[rustfmt::skip]
            pub mod nat_lit {
                use tymetafuncspec_core::BoundedNatHeapBak;
                use crate::cst::data_structure as cds;
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[rustfmt::skip]
                #[derive(Default)]
                pub struct Bak(pub BoundedNatHeapBak<cds::Heap>);
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[rustfmt::skip]
            pub mod idx_box {
                use crate::cst::data_structure::heap::idx_box::either as cdshibe;
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[rustfmt::skip]
                #[derive(Default)]
                pub struct Bak {
                    pub either: cdshibe::Bak,
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[rustfmt::skip]
                pub mod either {
                    use crate::cst::data_structure::heap::idx_box::either::pair as cdshibep;
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    #[derive(Default)]
                    pub struct Bak {
                        pub pair: cdshibep::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[rustfmt::skip]
                    pub mod pair {
                        use crate::cst::data_structure::heap::idx_box::either::pair::plus as cdshibepp;
                        use crate::cst::data_structure::heap::idx_box::either::pair::f as cdshibepf;
                        use crate::cst::data_structure::heap::idx_box::either::pair::sum as cdshibeps;
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        #[derive(Default)]
                        pub struct Bak {
                            pub f: cdshibepf::Bak,
                            pub plus: cdshibepp::Bak,
                            pub sum: cdshibeps::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        pub mod f {
                            use crate::cst::data_structure::heap::idx_box::either::pair::f::maybe as cdshibepfm;
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            #[derive(Default)]
                            pub struct Bak {
                                pub maybe: cdshibepfm::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            pub mod maybe {
                                use crate::cst::data_structure::heap::idx_box::either::pair::f::maybe::parse_metadata as cdshibepfmpm;
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub parse_metadata: cdshibepfmpm::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                pub mod parse_metadata {
                                    use crate::cst::data_structure::heap::idx_box::either::pair::f::maybe::parse_metadata::parse_error as cdshibepfmpmpe;
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[rustfmt::skip]
                                    #[derive(Default)]
                                    pub struct Bak {
                                        pub parse_error: cdshibepfmpmpe::Bak,
                                    }
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[rustfmt::skip]
                                    pub mod parse_error {
                                        use tymetafuncspec_core::Pair;
                                        use tymetafuncspec_core::Maybe;
                                        use std_parse_error::ParseError;
                                        use tymetafuncspec_core::IdxBoxHeapBak;
                                        use tymetafuncspec_core::Either;
                                        use crate::cst::data_structure as cds;
                                        use std_parse_metadata::ParseMetadata;
                                        /// generated by [term_specialized_gen::gen_heapbak_module]
                                        #[rustfmt::skip]
                                        #[derive(Default)]
                                        pub struct Bak(
                                            pub IdxBoxHeapBak<
                                                cds::Heap,
                                                Either<
                                                    cds::Heap,
                                                    Pair<
                                                        cds::Heap,
                                                        cds::F,
                                                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                                    >,
                                                    ParseError<cds::Heap>,
                                                >,
                                            >,
                                        );
                                    }
                                }
                            }
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        pub mod plus {
                            use crate::cst::data_structure::heap::idx_box::either::pair::plus::maybe as cdshibeppm;
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            #[derive(Default)]
                            pub struct Bak {
                                pub maybe: cdshibeppm::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            pub mod maybe {
                                use crate::cst::data_structure::heap::idx_box::either::pair::plus::maybe::parse_metadata as cdshibeppmpm;
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub parse_metadata: cdshibeppmpm::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                pub mod parse_metadata {
                                    use crate::cst::data_structure::heap::idx_box::either::pair::plus::maybe::parse_metadata::parse_error as cdshibeppmpmpe;
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[rustfmt::skip]
                                    #[derive(Default)]
                                    pub struct Bak {
                                        pub parse_error: cdshibeppmpmpe::Bak,
                                    }
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[rustfmt::skip]
                                    pub mod parse_error {
                                        use crate::cst::data_structure as cds;
                                        use tymetafuncspec_core::Maybe;
                                        use std_parse_metadata::ParseMetadata;
                                        use std_parse_error::ParseError;
                                        use tymetafuncspec_core::Either;
                                        use tymetafuncspec_core::Pair;
                                        use tymetafuncspec_core::IdxBoxHeapBak;
                                        /// generated by [term_specialized_gen::gen_heapbak_module]
                                        #[rustfmt::skip]
                                        #[derive(Default)]
                                        pub struct Bak(
                                            pub IdxBoxHeapBak<
                                                cds::Heap,
                                                Either<
                                                    cds::Heap,
                                                    Pair<
                                                        cds::Heap,
                                                        cds::Plus,
                                                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                                    >,
                                                    ParseError<cds::Heap>,
                                                >,
                                            >,
                                        );
                                    }
                                }
                            }
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[rustfmt::skip]
                        pub mod sum {
                            use crate::cst::data_structure::heap::idx_box::either::pair::sum::maybe as cdshibepsm;
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            #[derive(Default)]
                            pub struct Bak {
                                pub maybe: cdshibepsm::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[rustfmt::skip]
                            pub mod maybe {
                                use crate::cst::data_structure::heap::idx_box::either::pair::sum::maybe::parse_metadata as cdshibepsmpm;
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub parse_metadata: cdshibepsmpm::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[rustfmt::skip]
                                pub mod parse_metadata {
                                    use crate::cst::data_structure::heap::idx_box::either::pair::sum::maybe::parse_metadata::parse_error as cdshibepsmpmpe;
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[rustfmt::skip]
                                    #[derive(Default)]
                                    pub struct Bak {
                                        pub parse_error: cdshibepsmpmpe::Bak,
                                    }
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[rustfmt::skip]
                                    pub mod parse_error {
                                        use tymetafuncspec_core::Maybe;
                                        use tymetafuncspec_core::Pair;
                                        use std_parse_error::ParseError;
                                        use tymetafuncspec_core::IdxBoxHeapBak;
                                        use tymetafuncspec_core::Either;
                                        use std_parse_metadata::ParseMetadata;
                                        use crate::cst::data_structure as cds;
                                        /// generated by [term_specialized_gen::gen_heapbak_module]
                                        #[rustfmt::skip]
                                        #[derive(Default)]
                                        pub struct Bak(
                                            pub IdxBoxHeapBak<
                                                cds::Heap,
                                                Either<
                                                    cds::Heap,
                                                    Pair<
                                                        cds::Heap,
                                                        cds::Sum,
                                                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                                    >,
                                                    ParseError<cds::Heap>,
                                                >,
                                            >,
                                        );
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        /// generated by [term_specialized_gen::gen_heap]
        #[rustfmt::skip]
        pub mod superheap {
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::EitherHeapBak <
                crate ::cst::data_structure::Heap, crate ::cst::data_structure::Nat,
                std_parse_error::ParseError < crate ::cst::data_structure::Heap, > >;
                either nat parse_error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; std_parse_error::ParseErrorBak < crate
                ::cst::data_structure::Heap, >; parse_error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::EitherHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::LeftOperand,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >
                >; either pair left_operand maybe parse_metadata parse_error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::PairHeapBak <
                crate ::cst::data_structure::Heap, crate
                ::cst::data_structure::LeftOperand, tymetafuncspec_core::Maybe < crate
                ::cst::data_structure::Heap, std_parse_metadata::ParseMetadata < crate
                ::cst::data_structure::Heap, >, > >; pair left_operand maybe
                parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::MaybeHeapBak <
                crate ::cst::data_structure::Heap, std_parse_metadata::ParseMetadata <
                crate ::cst::data_structure::Heap, > >; maybe parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; std_parse_metadata::ParseMetadataBak <
                crate ::cst::data_structure::Heap, >; parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::EitherHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::RightOperand,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >
                >; either pair right_operand maybe parse_metadata parse_error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::PairHeapBak <
                crate ::cst::data_structure::Heap, crate
                ::cst::data_structure::RightOperand, tymetafuncspec_core::Maybe < crate
                ::cst::data_structure::Heap, std_parse_metadata::ParseMetadata < crate
                ::cst::data_structure::Heap, >, > >; pair right_operand maybe
                parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::EitherHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Set < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Nat,
                std_parse_error::ParseError < crate ::cst::data_structure::Heap, >, >, >,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >
                >; either pair set either nat parse_error maybe parse_metadata
                parse_error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::PairHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Set < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Nat,
                std_parse_error::ParseError < crate ::cst::data_structure::Heap, >, >, >,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                > >; pair set either nat parse_error maybe parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::SetHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Nat,
                std_parse_error::ParseError < crate ::cst::data_structure::Heap, >, > >;
                set either nat parse_error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::EitherHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::BoundedNat < crate
                ::cst::data_structure::Heap, >, tymetafuncspec_core::Maybe < crate
                ::cst::data_structure::Heap, std_parse_metadata::ParseMetadata < crate
                ::cst::data_structure::Heap, >, >, >, std_parse_error::ParseError < crate
                ::cst::data_structure::Heap, > >; either pair nat_lit maybe
                parse_metadata parse_error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::PairHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::BoundedNat <
                crate ::cst::data_structure::Heap, >, tymetafuncspec_core::Maybe < crate
                ::cst::data_structure::Heap, std_parse_metadata::ParseMetadata < crate
                ::cst::data_structure::Heap, >, > >; pair nat_lit maybe parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::BoundedNatHeapBak
                < crate ::cst::data_structure::Heap, >; nat_lit
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::EitherHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::F,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >, >, tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >
                >; either pair idx_box either pair f maybe parse_metadata parse_error
                maybe parse_metadata parse_error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::PairHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::F,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >, >, tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                > >; pair idx_box either pair f maybe parse_metadata parse_error maybe
                parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::IdxBoxHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::F,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                > >; idx_box either pair f maybe parse_metadata parse_error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::EitherHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::F,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >
                >; either pair f maybe parse_metadata parse_error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::PairHeapBak <
                crate ::cst::data_structure::Heap, crate ::cst::data_structure::F,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                > >; pair f maybe parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::EitherHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Plus,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >, >, tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >
                >; either pair idx_box either pair plus maybe parse_metadata parse_error
                maybe parse_metadata parse_error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::PairHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Plus,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >, >, tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                > >; pair idx_box either pair plus maybe parse_metadata parse_error maybe
                parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::IdxBoxHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Plus,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                > >; idx_box either pair plus maybe parse_metadata parse_error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::EitherHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Plus,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >
                >; either pair plus maybe parse_metadata parse_error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::PairHeapBak <
                crate ::cst::data_structure::Heap, crate ::cst::data_structure::Plus,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                > >; pair plus maybe parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::EitherHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Sum,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >, >, tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >
                >; either pair idx_box either pair sum maybe parse_metadata parse_error
                maybe parse_metadata parse_error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::PairHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Sum,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >, >, tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                > >; pair idx_box either pair sum maybe parse_metadata parse_error maybe
                parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::IdxBoxHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Sum,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                > >; idx_box either pair sum maybe parse_metadata parse_error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::EitherHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Sum,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >
                >; either pair sum maybe parse_metadata parse_error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::PairHeapBak <
                crate ::cst::data_structure::Heap, crate ::cst::data_structure::Sum,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                > >; pair sum maybe parse_metadata
            );
        }
        #[derive(Clone, Copy)]
        pub struct F {
            pub nat: Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
        }
        #[derive(Clone, Copy)]
        pub struct Plus {
            pub left_operand: Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    cds::LeftOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            >,
            pub right_operand: Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    cds::RightOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            >,
        }
        #[derive(Clone, Copy)]
        pub struct LeftOperand {
            pub nat: Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
        }
        #[derive(Clone, Copy)]
        pub struct RightOperand {
            pub nat: Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
        }
        #[derive(Clone, Copy)]
        pub struct Sum {
            pub set: Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    Set<cds::Heap, Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            >,
        }
        #[derive(Clone, Copy)]
        pub enum Nat {
            NatLit(
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        BoundedNat<cds::Heap>,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            ),
            F(
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::F,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            ),
            Plus(
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Plus,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            ),
            Sum(
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Sum,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            ),
        }
        /// generated by [term_specialized_gen::gen_heaped_impls]
        #[rustfmt::skip]
        pub mod heaped {
            use crate::cst::data_structure as cds;
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            #[rustfmt::skip]
            impl term::Heaped for cds::F {
                type Heap = cds::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            #[rustfmt::skip]
            impl term::Heaped for cds::Plus {
                type Heap = cds::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            #[rustfmt::skip]
            impl term::Heaped for cds::LeftOperand {
                type Heap = cds::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            #[rustfmt::skip]
            impl term::Heaped for cds::RightOperand {
                type Heap = cds::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            #[rustfmt::skip]
            impl term::Heaped for cds::Sum {
                type Heap = cds::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            #[rustfmt::skip]
            impl term::Heaped for cds::Nat {
                type Heap = cds::Heap;
            }
        }
    }
    /// generated by [term_trait_gen::generate]
    #[rustfmt::skip]
    pub mod term_trait {
        use tymetafuncspec_core::Pair;
        use std_parse_error::ParseError;
        use tymetafuncspec_core::MaybeHeapBak;
        use tymetafuncspec_core::PairHeapBak;
        use tymetafuncspec_core::IdxBox;
        use tymetafuncspec_core::EitherHeapBak;
        use tymetafuncspec_core::SetHeapBak;
        use tymetafuncspec_core::BoundedNat;
        use std_parse_metadata::ParseMetadata;
        use tymetafuncspec_core::Either;
        use term::SuperHeap;
        use term::MapsTmf;
        use std_parse_error::ParseErrorBak;
        use crate::cst::term_trait::words as cttw;
        use tymetafuncspec_core::Set;
        use crate::cst::term_trait::owned as ctto;
        use tymetafuncspec_core::IdxBoxHeapBak;
        use std_parse_metadata::ParseMetadataBak;
        use tymetafuncspec_core::BoundedNatHeapBak;
        use tymetafuncspec_core::Maybe;
        /// generated by [term_trait_gen::heap_trait]
        #[rustfmt::skip]
        pub trait Heap: Sized + MapsTmf<
                cttw::L,
                Either<Self, Self::Nat, ParseError<Self>>,
            > + MapsTmf<
                cttw::L,
                ParseError<Self>,
            > + MapsTmf<
                cttw::L,
                Either<
                    Self,
                    Pair<Self, Self::LeftOperand, Maybe<Self, ParseMetadata<Self>>>,
                    ParseError<Self>,
                >,
            > + MapsTmf<
                cttw::L,
                Pair<Self, Self::LeftOperand, Maybe<Self, ParseMetadata<Self>>>,
            > + MapsTmf<
                cttw::L,
                Maybe<Self, ParseMetadata<Self>>,
            > + MapsTmf<
                cttw::L,
                ParseMetadata<Self>,
            > + MapsTmf<
                cttw::L,
                Either<
                    Self,
                    Pair<Self, Self::RightOperand, Maybe<Self, ParseMetadata<Self>>>,
                    ParseError<Self>,
                >,
            > + MapsTmf<
                cttw::L,
                Pair<Self, Self::RightOperand, Maybe<Self, ParseMetadata<Self>>>,
            > + MapsTmf<
                cttw::L,
                Either<
                    Self,
                    Pair<
                        Self,
                        Set<Self, Either<Self, Self::Nat, ParseError<Self>>>,
                        Maybe<Self, ParseMetadata<Self>>,
                    >,
                    ParseError<Self>,
                >,
            > + MapsTmf<
                cttw::L,
                Pair<
                    Self,
                    Set<Self, Either<Self, Self::Nat, ParseError<Self>>>,
                    Maybe<Self, ParseMetadata<Self>>,
                >,
            > + MapsTmf<
                cttw::L,
                Set<Self, Either<Self, Self::Nat, ParseError<Self>>>,
            > + MapsTmf<
                cttw::L,
                Either<
                    Self,
                    Pair<Self, BoundedNat<Self>, Maybe<Self, ParseMetadata<Self>>>,
                    ParseError<Self>,
                >,
            > + MapsTmf<
                cttw::L,
                Pair<Self, BoundedNat<Self>, Maybe<Self, ParseMetadata<Self>>>,
            > + MapsTmf<
                cttw::L,
                BoundedNat<Self>,
            > + MapsTmf<
                cttw::L,
                Either<
                    Self,
                    Pair<
                        Self,
                        IdxBox<
                            Self,
                            Either<
                                Self,
                                Pair<Self, Self::F, Maybe<Self, ParseMetadata<Self>>>,
                                ParseError<Self>,
                            >,
                        >,
                        Maybe<Self, ParseMetadata<Self>>,
                    >,
                    ParseError<Self>,
                >,
            > + MapsTmf<
                cttw::L,
                Pair<
                    Self,
                    IdxBox<
                        Self,
                        Either<
                            Self,
                            Pair<Self, Self::F, Maybe<Self, ParseMetadata<Self>>>,
                            ParseError<Self>,
                        >,
                    >,
                    Maybe<Self, ParseMetadata<Self>>,
                >,
            > + MapsTmf<
                cttw::L,
                IdxBox<
                    Self,
                    Either<
                        Self,
                        Pair<Self, Self::F, Maybe<Self, ParseMetadata<Self>>>,
                        ParseError<Self>,
                    >,
                >,
            > + MapsTmf<
                cttw::L,
                Either<
                    Self,
                    Pair<Self, Self::F, Maybe<Self, ParseMetadata<Self>>>,
                    ParseError<Self>,
                >,
            > + MapsTmf<
                cttw::L,
                Pair<Self, Self::F, Maybe<Self, ParseMetadata<Self>>>,
            > + MapsTmf<
                cttw::L,
                Either<
                    Self,
                    Pair<
                        Self,
                        IdxBox<
                            Self,
                            Either<
                                Self,
                                Pair<Self, Self::Plus, Maybe<Self, ParseMetadata<Self>>>,
                                ParseError<Self>,
                            >,
                        >,
                        Maybe<Self, ParseMetadata<Self>>,
                    >,
                    ParseError<Self>,
                >,
            > + MapsTmf<
                cttw::L,
                Pair<
                    Self,
                    IdxBox<
                        Self,
                        Either<
                            Self,
                            Pair<Self, Self::Plus, Maybe<Self, ParseMetadata<Self>>>,
                            ParseError<Self>,
                        >,
                    >,
                    Maybe<Self, ParseMetadata<Self>>,
                >,
            > + MapsTmf<
                cttw::L,
                IdxBox<
                    Self,
                    Either<
                        Self,
                        Pair<Self, Self::Plus, Maybe<Self, ParseMetadata<Self>>>,
                        ParseError<Self>,
                    >,
                >,
            > + MapsTmf<
                cttw::L,
                Either<
                    Self,
                    Pair<Self, Self::Plus, Maybe<Self, ParseMetadata<Self>>>,
                    ParseError<Self>,
                >,
            > + MapsTmf<
                cttw::L,
                Pair<Self, Self::Plus, Maybe<Self, ParseMetadata<Self>>>,
            > + MapsTmf<
                cttw::L,
                Either<
                    Self,
                    Pair<
                        Self,
                        IdxBox<
                            Self,
                            Either<
                                Self,
                                Pair<Self, Self::Sum, Maybe<Self, ParseMetadata<Self>>>,
                                ParseError<Self>,
                            >,
                        >,
                        Maybe<Self, ParseMetadata<Self>>,
                    >,
                    ParseError<Self>,
                >,
            > + MapsTmf<
                cttw::L,
                Pair<
                    Self,
                    IdxBox<
                        Self,
                        Either<
                            Self,
                            Pair<Self, Self::Sum, Maybe<Self, ParseMetadata<Self>>>,
                            ParseError<Self>,
                        >,
                    >,
                    Maybe<Self, ParseMetadata<Self>>,
                >,
            > + MapsTmf<
                cttw::L,
                IdxBox<
                    Self,
                    Either<
                        Self,
                        Pair<Self, Self::Sum, Maybe<Self, ParseMetadata<Self>>>,
                        ParseError<Self>,
                    >,
                >,
            > + MapsTmf<
                cttw::L,
                Either<
                    Self,
                    Pair<Self, Self::Sum, Maybe<Self, ParseMetadata<Self>>>,
                    ParseError<Self>,
                >,
            > + MapsTmf<
                cttw::L,
                Pair<Self, Self::Sum, Maybe<Self, ParseMetadata<Self>>>,
            > + SuperHeap<
                EitherHeapBak<Self, Self::Nat, ParseError<Self>>,
            > + SuperHeap<
                ParseErrorBak<Self>,
            > + SuperHeap<
                EitherHeapBak<
                    Self,
                    Pair<Self, Self::LeftOperand, Maybe<Self, ParseMetadata<Self>>>,
                    ParseError<Self>,
                >,
            > + SuperHeap<
                PairHeapBak<Self, Self::LeftOperand, Maybe<Self, ParseMetadata<Self>>>,
            > + SuperHeap<
                MaybeHeapBak<Self, ParseMetadata<Self>>,
            > + SuperHeap<
                ParseMetadataBak<Self>,
            > + SuperHeap<
                EitherHeapBak<
                    Self,
                    Pair<Self, Self::RightOperand, Maybe<Self, ParseMetadata<Self>>>,
                    ParseError<Self>,
                >,
            > + SuperHeap<
                PairHeapBak<Self, Self::RightOperand, Maybe<Self, ParseMetadata<Self>>>,
            > + SuperHeap<
                EitherHeapBak<
                    Self,
                    Pair<
                        Self,
                        Set<Self, Either<Self, Self::Nat, ParseError<Self>>>,
                        Maybe<Self, ParseMetadata<Self>>,
                    >,
                    ParseError<Self>,
                >,
            > + SuperHeap<
                PairHeapBak<
                    Self,
                    Set<Self, Either<Self, Self::Nat, ParseError<Self>>>,
                    Maybe<Self, ParseMetadata<Self>>,
                >,
            > + SuperHeap<
                SetHeapBak<Self, Either<Self, Self::Nat, ParseError<Self>>>,
            > + SuperHeap<
                EitherHeapBak<
                    Self,
                    Pair<Self, BoundedNat<Self>, Maybe<Self, ParseMetadata<Self>>>,
                    ParseError<Self>,
                >,
            > + SuperHeap<
                PairHeapBak<Self, BoundedNat<Self>, Maybe<Self, ParseMetadata<Self>>>,
            > + SuperHeap<
                BoundedNatHeapBak<Self>,
            > + SuperHeap<
                EitherHeapBak<
                    Self,
                    Pair<
                        Self,
                        IdxBox<
                            Self,
                            Either<
                                Self,
                                Pair<Self, Self::F, Maybe<Self, ParseMetadata<Self>>>,
                                ParseError<Self>,
                            >,
                        >,
                        Maybe<Self, ParseMetadata<Self>>,
                    >,
                    ParseError<Self>,
                >,
            > + SuperHeap<
                PairHeapBak<
                    Self,
                    IdxBox<
                        Self,
                        Either<
                            Self,
                            Pair<Self, Self::F, Maybe<Self, ParseMetadata<Self>>>,
                            ParseError<Self>,
                        >,
                    >,
                    Maybe<Self, ParseMetadata<Self>>,
                >,
            > + SuperHeap<
                IdxBoxHeapBak<
                    Self,
                    Either<
                        Self,
                        Pair<Self, Self::F, Maybe<Self, ParseMetadata<Self>>>,
                        ParseError<Self>,
                    >,
                >,
            > + SuperHeap<
                EitherHeapBak<
                    Self,
                    Pair<Self, Self::F, Maybe<Self, ParseMetadata<Self>>>,
                    ParseError<Self>,
                >,
            > + SuperHeap<
                PairHeapBak<Self, Self::F, Maybe<Self, ParseMetadata<Self>>>,
            > + SuperHeap<
                EitherHeapBak<
                    Self,
                    Pair<
                        Self,
                        IdxBox<
                            Self,
                            Either<
                                Self,
                                Pair<Self, Self::Plus, Maybe<Self, ParseMetadata<Self>>>,
                                ParseError<Self>,
                            >,
                        >,
                        Maybe<Self, ParseMetadata<Self>>,
                    >,
                    ParseError<Self>,
                >,
            > + SuperHeap<
                PairHeapBak<
                    Self,
                    IdxBox<
                        Self,
                        Either<
                            Self,
                            Pair<Self, Self::Plus, Maybe<Self, ParseMetadata<Self>>>,
                            ParseError<Self>,
                        >,
                    >,
                    Maybe<Self, ParseMetadata<Self>>,
                >,
            > + SuperHeap<
                IdxBoxHeapBak<
                    Self,
                    Either<
                        Self,
                        Pair<Self, Self::Plus, Maybe<Self, ParseMetadata<Self>>>,
                        ParseError<Self>,
                    >,
                >,
            > + SuperHeap<
                EitherHeapBak<
                    Self,
                    Pair<Self, Self::Plus, Maybe<Self, ParseMetadata<Self>>>,
                    ParseError<Self>,
                >,
            > + SuperHeap<
                PairHeapBak<Self, Self::Plus, Maybe<Self, ParseMetadata<Self>>>,
            > + SuperHeap<
                EitherHeapBak<
                    Self,
                    Pair<
                        Self,
                        IdxBox<
                            Self,
                            Either<
                                Self,
                                Pair<Self, Self::Sum, Maybe<Self, ParseMetadata<Self>>>,
                                ParseError<Self>,
                            >,
                        >,
                        Maybe<Self, ParseMetadata<Self>>,
                    >,
                    ParseError<Self>,
                >,
            > + SuperHeap<
                PairHeapBak<
                    Self,
                    IdxBox<
                        Self,
                        Either<
                            Self,
                            Pair<Self, Self::Sum, Maybe<Self, ParseMetadata<Self>>>,
                            ParseError<Self>,
                        >,
                    >,
                    Maybe<Self, ParseMetadata<Self>>,
                >,
            > + SuperHeap<
                IdxBoxHeapBak<
                    Self,
                    Either<
                        Self,
                        Pair<Self, Self::Sum, Maybe<Self, ParseMetadata<Self>>>,
                        ParseError<Self>,
                    >,
                >,
            > + SuperHeap<
                EitherHeapBak<
                    Self,
                    Pair<Self, Self::Sum, Maybe<Self, ParseMetadata<Self>>>,
                    ParseError<Self>,
                >,
            > + SuperHeap<
                PairHeapBak<Self, Self::Sum, Maybe<Self, ParseMetadata<Self>>>,
            > {
            type F: ctto::F<Heap = Self>;
            type Plus: ctto::Plus<Heap = Self>;
            type LeftOperand: ctto::LeftOperand<Heap = Self>;
            type RightOperand: ctto::RightOperand<Heap = Self>;
            type Sum: ctto::Sum<Heap = Self>;
            type Nat: ctto::Nat<Heap = Self>;
        }
        /// generated by [term_trait_gen::owned::generate]
        #[rustfmt::skip]
        pub mod owned {
            use tymetafuncspec_core::Set;
            use tymetafuncspec_core::Either;
            use term::CanonicallyConstructibleFrom;
            use term::Heaped;
            use tymetafuncspec_core::Pair;
            use tymetafuncspec_core::BoundedNat;
            use tymetafuncspec_core::Maybe;
            use tymetafuncspec_core::IdxBox;
            use std_parse_error::ParseError;
            use std_parse_metadata::ParseMetadata;
            use crate::cst::term_trait::words as cttw;
            use crate::cst::term_trait as ctt;
            use term::MapsTmf;
            pub trait F: Heaped + CanonicallyConstructibleFrom<
                    <Self as Heaped>::Heap,
                    (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                <<Self as Heaped>::Heap as ctt::Heap>::Nat,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ),
                >
            where
                <Self as Heaped>::Heap: ctt::Heap,
            {}
            pub trait Plus: Heaped + CanonicallyConstructibleFrom<
                    <Self as Heaped>::Heap,
                    (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                Pair<
                                    <Self as Heaped>::Heap,
                                    <<Self as Heaped>::Heap as ctt::Heap>::LeftOperand,
                                    Maybe<
                                        <Self as Heaped>::Heap,
                                        ParseMetadata<<Self as Heaped>::Heap>,
                                    >,
                                >,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (
                            <<Self as Heaped>::Heap as MapsTmf<
                                cttw::L,
                                Either<
                                    <Self as Heaped>::Heap,
                                    Pair<
                                        <Self as Heaped>::Heap,
                                        <<Self as Heaped>::Heap as ctt::Heap>::RightOperand,
                                        Maybe<
                                            <Self as Heaped>::Heap,
                                            ParseMetadata<<Self as Heaped>::Heap>,
                                        >,
                                    >,
                                    ParseError<<Self as Heaped>::Heap>,
                                >,
                            >>::Tmf,
                            (),
                        ),
                    ),
                >
            where
                <Self as Heaped>::Heap: ctt::Heap,
            {}
            pub trait LeftOperand: Heaped + CanonicallyConstructibleFrom<
                    <Self as Heaped>::Heap,
                    (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                <<Self as Heaped>::Heap as ctt::Heap>::Nat,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ),
                >
            where
                <Self as Heaped>::Heap: ctt::Heap,
            {}
            pub trait RightOperand: Heaped + CanonicallyConstructibleFrom<
                    <Self as Heaped>::Heap,
                    (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                <<Self as Heaped>::Heap as ctt::Heap>::Nat,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ),
                >
            where
                <Self as Heaped>::Heap: ctt::Heap,
            {}
            pub trait Sum: Heaped + CanonicallyConstructibleFrom<
                    <Self as Heaped>::Heap,
                    (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                Pair<
                                    <Self as Heaped>::Heap,
                                    Set<
                                        <Self as Heaped>::Heap,
                                        Either<
                                            <Self as Heaped>::Heap,
                                            <<Self as Heaped>::Heap as ctt::Heap>::Nat,
                                            ParseError<<Self as Heaped>::Heap>,
                                        >,
                                    >,
                                    Maybe<
                                        <Self as Heaped>::Heap,
                                        ParseMetadata<<Self as Heaped>::Heap>,
                                    >,
                                >,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ),
                >
            where
                <Self as Heaped>::Heap: ctt::Heap,
            {}
            pub trait Nat: Heaped + CanonicallyConstructibleFrom<
                    <Self as Heaped>::Heap,
                    (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                Pair<
                                    <Self as Heaped>::Heap,
                                    BoundedNat<<Self as Heaped>::Heap>,
                                    Maybe<
                                        <Self as Heaped>::Heap,
                                        ParseMetadata<<Self as Heaped>::Heap>,
                                    >,
                                >,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ),
                > + CanonicallyConstructibleFrom<
                    <Self as Heaped>::Heap,
                    (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                Pair<
                                    <Self as Heaped>::Heap,
                                    IdxBox<
                                        <Self as Heaped>::Heap,
                                        Either<
                                            <Self as Heaped>::Heap,
                                            Pair<
                                                <Self as Heaped>::Heap,
                                                <<Self as Heaped>::Heap as ctt::Heap>::F,
                                                Maybe<
                                                    <Self as Heaped>::Heap,
                                                    ParseMetadata<<Self as Heaped>::Heap>,
                                                >,
                                            >,
                                            ParseError<<Self as Heaped>::Heap>,
                                        >,
                                    >,
                                    Maybe<
                                        <Self as Heaped>::Heap,
                                        ParseMetadata<<Self as Heaped>::Heap>,
                                    >,
                                >,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ),
                > + CanonicallyConstructibleFrom<
                    <Self as Heaped>::Heap,
                    (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                Pair<
                                    <Self as Heaped>::Heap,
                                    IdxBox<
                                        <Self as Heaped>::Heap,
                                        Either<
                                            <Self as Heaped>::Heap,
                                            Pair<
                                                <Self as Heaped>::Heap,
                                                <<Self as Heaped>::Heap as ctt::Heap>::Plus,
                                                Maybe<
                                                    <Self as Heaped>::Heap,
                                                    ParseMetadata<<Self as Heaped>::Heap>,
                                                >,
                                            >,
                                            ParseError<<Self as Heaped>::Heap>,
                                        >,
                                    >,
                                    Maybe<
                                        <Self as Heaped>::Heap,
                                        ParseMetadata<<Self as Heaped>::Heap>,
                                    >,
                                >,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ),
                > + CanonicallyConstructibleFrom<
                    <Self as Heaped>::Heap,
                    (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                Pair<
                                    <Self as Heaped>::Heap,
                                    IdxBox<
                                        <Self as Heaped>::Heap,
                                        Either<
                                            <Self as Heaped>::Heap,
                                            Pair<
                                                <Self as Heaped>::Heap,
                                                <<Self as Heaped>::Heap as ctt::Heap>::Sum,
                                                Maybe<
                                                    <Self as Heaped>::Heap,
                                                    ParseMetadata<<Self as Heaped>::Heap>,
                                                >,
                                            >,
                                            ParseError<<Self as Heaped>::Heap>,
                                        >,
                                    >,
                                    Maybe<
                                        <Self as Heaped>::Heap,
                                        ParseMetadata<<Self as Heaped>::Heap>,
                                    >,
                                >,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ),
                >
            where
                <Self as Heaped>::Heap: ctt::Heap,
            {}
        }
        /// generated by [words::words_mod]
        #[rustfmt::skip]
        pub mod words {
            pub struct L;
            pub mod sorts {
                pub struct F;
                pub struct Plus;
                pub struct LeftOperand;
                pub struct RightOperand;
                pub struct Sum;
                pub struct Nat;
            }
        }
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::generate]
    #[rustfmt::skip]
    pub mod pattern_match_strategy {
        use tymetafuncspec_core::BoundedNat;
        use tymetafuncspec_core::Set;
        use tymetafuncspec_core::IdxBox;
        use crate::cst::term_trait::words as cttw;
        use crate::cst::pattern_match_strategy as cpms;
        use std::marker::PhantomData;
        use term::MapsTmf;
        use term::case_split::HasPatternMatchStrategyFor;
        use crate::cst::term_trait as ctt;
        use words::Implements;
        use crate::cst::term_trait::words::sorts as cttws;
        use tymetafuncspec_core::Pair;
        use tymetafuncspec_core::Either;
        use tymetafuncspec_core::Maybe;
        use std_parse_metadata::ParseMetadata;
        use std_parse_error::ParseError;
        use crate::cst::data_structure as cds;
        impl<Heap: ctt::Heap, T> term::case_split::HasPatternMatchStrategyFor<T>
        for PatternMatchStrategyProvider<Heap>
        where
            T: Implements<cttw::L>,
            PatternMatchStrategyProvider<Heap>: HasPatternMatchStrategyFor<T::LWord>,
        {
            type Strategy = <PatternMatchStrategyProvider<
                Heap,
            > as HasPatternMatchStrategyFor<T::LWord>>::Strategy;
        }
        pub struct PatternMatchStrategyProvider<Heap>(PhantomData<Heap>);
        /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
        #[rustfmt::skip]
        impl<Heap: ctt::Heap> term::case_split::HasPatternMatchStrategyFor<cttws::F>
        for PatternMatchStrategyProvider<Heap> {
            type Strategy = (
                (
                    <Heap as MapsTmf<
                        cttw::L,
                        Either<Heap, Heap::Nat, ParseError<Heap>>,
                    >>::Tmf,
                    (),
                ),
                (),
            );
        }
        /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
        #[rustfmt::skip]
        impl<Heap: ctt::Heap> term::case_split::HasPatternMatchStrategyFor<cttws::Plus>
        for PatternMatchStrategyProvider<Heap> {
            type Strategy = (
                (
                    <Heap as MapsTmf<
                        cttw::L,
                        Either<
                            Heap,
                            Pair<
                                Heap,
                                Heap::LeftOperand,
                                Maybe<Heap, ParseMetadata<Heap>>,
                            >,
                            ParseError<Heap>,
                        >,
                    >>::Tmf,
                    (
                        <Heap as MapsTmf<
                            cttw::L,
                            Either<
                                Heap,
                                Pair<
                                    Heap,
                                    Heap::RightOperand,
                                    Maybe<Heap, ParseMetadata<Heap>>,
                                >,
                                ParseError<Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ),
                ),
                (),
            );
        }
        /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
        #[rustfmt::skip]
        impl<
            Heap: ctt::Heap,
        > term::case_split::HasPatternMatchStrategyFor<cttws::LeftOperand>
        for PatternMatchStrategyProvider<Heap> {
            type Strategy = (
                (
                    <Heap as MapsTmf<
                        cttw::L,
                        Either<Heap, Heap::Nat, ParseError<Heap>>,
                    >>::Tmf,
                    (),
                ),
                (),
            );
        }
        /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
        #[rustfmt::skip]
        impl<
            Heap: ctt::Heap,
        > term::case_split::HasPatternMatchStrategyFor<cttws::RightOperand>
        for PatternMatchStrategyProvider<Heap> {
            type Strategy = (
                (
                    <Heap as MapsTmf<
                        cttw::L,
                        Either<Heap, Heap::Nat, ParseError<Heap>>,
                    >>::Tmf,
                    (),
                ),
                (),
            );
        }
        /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
        #[rustfmt::skip]
        impl<Heap: ctt::Heap> term::case_split::HasPatternMatchStrategyFor<cttws::Sum>
        for PatternMatchStrategyProvider<Heap> {
            type Strategy = (
                (
                    <Heap as MapsTmf<
                        cttw::L,
                        Either<
                            Heap,
                            Pair<
                                Heap,
                                Set<Heap, Either<Heap, Heap::Nat, ParseError<Heap>>>,
                                Maybe<Heap, ParseMetadata<Heap>>,
                            >,
                            ParseError<Heap>,
                        >,
                    >>::Tmf,
                    (),
                ),
                (),
            );
        }
        /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
        #[rustfmt::skip]
        impl<Heap: ctt::Heap> term::case_split::HasPatternMatchStrategyFor<cttws::Nat>
        for PatternMatchStrategyProvider<Heap> {
            type Strategy = (
                (
                    <Heap as MapsTmf<
                        cttw::L,
                        Either<
                            Heap,
                            Pair<
                                Heap,
                                BoundedNat<Heap>,
                                Maybe<Heap, ParseMetadata<Heap>>,
                            >,
                            ParseError<Heap>,
                        >,
                    >>::Tmf,
                    (),
                ),
                (
                    (
                        <Heap as MapsTmf<
                            cttw::L,
                            Either<
                                Heap,
                                Pair<
                                    Heap,
                                    IdxBox<
                                        Heap,
                                        Either<
                                            Heap,
                                            Pair<Heap, Heap::F, Maybe<Heap, ParseMetadata<Heap>>>,
                                            ParseError<Heap>,
                                        >,
                                    >,
                                    Maybe<Heap, ParseMetadata<Heap>>,
                                >,
                                ParseError<Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ),
                    (
                        (
                            <Heap as MapsTmf<
                                cttw::L,
                                Either<
                                    Heap,
                                    Pair<
                                        Heap,
                                        IdxBox<
                                            Heap,
                                            Either<
                                                Heap,
                                                Pair<Heap, Heap::Plus, Maybe<Heap, ParseMetadata<Heap>>>,
                                                ParseError<Heap>,
                                            >,
                                        >,
                                        Maybe<Heap, ParseMetadata<Heap>>,
                                    >,
                                    ParseError<Heap>,
                                >,
                            >>::Tmf,
                            (),
                        ),
                        (
                            (
                                <Heap as MapsTmf<
                                    cttw::L,
                                    Either<
                                        Heap,
                                        Pair<
                                            Heap,
                                            IdxBox<
                                                Heap,
                                                Either<
                                                    Heap,
                                                    Pair<Heap, Heap::Sum, Maybe<Heap, ParseMetadata<Heap>>>,
                                                    ParseError<Heap>,
                                                >,
                                            >,
                                            Maybe<Heap, ParseMetadata<Heap>>,
                                        >,
                                        ParseError<Heap>,
                                    >,
                                >>::Tmf,
                                (),
                            ),
                            (),
                        ),
                    ),
                ),
            );
        }
        /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
        #[rustfmt::skip]
        impl term::case_split::Adt for cds::F {
            type PatternMatchStrategyProvider = cpms::PatternMatchStrategyProvider<
                cds::Heap,
            >;
        }
        /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
        #[rustfmt::skip]
        impl term::case_split::Adt for cds::Plus {
            type PatternMatchStrategyProvider = cpms::PatternMatchStrategyProvider<
                cds::Heap,
            >;
        }
        /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
        #[rustfmt::skip]
        impl term::case_split::Adt for cds::LeftOperand {
            type PatternMatchStrategyProvider = cpms::PatternMatchStrategyProvider<
                cds::Heap,
            >;
        }
        /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
        #[rustfmt::skip]
        impl term::case_split::Adt for cds::RightOperand {
            type PatternMatchStrategyProvider = cpms::PatternMatchStrategyProvider<
                cds::Heap,
            >;
        }
        /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
        #[rustfmt::skip]
        impl term::case_split::Adt for cds::Sum {
            type PatternMatchStrategyProvider = cpms::PatternMatchStrategyProvider<
                cds::Heap,
            >;
        }
        /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
        #[rustfmt::skip]
        impl term::case_split::Adt for cds::Nat {
            type PatternMatchStrategyProvider = cpms::PatternMatchStrategyProvider<
                cds::Heap,
            >;
        }
    }
    /// generated by [words::words_impls]
    #[rustfmt::skip]
    pub mod words_impls {
        use crate::cst::data_structure as cds;
        use crate::cst::term_trait::words::sorts as cttws;
        use crate::cst::term_trait::words as cttw;
        impl words::Implements<cttw::L> for cds::F {
            type LWord = cttws::F;
        }
        impl words::Implements<cttw::L> for cds::Plus {
            type LWord = cttws::Plus;
        }
        impl words::Implements<cttw::L> for cds::LeftOperand {
            type LWord = cttws::LeftOperand;
        }
        impl words::Implements<cttw::L> for cds::RightOperand {
            type LWord = cttws::RightOperand;
        }
        impl words::Implements<cttw::L> for cds::Sum {
            type LWord = cttws::Sum;
        }
        impl words::Implements<cttw::L> for cds::Nat {
            type LWord = cttws::Nat;
        }
    }
    /// generated by [term_specialized_impl_gen::generate]
    #[rustfmt::skip]
    pub mod term_impls {
        use crate::cst::data_structure as cds;
        /// generated by [term_specialized_impl_gen::gen_heap_impl]
        #[rustfmt::skip]
        impl crate::cst::term_trait::Heap for cds::Heap {
            type F = cds::F;
            type Plus = cds::Plus;
            type LeftOperand = cds::LeftOperand;
            type RightOperand = cds::RightOperand;
            type Sum = cds::Sum;
            type Nat = cds::Nat;
        }
        /// generated by [term_specialized_impl_gen::gen_owned_mod]
        #[rustfmt::skip]
        pub mod owned_impls {
            use crate::cst::data_structure as cds;
            impl crate::cst::term_trait::owned::F for cds::F {}
            impl crate::cst::term_trait::owned::Plus for cds::Plus {}
            impl crate::cst::term_trait::owned::LeftOperand for cds::LeftOperand {}
            impl crate::cst::term_trait::owned::RightOperand for cds::RightOperand {}
            impl crate::cst::term_trait::owned::Sum for cds::Sum {}
            impl crate::cst::term_trait::owned::Nat for cds::Nat {}
        }
        /// generated by [term_specialized_impl_gen::gen_ccf_mod]
        #[rustfmt::skip]
        pub mod ccf_impls {
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            #[rustfmt::skip]
            pub mod f {
                use tymetafuncspec_core::Either;
                use crate::cst::term_trait::words as cttw;
                use crate::cst::data_structure as cds;
                use term::MapsTmf;
                use std_parse_error::ParseError;
                use term::Heaped;
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                #[rustfmt::skip]
                impl term::DirectlyCanonicallyConstructibleFrom<
                    <Self as Heaped>::Heap,
                    (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                cds::Nat,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ),
                > for cds::F {
                    fn construct(
                        heap: &mut <Self as Heaped>::Heap,
                        t: (
                            <<Self as Heaped>::Heap as MapsTmf<
                                cttw::L,
                                Either<
                                    <Self as Heaped>::Heap,
                                    cds::Nat,
                                    ParseError<<Self as Heaped>::Heap>,
                                >,
                            >>::Tmf,
                            (),
                        ),
                    ) -> Self {
                        crate::cst::data_structure::F {
                            nat: t.0,
                        }
                    }
                    fn deconstruct_succeeds(
                        &self,
                        heap: &<Self as Heaped>::Heap,
                    ) -> bool {
                        true
                    }
                    fn deconstruct(
                        self,
                        heap: &<Self as Heaped>::Heap,
                    ) -> (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                cds::Nat,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ) {
                        (self.nat, ())
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            #[rustfmt::skip]
            pub mod plus {
                use std_parse_error::ParseError;
                use crate::cst::term_trait::words as cttw;
                use tymetafuncspec_core::Pair;
                use term::MapsTmf;
                use std_parse_metadata::ParseMetadata;
                use tymetafuncspec_core::Maybe;
                use tymetafuncspec_core::Either;
                use term::Heaped;
                use crate::cst::data_structure as cds;
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                #[rustfmt::skip]
                impl term::DirectlyCanonicallyConstructibleFrom<
                    <Self as Heaped>::Heap,
                    (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                Pair<
                                    <Self as Heaped>::Heap,
                                    cds::LeftOperand,
                                    Maybe<
                                        <Self as Heaped>::Heap,
                                        ParseMetadata<<Self as Heaped>::Heap>,
                                    >,
                                >,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (
                            <<Self as Heaped>::Heap as MapsTmf<
                                cttw::L,
                                Either<
                                    <Self as Heaped>::Heap,
                                    Pair<
                                        <Self as Heaped>::Heap,
                                        cds::RightOperand,
                                        Maybe<
                                            <Self as Heaped>::Heap,
                                            ParseMetadata<<Self as Heaped>::Heap>,
                                        >,
                                    >,
                                    ParseError<<Self as Heaped>::Heap>,
                                >,
                            >>::Tmf,
                            (),
                        ),
                    ),
                > for cds::Plus {
                    fn construct(
                        heap: &mut <Self as Heaped>::Heap,
                        t: (
                            <<Self as Heaped>::Heap as MapsTmf<
                                cttw::L,
                                Either<
                                    <Self as Heaped>::Heap,
                                    Pair<
                                        <Self as Heaped>::Heap,
                                        cds::LeftOperand,
                                        Maybe<
                                            <Self as Heaped>::Heap,
                                            ParseMetadata<<Self as Heaped>::Heap>,
                                        >,
                                    >,
                                    ParseError<<Self as Heaped>::Heap>,
                                >,
                            >>::Tmf,
                            (
                                <<Self as Heaped>::Heap as MapsTmf<
                                    cttw::L,
                                    Either<
                                        <Self as Heaped>::Heap,
                                        Pair<
                                            <Self as Heaped>::Heap,
                                            cds::RightOperand,
                                            Maybe<
                                                <Self as Heaped>::Heap,
                                                ParseMetadata<<Self as Heaped>::Heap>,
                                            >,
                                        >,
                                        ParseError<<Self as Heaped>::Heap>,
                                    >,
                                >>::Tmf,
                                (),
                            ),
                        ),
                    ) -> Self {
                        crate::cst::data_structure::Plus {
                            left_operand: t.0,
                            right_operand: t.1.0,
                        }
                    }
                    fn deconstruct_succeeds(
                        &self,
                        heap: &<Self as Heaped>::Heap,
                    ) -> bool {
                        true
                    }
                    fn deconstruct(
                        self,
                        heap: &<Self as Heaped>::Heap,
                    ) -> (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                Pair<
                                    <Self as Heaped>::Heap,
                                    cds::LeftOperand,
                                    Maybe<
                                        <Self as Heaped>::Heap,
                                        ParseMetadata<<Self as Heaped>::Heap>,
                                    >,
                                >,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (
                            <<Self as Heaped>::Heap as MapsTmf<
                                cttw::L,
                                Either<
                                    <Self as Heaped>::Heap,
                                    Pair<
                                        <Self as Heaped>::Heap,
                                        cds::RightOperand,
                                        Maybe<
                                            <Self as Heaped>::Heap,
                                            ParseMetadata<<Self as Heaped>::Heap>,
                                        >,
                                    >,
                                    ParseError<<Self as Heaped>::Heap>,
                                >,
                            >>::Tmf,
                            (),
                        ),
                    ) {
                        (self.left_operand, (self.right_operand, ()))
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            #[rustfmt::skip]
            pub mod left_operand {
                use tymetafuncspec_core::Either;
                use term::MapsTmf;
                use term::Heaped;
                use crate::cst::term_trait::words as cttw;
                use crate::cst::data_structure as cds;
                use std_parse_error::ParseError;
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                #[rustfmt::skip]
                impl term::DirectlyCanonicallyConstructibleFrom<
                    <Self as Heaped>::Heap,
                    (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                cds::Nat,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ),
                > for cds::LeftOperand {
                    fn construct(
                        heap: &mut <Self as Heaped>::Heap,
                        t: (
                            <<Self as Heaped>::Heap as MapsTmf<
                                cttw::L,
                                Either<
                                    <Self as Heaped>::Heap,
                                    cds::Nat,
                                    ParseError<<Self as Heaped>::Heap>,
                                >,
                            >>::Tmf,
                            (),
                        ),
                    ) -> Self {
                        crate::cst::data_structure::LeftOperand {
                            nat: t.0,
                        }
                    }
                    fn deconstruct_succeeds(
                        &self,
                        heap: &<Self as Heaped>::Heap,
                    ) -> bool {
                        true
                    }
                    fn deconstruct(
                        self,
                        heap: &<Self as Heaped>::Heap,
                    ) -> (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                cds::Nat,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ) {
                        (self.nat, ())
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            #[rustfmt::skip]
            pub mod right_operand {
                use crate::cst::data_structure as cds;
                use term::Heaped;
                use term::MapsTmf;
                use crate::cst::term_trait::words as cttw;
                use std_parse_error::ParseError;
                use tymetafuncspec_core::Either;
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                #[rustfmt::skip]
                impl term::DirectlyCanonicallyConstructibleFrom<
                    <Self as Heaped>::Heap,
                    (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                cds::Nat,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ),
                > for cds::RightOperand {
                    fn construct(
                        heap: &mut <Self as Heaped>::Heap,
                        t: (
                            <<Self as Heaped>::Heap as MapsTmf<
                                cttw::L,
                                Either<
                                    <Self as Heaped>::Heap,
                                    cds::Nat,
                                    ParseError<<Self as Heaped>::Heap>,
                                >,
                            >>::Tmf,
                            (),
                        ),
                    ) -> Self {
                        crate::cst::data_structure::RightOperand {
                            nat: t.0,
                        }
                    }
                    fn deconstruct_succeeds(
                        &self,
                        heap: &<Self as Heaped>::Heap,
                    ) -> bool {
                        true
                    }
                    fn deconstruct(
                        self,
                        heap: &<Self as Heaped>::Heap,
                    ) -> (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                cds::Nat,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ) {
                        (self.nat, ())
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            #[rustfmt::skip]
            pub mod sum {
                use tymetafuncspec_core::Pair;
                use term::MapsTmf;
                use term::Heaped;
                use crate::cst::data_structure as cds;
                use std_parse_metadata::ParseMetadata;
                use tymetafuncspec_core::Set;
                use tymetafuncspec_core::Maybe;
                use tymetafuncspec_core::Either;
                use std_parse_error::ParseError;
                use crate::cst::term_trait::words as cttw;
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                #[rustfmt::skip]
                impl term::DirectlyCanonicallyConstructibleFrom<
                    <Self as Heaped>::Heap,
                    (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                Pair<
                                    <Self as Heaped>::Heap,
                                    Set<
                                        <Self as Heaped>::Heap,
                                        Either<
                                            <Self as Heaped>::Heap,
                                            cds::Nat,
                                            ParseError<<Self as Heaped>::Heap>,
                                        >,
                                    >,
                                    Maybe<
                                        <Self as Heaped>::Heap,
                                        ParseMetadata<<Self as Heaped>::Heap>,
                                    >,
                                >,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ),
                > for cds::Sum {
                    fn construct(
                        heap: &mut <Self as Heaped>::Heap,
                        t: (
                            <<Self as Heaped>::Heap as MapsTmf<
                                cttw::L,
                                Either<
                                    <Self as Heaped>::Heap,
                                    Pair<
                                        <Self as Heaped>::Heap,
                                        Set<
                                            <Self as Heaped>::Heap,
                                            Either<
                                                <Self as Heaped>::Heap,
                                                cds::Nat,
                                                ParseError<<Self as Heaped>::Heap>,
                                            >,
                                        >,
                                        Maybe<
                                            <Self as Heaped>::Heap,
                                            ParseMetadata<<Self as Heaped>::Heap>,
                                        >,
                                    >,
                                    ParseError<<Self as Heaped>::Heap>,
                                >,
                            >>::Tmf,
                            (),
                        ),
                    ) -> Self {
                        crate::cst::data_structure::Sum {
                            set: t.0,
                        }
                    }
                    fn deconstruct_succeeds(
                        &self,
                        heap: &<Self as Heaped>::Heap,
                    ) -> bool {
                        true
                    }
                    fn deconstruct(
                        self,
                        heap: &<Self as Heaped>::Heap,
                    ) -> (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                Pair<
                                    <Self as Heaped>::Heap,
                                    Set<
                                        <Self as Heaped>::Heap,
                                        Either<
                                            <Self as Heaped>::Heap,
                                            cds::Nat,
                                            ParseError<<Self as Heaped>::Heap>,
                                        >,
                                    >,
                                    Maybe<
                                        <Self as Heaped>::Heap,
                                        ParseMetadata<<Self as Heaped>::Heap>,
                                    >,
                                >,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ) {
                        (self.set, ())
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            #[rustfmt::skip]
            pub mod nat {
                use term::Heaped;
                use tymetafuncspec_core::IdxBox;
                use tymetafuncspec_core::Pair;
                use tymetafuncspec_core::Maybe;
                use tymetafuncspec_core::Either;
                use std_parse_error::ParseError;
                use crate::cst::term_trait::words as cttw;
                use tymetafuncspec_core::BoundedNat;
                use term::MapsTmf;
                use std_parse_metadata::ParseMetadata;
                use crate::cst::data_structure as cds;
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
                #[rustfmt::skip]
                impl term::DirectlyCanonicallyConstructibleFrom<
                    <Self as Heaped>::Heap,
                    (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                Pair<
                                    <Self as Heaped>::Heap,
                                    BoundedNat<<Self as Heaped>::Heap>,
                                    Maybe<
                                        <Self as Heaped>::Heap,
                                        ParseMetadata<<Self as Heaped>::Heap>,
                                    >,
                                >,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ),
                > for cds::Nat {
                    fn construct(
                        heap: &mut <Self as Heaped>::Heap,
                        t: (
                            <<Self as Heaped>::Heap as MapsTmf<
                                cttw::L,
                                Either<
                                    <Self as Heaped>::Heap,
                                    Pair<
                                        <Self as Heaped>::Heap,
                                        BoundedNat<<Self as Heaped>::Heap>,
                                        Maybe<
                                            <Self as Heaped>::Heap,
                                            ParseMetadata<<Self as Heaped>::Heap>,
                                        >,
                                    >,
                                    ParseError<<Self as Heaped>::Heap>,
                                >,
                            >>::Tmf,
                            (),
                        ),
                    ) -> Self {
                        crate::cst::data_structure::Nat::NatLit(t.0)
                    }
                    fn deconstruct_succeeds(
                        &self,
                        heap: &<Self as Heaped>::Heap,
                    ) -> bool {
                        match self {
                            crate::cst::data_structure::Nat::NatLit(_) => true,
                            _ => false,
                        }
                    }
                    fn deconstruct(
                        self,
                        heap: &<Self as Heaped>::Heap,
                    ) -> (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                Pair<
                                    <Self as Heaped>::Heap,
                                    BoundedNat<<Self as Heaped>::Heap>,
                                    Maybe<
                                        <Self as Heaped>::Heap,
                                        ParseMetadata<<Self as Heaped>::Heap>,
                                    >,
                                >,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ) {
                        match self {
                            crate::cst::data_structure::Nat::NatLit(t) => (t, ()),
                            _ => panic!("conversion failure"),
                        }
                    }
                }
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
                #[rustfmt::skip]
                impl term::DirectlyCanonicallyConstructibleFrom<
                    <Self as Heaped>::Heap,
                    (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                Pair<
                                    <Self as Heaped>::Heap,
                                    IdxBox<
                                        <Self as Heaped>::Heap,
                                        Either<
                                            <Self as Heaped>::Heap,
                                            Pair<
                                                <Self as Heaped>::Heap,
                                                cds::F,
                                                Maybe<
                                                    <Self as Heaped>::Heap,
                                                    ParseMetadata<<Self as Heaped>::Heap>,
                                                >,
                                            >,
                                            ParseError<<Self as Heaped>::Heap>,
                                        >,
                                    >,
                                    Maybe<
                                        <Self as Heaped>::Heap,
                                        ParseMetadata<<Self as Heaped>::Heap>,
                                    >,
                                >,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ),
                > for cds::Nat {
                    fn construct(
                        heap: &mut <Self as Heaped>::Heap,
                        t: (
                            <<Self as Heaped>::Heap as MapsTmf<
                                cttw::L,
                                Either<
                                    <Self as Heaped>::Heap,
                                    Pair<
                                        <Self as Heaped>::Heap,
                                        IdxBox<
                                            <Self as Heaped>::Heap,
                                            Either<
                                                <Self as Heaped>::Heap,
                                                Pair<
                                                    <Self as Heaped>::Heap,
                                                    cds::F,
                                                    Maybe<
                                                        <Self as Heaped>::Heap,
                                                        ParseMetadata<<Self as Heaped>::Heap>,
                                                    >,
                                                >,
                                                ParseError<<Self as Heaped>::Heap>,
                                            >,
                                        >,
                                        Maybe<
                                            <Self as Heaped>::Heap,
                                            ParseMetadata<<Self as Heaped>::Heap>,
                                        >,
                                    >,
                                    ParseError<<Self as Heaped>::Heap>,
                                >,
                            >>::Tmf,
                            (),
                        ),
                    ) -> Self {
                        crate::cst::data_structure::Nat::F(t.0)
                    }
                    fn deconstruct_succeeds(
                        &self,
                        heap: &<Self as Heaped>::Heap,
                    ) -> bool {
                        match self {
                            crate::cst::data_structure::Nat::F(_) => true,
                            _ => false,
                        }
                    }
                    fn deconstruct(
                        self,
                        heap: &<Self as Heaped>::Heap,
                    ) -> (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                Pair<
                                    <Self as Heaped>::Heap,
                                    IdxBox<
                                        <Self as Heaped>::Heap,
                                        Either<
                                            <Self as Heaped>::Heap,
                                            Pair<
                                                <Self as Heaped>::Heap,
                                                cds::F,
                                                Maybe<
                                                    <Self as Heaped>::Heap,
                                                    ParseMetadata<<Self as Heaped>::Heap>,
                                                >,
                                            >,
                                            ParseError<<Self as Heaped>::Heap>,
                                        >,
                                    >,
                                    Maybe<
                                        <Self as Heaped>::Heap,
                                        ParseMetadata<<Self as Heaped>::Heap>,
                                    >,
                                >,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ) {
                        match self {
                            crate::cst::data_structure::Nat::F(t) => (t, ()),
                            _ => panic!("conversion failure"),
                        }
                    }
                }
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
                #[rustfmt::skip]
                impl term::DirectlyCanonicallyConstructibleFrom<
                    <Self as Heaped>::Heap,
                    (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                Pair<
                                    <Self as Heaped>::Heap,
                                    IdxBox<
                                        <Self as Heaped>::Heap,
                                        Either<
                                            <Self as Heaped>::Heap,
                                            Pair<
                                                <Self as Heaped>::Heap,
                                                cds::Plus,
                                                Maybe<
                                                    <Self as Heaped>::Heap,
                                                    ParseMetadata<<Self as Heaped>::Heap>,
                                                >,
                                            >,
                                            ParseError<<Self as Heaped>::Heap>,
                                        >,
                                    >,
                                    Maybe<
                                        <Self as Heaped>::Heap,
                                        ParseMetadata<<Self as Heaped>::Heap>,
                                    >,
                                >,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ),
                > for cds::Nat {
                    fn construct(
                        heap: &mut <Self as Heaped>::Heap,
                        t: (
                            <<Self as Heaped>::Heap as MapsTmf<
                                cttw::L,
                                Either<
                                    <Self as Heaped>::Heap,
                                    Pair<
                                        <Self as Heaped>::Heap,
                                        IdxBox<
                                            <Self as Heaped>::Heap,
                                            Either<
                                                <Self as Heaped>::Heap,
                                                Pair<
                                                    <Self as Heaped>::Heap,
                                                    cds::Plus,
                                                    Maybe<
                                                        <Self as Heaped>::Heap,
                                                        ParseMetadata<<Self as Heaped>::Heap>,
                                                    >,
                                                >,
                                                ParseError<<Self as Heaped>::Heap>,
                                            >,
                                        >,
                                        Maybe<
                                            <Self as Heaped>::Heap,
                                            ParseMetadata<<Self as Heaped>::Heap>,
                                        >,
                                    >,
                                    ParseError<<Self as Heaped>::Heap>,
                                >,
                            >>::Tmf,
                            (),
                        ),
                    ) -> Self {
                        crate::cst::data_structure::Nat::Plus(t.0)
                    }
                    fn deconstruct_succeeds(
                        &self,
                        heap: &<Self as Heaped>::Heap,
                    ) -> bool {
                        match self {
                            crate::cst::data_structure::Nat::Plus(_) => true,
                            _ => false,
                        }
                    }
                    fn deconstruct(
                        self,
                        heap: &<Self as Heaped>::Heap,
                    ) -> (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                Pair<
                                    <Self as Heaped>::Heap,
                                    IdxBox<
                                        <Self as Heaped>::Heap,
                                        Either<
                                            <Self as Heaped>::Heap,
                                            Pair<
                                                <Self as Heaped>::Heap,
                                                cds::Plus,
                                                Maybe<
                                                    <Self as Heaped>::Heap,
                                                    ParseMetadata<<Self as Heaped>::Heap>,
                                                >,
                                            >,
                                            ParseError<<Self as Heaped>::Heap>,
                                        >,
                                    >,
                                    Maybe<
                                        <Self as Heaped>::Heap,
                                        ParseMetadata<<Self as Heaped>::Heap>,
                                    >,
                                >,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ) {
                        match self {
                            crate::cst::data_structure::Nat::Plus(t) => (t, ()),
                            _ => panic!("conversion failure"),
                        }
                    }
                }
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
                #[rustfmt::skip]
                impl term::DirectlyCanonicallyConstructibleFrom<
                    <Self as Heaped>::Heap,
                    (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                Pair<
                                    <Self as Heaped>::Heap,
                                    IdxBox<
                                        <Self as Heaped>::Heap,
                                        Either<
                                            <Self as Heaped>::Heap,
                                            Pair<
                                                <Self as Heaped>::Heap,
                                                cds::Sum,
                                                Maybe<
                                                    <Self as Heaped>::Heap,
                                                    ParseMetadata<<Self as Heaped>::Heap>,
                                                >,
                                            >,
                                            ParseError<<Self as Heaped>::Heap>,
                                        >,
                                    >,
                                    Maybe<
                                        <Self as Heaped>::Heap,
                                        ParseMetadata<<Self as Heaped>::Heap>,
                                    >,
                                >,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ),
                > for cds::Nat {
                    fn construct(
                        heap: &mut <Self as Heaped>::Heap,
                        t: (
                            <<Self as Heaped>::Heap as MapsTmf<
                                cttw::L,
                                Either<
                                    <Self as Heaped>::Heap,
                                    Pair<
                                        <Self as Heaped>::Heap,
                                        IdxBox<
                                            <Self as Heaped>::Heap,
                                            Either<
                                                <Self as Heaped>::Heap,
                                                Pair<
                                                    <Self as Heaped>::Heap,
                                                    cds::Sum,
                                                    Maybe<
                                                        <Self as Heaped>::Heap,
                                                        ParseMetadata<<Self as Heaped>::Heap>,
                                                    >,
                                                >,
                                                ParseError<<Self as Heaped>::Heap>,
                                            >,
                                        >,
                                        Maybe<
                                            <Self as Heaped>::Heap,
                                            ParseMetadata<<Self as Heaped>::Heap>,
                                        >,
                                    >,
                                    ParseError<<Self as Heaped>::Heap>,
                                >,
                            >>::Tmf,
                            (),
                        ),
                    ) -> Self {
                        crate::cst::data_structure::Nat::Sum(t.0)
                    }
                    fn deconstruct_succeeds(
                        &self,
                        heap: &<Self as Heaped>::Heap,
                    ) -> bool {
                        match self {
                            crate::cst::data_structure::Nat::Sum(_) => true,
                            _ => false,
                        }
                    }
                    fn deconstruct(
                        self,
                        heap: &<Self as Heaped>::Heap,
                    ) -> (
                        <<Self as Heaped>::Heap as MapsTmf<
                            cttw::L,
                            Either<
                                <Self as Heaped>::Heap,
                                Pair<
                                    <Self as Heaped>::Heap,
                                    IdxBox<
                                        <Self as Heaped>::Heap,
                                        Either<
                                            <Self as Heaped>::Heap,
                                            Pair<
                                                <Self as Heaped>::Heap,
                                                cds::Sum,
                                                Maybe<
                                                    <Self as Heaped>::Heap,
                                                    ParseMetadata<<Self as Heaped>::Heap>,
                                                >,
                                            >,
                                            ParseError<<Self as Heaped>::Heap>,
                                        >,
                                    >,
                                    Maybe<
                                        <Self as Heaped>::Heap,
                                        ParseMetadata<<Self as Heaped>::Heap>,
                                    >,
                                >,
                                ParseError<<Self as Heaped>::Heap>,
                            >,
                        >>::Tmf,
                        (),
                    ) {
                        match self {
                            crate::cst::data_structure::Nat::Sum(t) => (t, ()),
                            _ => panic!("conversion failure"),
                        }
                    }
                }
            }
        }
        /// generated by [term_specialized_impl_gen::gen_transitive_ccf_mod]
        #[rustfmt::skip]
        pub mod transitive_ccf {
            use tymetafuncspec_core::Maybe;
            use tymetafuncspec_core::Set;
            use std_parse_metadata::ParseMetadata;
            use tymetafuncspec_core::BoundedNat;
            use crate::cst::data_structure as cds;
            use tymetafuncspec_core::IdxBox;
            use std_parse_error::ParseError;
            use tymetafuncspec_core::Either;
            use tymetafuncspec_core::Pair;
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::Nat> for cds::LeftOperand {
                type Intermediary = Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for cds::LeftOperand {
                type Intermediary = Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
            > for cds::LeftOperand {
                type Intermediary = Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        BoundedNat<cds::Heap>,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for cds::LeftOperand {
                type Intermediary = Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Plus,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for cds::LeftOperand {
                type Intermediary = Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::F,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for cds::LeftOperand {
                type Intermediary = Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Sum,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for cds::LeftOperand {
                type Intermediary = Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::Nat> for cds::RightOperand {
                type Intermediary = Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for cds::RightOperand {
                type Intermediary = Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
            > for cds::RightOperand {
                type Intermediary = Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        BoundedNat<cds::Heap>,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for cds::RightOperand {
                type Intermediary = Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Plus,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for cds::RightOperand {
                type Intermediary = Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::F,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for cds::RightOperand {
                type Intermediary = Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Sum,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for cds::RightOperand {
                type Intermediary = Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::Nat> for cds::F {
                type Intermediary = Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>> for cds::F {
                type Intermediary = Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
            > for cds::F {
                type Intermediary = Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        BoundedNat<cds::Heap>,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for cds::F {
                type Intermediary = Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Plus,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for cds::F {
                type Intermediary = Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::F,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for cds::F {
                type Intermediary = Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Sum,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for cds::F {
                type Intermediary = Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Set<cds::Heap, Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>>,
            > for cds::Sum {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        Set<
                            cds::Heap,
                            Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for cds::Sum {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        Set<
                            cds::Heap,
                            Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        Set<
                            cds::Heap,
                            Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for cds::Sum {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        Set<
                            cds::Heap,
                            Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for cds::Sum {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        Set<
                            cds::Heap,
                            Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > for cds::Sum {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        Set<
                            cds::Heap,
                            Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Pair<
                    cds::Heap,
                    Set<cds::Heap, Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
            > for cds::Sum {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        Set<
                            cds::Heap,
                            Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, BoundedNat<cds::Heap>>
            for cds::Nat {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        BoundedNat<cds::Heap>,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Plus,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
            > for cds::Nat {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Plus,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::F,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
            > for cds::Nat {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::F,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Sum,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
            > for cds::Nat {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Sum,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for cds::Nat {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::F,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Plus,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for cds::Nat {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Plus,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                    ParseError<cds::Heap>,
                >,
            > for cds::Nat {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::F,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Sum,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for cds::Nat {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Sum,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        BoundedNat<cds::Heap>,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for cds::Nat {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        BoundedNat<cds::Heap>,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Plus,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for cds::Nat {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Plus,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::F,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for cds::Nat {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::F,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Sum,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for cds::Nat {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Sum,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for cds::Nat {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::F,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > for cds::Nat {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::F,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Pair<
                    cds::Heap,
                    BoundedNat<cds::Heap>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
            > for cds::Nat {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        BoundedNat<cds::Heap>,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Plus,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
            > for cds::Nat {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Plus,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::F,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
            > for cds::Nat {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::F,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Sum,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
            > for cds::Nat {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Sum,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::Plus>
            for IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Plus,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Plus,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Plus,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Plus,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Plus,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            >
            for IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Plus,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Plus,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Plus,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Plus,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >
            for IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Plus,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Plus,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
            >
            for IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Plus,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Plus,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::F>
            for IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                    ParseError<cds::Heap>,
                >,
            > {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                    ParseError<cds::Heap>,
                >,
            > {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
            >
            for IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                    ParseError<cds::Heap>,
                >,
            > {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                    ParseError<cds::Heap>,
                >,
            >
            for IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                    ParseError<cds::Heap>,
                >,
            > {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                    ParseError<cds::Heap>,
                >,
            > {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >
            for IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                    ParseError<cds::Heap>,
                >,
            > {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
            >
            for IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                    ParseError<cds::Heap>,
                >,
            > {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::Sum>
            for IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Sum,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Sum,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Sum,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Sum,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Sum,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            >
            for IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Sum,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Sum,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        Set<
                            cds::Heap,
                            Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            >
            for IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Sum,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Sum,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Sum,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Sum,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >
            for IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Sum,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Sum,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Pair<cds::Heap, cds::Sum, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
            >
            for IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Sum,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > {
                type Intermediary = Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Sum,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::Nat>
            for Either<cds::Heap, cds::Nat, ParseError<cds::Heap>> {
                type Intermediary = cds::Nat;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for Either<cds::Heap, cds::Nat, ParseError<cds::Heap>> {
                type Intermediary = ParseError<cds::Heap>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        BoundedNat<cds::Heap>,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for Either<cds::Heap, cds::Nat, ParseError<cds::Heap>> {
                type Intermediary = cds::Nat;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Plus,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for Either<cds::Heap, cds::Nat, ParseError<cds::Heap>> {
                type Intermediary = cds::Nat;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::F,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for Either<cds::Heap, cds::Nat, ParseError<cds::Heap>> {
                type Intermediary = cds::Nat;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Sum,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for Either<cds::Heap, cds::Nat, ParseError<cds::Heap>> {
                type Intermediary = cds::Nat;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::Plus>
            for Either<
                cds::Heap,
                Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::Plus,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for Either<
                cds::Heap,
                Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                ParseError<cds::Heap>,
            > {
                type Intermediary = ParseError<cds::Heap>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for Either<
                cds::Heap,
                Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::Plus,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >
            for Either<
                cds::Heap,
                Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::Plus,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
            >
            for Either<
                cds::Heap,
                Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::Plus,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::LeftOperand>
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    cds::LeftOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::LeftOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    cds::LeftOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = ParseError<cds::Heap>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    cds::LeftOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::LeftOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    cds::LeftOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::LeftOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    cds::LeftOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::LeftOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Pair<
                    cds::Heap,
                    cds::LeftOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    cds::LeftOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::LeftOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::RightOperand>
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    cds::RightOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::RightOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    cds::RightOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = ParseError<cds::Heap>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    cds::RightOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::RightOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    cds::RightOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::RightOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    cds::RightOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::RightOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Pair<
                    cds::Heap,
                    cds::RightOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    cds::RightOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::RightOperand,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::F>
            for Either<
                cds::Heap,
                Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::F,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for Either<
                cds::Heap,
                Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                ParseError<cds::Heap>,
            > {
                type Intermediary = ParseError<cds::Heap>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
            >
            for Either<
                cds::Heap,
                Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::F,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for Either<
                cds::Heap,
                Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::F,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >
            for Either<
                cds::Heap,
                Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::F,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
            >
            for Either<
                cds::Heap,
                Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::F,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::Sum>
            for Either<
                cds::Heap,
                Pair<cds::Heap, cds::Sum, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::Sum,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for Either<
                cds::Heap,
                Pair<cds::Heap, cds::Sum, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                ParseError<cds::Heap>,
            > {
                type Intermediary = ParseError<cds::Heap>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        Set<
                            cds::Heap,
                            Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            >
            for Either<
                cds::Heap,
                Pair<cds::Heap, cds::Sum, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::Sum,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for Either<
                cds::Heap,
                Pair<cds::Heap, cds::Sum, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::Sum,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >
            for Either<
                cds::Heap,
                Pair<cds::Heap, cds::Sum, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::Sum,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Pair<cds::Heap, cds::Sum, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
            >
            for Either<
                cds::Heap,
                Pair<cds::Heap, cds::Sum, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    cds::Sum,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, BoundedNat<cds::Heap>>
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    BoundedNat<cds::Heap>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    BoundedNat<cds::Heap>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    BoundedNat<cds::Heap>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = ParseError<cds::Heap>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    BoundedNat<cds::Heap>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    BoundedNat<cds::Heap>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    BoundedNat<cds::Heap>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    BoundedNat<cds::Heap>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Pair<
                    cds::Heap,
                    BoundedNat<cds::Heap>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    BoundedNat<cds::Heap>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    BoundedNat<cds::Heap>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Set<cds::Heap, Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>>,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    Set<cds::Heap, Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    Set<cds::Heap, Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    Set<cds::Heap, Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = ParseError<cds::Heap>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    Set<cds::Heap, Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    Set<cds::Heap, Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    Set<cds::Heap, Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    Set<cds::Heap, Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Pair<
                    cds::Heap,
                    Set<cds::Heap, Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    Set<cds::Heap, Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    Set<cds::Heap, Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Plus,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Plus,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Plus,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Plus,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = ParseError<cds::Heap>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Plus,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Plus,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Plus,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Plus,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Plus,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Plus,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Plus,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Plus,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Plus,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Plus,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::F,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::F,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::F,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::F,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = ParseError<cds::Heap>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                    ParseError<cds::Heap>,
                >,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::F,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::F,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::F,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::F,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::F,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::F,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::F,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::F,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::F,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Sum,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Sum,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Sum,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Sum,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = ParseError<cds::Heap>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Sum,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Sum,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Sum,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Sum,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Sum,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Sum,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Sum,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Sum,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
            >
            for Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Sum,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            > {
                type Intermediary = Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Sum,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for Maybe<cds::Heap, ParseMetadata<cds::Heap>> {
                type Intermediary = ParseMetadata<cds::Heap>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::Plus>
            for Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::Plus;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = Maybe<cds::Heap, ParseMetadata<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >
            for Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = Maybe<cds::Heap, ParseMetadata<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::LeftOperand>
            for Pair<
                cds::Heap,
                cds::LeftOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = cds::LeftOperand;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::Nat>
            for Pair<
                cds::Heap,
                cds::LeftOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = cds::LeftOperand;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for Pair<
                cds::Heap,
                cds::LeftOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = cds::LeftOperand;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
            >
            for Pair<
                cds::Heap,
                cds::LeftOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = cds::LeftOperand;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        BoundedNat<cds::Heap>,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            >
            for Pair<
                cds::Heap,
                cds::LeftOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = cds::LeftOperand;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Plus,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            >
            for Pair<
                cds::Heap,
                cds::LeftOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = cds::LeftOperand;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::F,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            >
            for Pair<
                cds::Heap,
                cds::LeftOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = cds::LeftOperand;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Sum,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            >
            for Pair<
                cds::Heap,
                cds::LeftOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = cds::LeftOperand;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for Pair<
                cds::Heap,
                cds::LeftOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = Maybe<cds::Heap, ParseMetadata<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >
            for Pair<
                cds::Heap,
                cds::LeftOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = Maybe<cds::Heap, ParseMetadata<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::RightOperand>
            for Pair<
                cds::Heap,
                cds::RightOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = cds::RightOperand;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::Nat>
            for Pair<
                cds::Heap,
                cds::RightOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = cds::RightOperand;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for Pair<
                cds::Heap,
                cds::RightOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = cds::RightOperand;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
            >
            for Pair<
                cds::Heap,
                cds::RightOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = cds::RightOperand;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        BoundedNat<cds::Heap>,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            >
            for Pair<
                cds::Heap,
                cds::RightOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = cds::RightOperand;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Plus,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            >
            for Pair<
                cds::Heap,
                cds::RightOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = cds::RightOperand;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::F,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            >
            for Pair<
                cds::Heap,
                cds::RightOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = cds::RightOperand;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Sum,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            >
            for Pair<
                cds::Heap,
                cds::RightOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = cds::RightOperand;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for Pair<
                cds::Heap,
                cds::RightOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = Maybe<cds::Heap, ParseMetadata<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >
            for Pair<
                cds::Heap,
                cds::RightOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = Maybe<cds::Heap, ParseMetadata<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::F>
            for Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::F;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::Nat>
            for Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::F;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::F;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
            > for Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::F;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        BoundedNat<cds::Heap>,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::F;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Plus,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::F;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::F,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::F;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        IdxBox<
                            cds::Heap,
                            Either<
                                cds::Heap,
                                Pair<
                                    cds::Heap,
                                    cds::Sum,
                                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                                >,
                                ParseError<cds::Heap>,
                            >,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::F;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = Maybe<cds::Heap, ParseMetadata<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > for Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = Maybe<cds::Heap, ParseMetadata<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::Sum>
            for Pair<cds::Heap, cds::Sum, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::Sum;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Set<cds::Heap, Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>>,
            > for Pair<cds::Heap, cds::Sum, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::Sum;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for Pair<cds::Heap, cds::Sum, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::Sum;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        Set<
                            cds::Heap,
                            Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            > for Pair<cds::Heap, cds::Sum, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::Sum;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for Pair<cds::Heap, cds::Sum, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = Maybe<cds::Heap, ParseMetadata<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > for Pair<cds::Heap, cds::Sum, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = Maybe<cds::Heap, ParseMetadata<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Pair<
                    cds::Heap,
                    Set<cds::Heap, Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
            > for Pair<cds::Heap, cds::Sum, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::Sum;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, BoundedNat<cds::Heap>>
            for Pair<
                cds::Heap,
                BoundedNat<cds::Heap>,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = BoundedNat<cds::Heap>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for Pair<
                cds::Heap,
                BoundedNat<cds::Heap>,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = Maybe<cds::Heap, ParseMetadata<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >
            for Pair<
                cds::Heap,
                BoundedNat<cds::Heap>,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = Maybe<cds::Heap, ParseMetadata<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Set<cds::Heap, Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>>,
            >
            for Pair<
                cds::Heap,
                Set<cds::Heap, Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>>,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = Set<
                    cds::Heap,
                    Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for Pair<
                cds::Heap,
                Set<cds::Heap, Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>>,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = Maybe<cds::Heap, ParseMetadata<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >
            for Pair<
                cds::Heap,
                Set<cds::Heap, Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>>,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = Maybe<cds::Heap, ParseMetadata<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::Plus>
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Plus,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Plus,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Plus,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
            >
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Plus,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Plus,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Plus,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Plus,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Plus,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            >
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Plus,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Plus,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Plus,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = Maybe<cds::Heap, ParseMetadata<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Plus,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = Maybe<cds::Heap, ParseMetadata<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
            >
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Plus,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Plus,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::F>
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::F,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::F,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::F,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
            >
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::F,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::F,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::F,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::F,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
            >
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::F,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::F,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                    ParseError<cds::Heap>,
                >,
            >
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::F,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::F,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::F,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = Maybe<cds::Heap, ParseMetadata<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::F,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = Maybe<cds::Heap, ParseMetadata<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
            >
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::F,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::F,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, cds::Sum>
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Sum,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Sum,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Sum,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
            >
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Sum,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Sum,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseError<cds::Heap>>
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Sum,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Sum,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Sum,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            >
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Sum,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Sum,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        Set<
                            cds::Heap,
                            Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
                        >,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            >
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Sum,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Sum,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<cds::Heap, ParseMetadata<cds::Heap>>
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Sum,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = Maybe<cds::Heap, ParseMetadata<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Sum,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = Maybe<cds::Heap, ParseMetadata<cds::Heap>>;
            }
            /// generated by [term_specialized_impl_gen::tuc_impls]
            #[rustfmt::skip]
            impl term::TransitivelyUnitCcf<
                cds::Heap,
                Pair<cds::Heap, cds::Sum, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
            >
            for Pair<
                cds::Heap,
                IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Sum,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            > {
                type Intermediary = IdxBox<
                    cds::Heap,
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::Sum,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                >;
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (ParseError<cds::Heap>, (ParseError<cds::Heap>, ())),
            > for cds::Plus {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (ParseError<cds::Heap>, (ParseError<cds::Heap>, ())),
            >
            for Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    ParseError<cds::Heap>,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                ),
            > for cds::Plus {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    ParseError<cds::Heap>,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                ),
            >
            for Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    ParseError<cds::Heap>,
                    (
                        Pair<
                            cds::Heap,
                            cds::RightOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        (),
                    ),
                ),
            > for cds::Plus {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    ParseError<cds::Heap>,
                    (
                        Pair<
                            cds::Heap,
                            cds::RightOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        (),
                    ),
                ),
            >
            for Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
                    (Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>, ()),
                ),
            > for cds::Plus {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
                    (Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>, ()),
                ),
            >
            for Either<
                cds::Heap,
                Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                ParseError<cds::Heap>,
            > {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                ),
            > for cds::Plus {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                ),
            >
            for Either<
                cds::Heap,
                Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                ParseError<cds::Heap>,
            > {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (ParseError<cds::Heap>, ()),
                ),
            > for cds::Plus {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (ParseError<cds::Heap>, ()),
                ),
            >
            for Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>, ()),
                ),
            > for cds::Plus {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>, ()),
                ),
            >
            for Either<
                cds::Heap,
                Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                ParseError<cds::Heap>,
            > {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                ),
            > for cds::Plus {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                ),
            >
            for Either<
                cds::Heap,
                Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                ParseError<cds::Heap>,
            > {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                ),
            >
            for Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Pair<
                            cds::Heap,
                            cds::RightOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        (),
                    ),
                ),
            > for cds::Plus {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Pair<
                            cds::Heap,
                            cds::RightOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        (),
                    ),
                ),
            >
            for Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    Pair<
                        cds::Heap,
                        cds::LeftOperand,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    (ParseError<cds::Heap>, ()),
                ),
            > for cds::Plus {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    Pair<
                        cds::Heap,
                        cds::LeftOperand,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    (ParseError<cds::Heap>, ()),
                ),
            >
            for Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    Pair<
                        cds::Heap,
                        cds::LeftOperand,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                ),
            > for cds::Plus {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    Pair<
                        cds::Heap,
                        cds::LeftOperand,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                ),
            >
            for Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    Pair<
                        cds::Heap,
                        cds::LeftOperand,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    (
                        Pair<
                            cds::Heap,
                            cds::RightOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        (),
                    ),
                ),
            > for cds::Plus {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
            /// generated by [term_specialized_impl_gen::tac_impls]
            #[rustfmt::skip]
            impl term::TransitivelyAllCcf<
                cds::Heap,
                (
                    Pair<
                        cds::Heap,
                        cds::LeftOperand,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    (
                        Pair<
                            cds::Heap,
                            cds::RightOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        (),
                    ),
                ),
            >
            for Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>> {
                type Intermediary = cds::Plus;
                type Intermediaries = (
                    Either<
                        cds::Heap,
                        Pair<
                            cds::Heap,
                            cds::LeftOperand,
                            Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                        >,
                        ParseError<cds::Heap>,
                    >,
                    (
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::RightOperand,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                        (),
                    ),
                );
            }
        }
        /// generated by [term_specialized_impl_gen::gen_ccf_auto_impls]
        #[rustfmt::skip]
        pub mod ccf_auto_impls {
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, crate ::cst::data_structure::F
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, crate ::cst::data_structure::Plus
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, crate
                ::cst::data_structure::LeftOperand
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, crate
                ::cst::data_structure::RightOperand
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, crate ::cst::data_structure::Sum
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, crate ::cst::data_structure::Nat
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Nat,
                std_parse_error::ParseError < crate ::cst::data_structure::Heap, >, >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, std_parse_error::ParseError < crate
                ::cst::data_structure::Heap, >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::LeftOperand,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::LeftOperand,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Maybe < crate
                ::cst::data_structure::Heap, std_parse_metadata::ParseMetadata < crate
                ::cst::data_structure::Heap, >, >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, std_parse_metadata::ParseMetadata <
                crate ::cst::data_structure::Heap, >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::RightOperand,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::RightOperand,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Set < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Nat,
                std_parse_error::ParseError < crate ::cst::data_structure::Heap, >, >, >,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Set < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Nat,
                std_parse_error::ParseError < crate ::cst::data_structure::Heap, >, >, >,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Set < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Nat,
                std_parse_error::ParseError < crate ::cst::data_structure::Heap, >, >, >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::BoundedNat < crate
                ::cst::data_structure::Heap, >, tymetafuncspec_core::Maybe < crate
                ::cst::data_structure::Heap, std_parse_metadata::ParseMetadata < crate
                ::cst::data_structure::Heap, >, >, >, std_parse_error::ParseError < crate
                ::cst::data_structure::Heap, >, >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::BoundedNat < crate
                ::cst::data_structure::Heap, >, tymetafuncspec_core::Maybe < crate
                ::cst::data_structure::Heap, std_parse_metadata::ParseMetadata < crate
                ::cst::data_structure::Heap, >, >, >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::BoundedNat <
                crate ::cst::data_structure::Heap, >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::F,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >, >, tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::F,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >, >, tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::F,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >, >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::F,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::F,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Plus,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >, >, tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Plus,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >, >, tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Plus,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >, >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Plus,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Plus,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Sum,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >, >, tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Sum,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >, >, tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Sum,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >, >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Sum,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >,
                >
            );
            term::auto_impl_ccf!(
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Sum,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >
            );
        }
        /// generated by [term_specialized_impl_gen::gen_maps_tmf]
        #[rustfmt::skip]
        pub mod maps_tmf_impls {
            use term::CanonicallyConstructibleFrom;
            use crate::cst::data_structure as cds;
            use crate::cst::term_trait::words as cttw;
            impl<TmfMonomorphization> term::MapsTmf<cttw::L, TmfMonomorphization>
            for cds::Heap
            where
                TmfMonomorphization: CanonicallyConstructibleFrom<
                    Self,
                    (TmfMonomorphization, ()),
                >,
            {
                type Tmf = TmfMonomorphization;
            }
        }
    }
}
pub mod bridge {
    use crate::cst::data_structure as cds;
    use std_parse_error::ParseError;
    use std_parse_metadata::ParseMetadata;
    use tymetafuncspec_core::Either;
    use tymetafuncspec_core::Maybe;
    use tymetafuncspec_core::Pair;
    /// generated by [parse_gen::bridge_words_impls]
    #[rustfmt::skip]
    pub mod words_impls {
        use crate::term_trait::words::sorts as ttws;
        use parse_adt::cstfy::Cstfy;
        use crate::cst::data_structure as cds;
        use parse_adt::cstfy::CstfyTransparent;
        use crate::term_trait::words as ttw;
        impl words::Implements<ttw::L> for Cstfy<cds::Heap, cds::F> {
            type LWord = ttws::F;
        }
        impl words::Implements<ttw::L> for Cstfy<cds::Heap, cds::Plus> {
            type LWord = ttws::Plus;
        }
        impl words::Implements<ttw::L> for Cstfy<cds::Heap, cds::LeftOperand> {
            type LWord = ttws::LeftOperand;
        }
        impl words::Implements<ttw::L> for Cstfy<cds::Heap, cds::RightOperand> {
            type LWord = ttws::RightOperand;
        }
        impl words::Implements<ttw::L> for Cstfy<cds::Heap, cds::Sum> {
            type LWord = ttws::Sum;
        }
        impl words::Implements<ttw::L> for CstfyTransparent<cds::Heap, cds::Nat> {
            type LWord = ttws::Nat;
        }
    }
    /// generated by [term_bridge_gen::generate_heap]
    #[rustfmt::skip]
    impl crate::term_trait::Heap for cds::Heap {
        type F = Either<
            cds::Heap,
            Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
            ParseError<cds::Heap>,
        >;
        type Plus = Either<
            cds::Heap,
            Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
            ParseError<cds::Heap>,
        >;
        type LeftOperand = Either<
            cds::Heap,
            Pair<
                cds::Heap,
                cds::LeftOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >,
            ParseError<cds::Heap>,
        >;
        type RightOperand = Either<
            cds::Heap,
            Pair<
                cds::Heap,
                cds::RightOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >,
            ParseError<cds::Heap>,
        >;
        type Sum = Either<
            cds::Heap,
            Pair<cds::Heap, cds::Sum, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
            ParseError<cds::Heap>,
        >;
        type Nat = Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>;
    }
    /// generated by [term_bridge_gen::generate_owned_impls]
    #[rustfmt::skip]
    pub mod owned_impls {
        use std_parse_metadata::ParseMetadata;
        use std_parse_error::ParseError;
        use tymetafuncspec_core::Either;
        use tymetafuncspec_core::Pair;
        use tymetafuncspec_core::Maybe;
        use crate::cst::data_structure as cds;
        impl crate::term_trait::owned::F
        for Either<
            cds::Heap,
            Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
            ParseError<cds::Heap>,
        > {}
        impl crate::term_trait::owned::Plus
        for Either<
            cds::Heap,
            Pair<cds::Heap, cds::Plus, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
            ParseError<cds::Heap>,
        > {}
        impl crate::term_trait::owned::LeftOperand
        for Either<
            cds::Heap,
            Pair<
                cds::Heap,
                cds::LeftOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >,
            ParseError<cds::Heap>,
        > {}
        impl crate::term_trait::owned::RightOperand
        for Either<
            cds::Heap,
            Pair<
                cds::Heap,
                cds::RightOperand,
                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
            >,
            ParseError<cds::Heap>,
        > {}
        impl crate::term_trait::owned::Sum
        for Either<
            cds::Heap,
            Pair<cds::Heap, cds::Sum, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
            ParseError<cds::Heap>,
        > {}
        impl crate::term_trait::owned::Nat
        for Either<cds::Heap, cds::Nat, ParseError<cds::Heap>> {}
    }
    /// generated by [term_bridge_gen::generate_maps_tmf_impls]
    #[rustfmt::skip]
    pub mod maps_tmf_impls {
        use tymetafuncspec_core::Maybe;
        use tymetafuncspec_core::Either;
        use crate::cst::data_structure as cds;
        use tymetafuncspec_core::Set;
        use std_parse_metadata::ParseMetadata;
        use tymetafuncspec_core::Pair;
        use tymetafuncspec_core::IdxBox;
        use std_parse_error::ParseError;
        use tymetafuncspec_core::BoundedNat;
        use crate::term_trait::words as ttw;
        impl term::MapsTmf<
            ttw::L,
            Set<cds::Heap, Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>>,
        > for cds::Heap {
            type Tmf = Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    Set<cds::Heap, Either<cds::Heap, cds::Nat, ParseError<cds::Heap>>>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            >;
        }
        impl term::MapsTmf<ttw::L, BoundedNat<cds::Heap>> for cds::Heap {
            type Tmf = Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    BoundedNat<cds::Heap>,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            >;
        }
        impl term::MapsTmf<
            ttw::L,
            IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<cds::Heap, cds::F, Maybe<cds::Heap, ParseMetadata<cds::Heap>>>,
                    ParseError<cds::Heap>,
                >,
            >,
        > for cds::Heap {
            type Tmf = Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::F,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            >;
        }
        impl term::MapsTmf<
            ttw::L,
            IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Plus,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            >,
        > for cds::Heap {
            type Tmf = Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Plus,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            >;
        }
        impl term::MapsTmf<
            ttw::L,
            IdxBox<
                cds::Heap,
                Either<
                    cds::Heap,
                    Pair<
                        cds::Heap,
                        cds::Sum,
                        Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                    >,
                    ParseError<cds::Heap>,
                >,
            >,
        > for cds::Heap {
            type Tmf = Either<
                cds::Heap,
                Pair<
                    cds::Heap,
                    IdxBox<
                        cds::Heap,
                        Either<
                            cds::Heap,
                            Pair<
                                cds::Heap,
                                cds::Sum,
                                Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                            >,
                            ParseError<cds::Heap>,
                        >,
                    >,
                    Maybe<cds::Heap, ParseMetadata<cds::Heap>>,
                >,
                ParseError<cds::Heap>,
            >;
        }
    }
}
/// generated by [term_specialized_gen::generate]
#[rustfmt::skip]
pub mod data_structure {
    use crate::data_structure::heap::nat_lit as dshnl;
    use crate::data_structure::heap::idx_box as dshib;
    use tymetafuncspec_core::Set;
    use tymetafuncspec_core::IdxBox;
    use tymetafuncspec_core::BoundedNat;
    use crate::data_structure::heap::set as dshs;
    use crate::data_structure as ds;
    /// generated by [term_specialized_gen::gen_heap]
    #[rustfmt::skip]
    #[derive(Default)]
    pub struct Heap {
        set: dshs::Bak,
        nat_lit: dshnl::Bak,
        idx_box: dshib::Bak,
    }
    /// generated by [term_specialized_gen::gen_heap]
    #[rustfmt::skip]
    pub mod heap {
        use crate::data_structure::heap::idx_box as dshib;
        use crate::data_structure::heap::set as dshs;
        use crate::data_structure::heap::nat_lit as dshnl;
        /// generated by [term_specialized_gen::gen_modules_with_prefix]
        #[rustfmt::skip]
        #[derive(Default)]
        pub struct Bak {
            pub set: dshs::Bak,
            pub nat_lit: dshnl::Bak,
            pub idx_box: dshib::Bak,
        }
        /// generated by [term_specialized_gen::gen_modules_with_prefix]
        #[rustfmt::skip]
        pub mod set {
            use crate::data_structure::heap::set::nat as dshsn;
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[rustfmt::skip]
            #[derive(Default)]
            pub struct Bak {
                pub nat: dshsn::Bak,
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[rustfmt::skip]
            pub mod nat {
                use tymetafuncspec_core::SetHeapBak;
                use crate::data_structure as ds;
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[rustfmt::skip]
                #[derive(Default)]
                pub struct Bak(pub SetHeapBak<ds::Heap, ds::Nat>);
            }
        }
        /// generated by [term_specialized_gen::gen_modules_with_prefix]
        #[rustfmt::skip]
        pub mod nat_lit {
            use crate::data_structure as ds;
            use tymetafuncspec_core::BoundedNatHeapBak;
            /// generated by [term_specialized_gen::gen_heapbak_module]
            #[rustfmt::skip]
            #[derive(Default)]
            pub struct Bak(pub BoundedNatHeapBak<ds::Heap>);
        }
        /// generated by [term_specialized_gen::gen_modules_with_prefix]
        #[rustfmt::skip]
        pub mod idx_box {
            use crate::data_structure::heap::idx_box::plus as dshibp;
            use crate::data_structure::heap::idx_box::f as dshibf;
            use crate::data_structure::heap::idx_box::sum as dshibs;
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[rustfmt::skip]
            #[derive(Default)]
            pub struct Bak {
                pub f: dshibf::Bak,
                pub plus: dshibp::Bak,
                pub sum: dshibs::Bak,
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[rustfmt::skip]
            pub mod f {
                use tymetafuncspec_core::IdxBoxHeapBak;
                use crate::data_structure as ds;
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[rustfmt::skip]
                #[derive(Default)]
                pub struct Bak(pub IdxBoxHeapBak<ds::Heap, ds::F>);
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[rustfmt::skip]
            pub mod plus {
                use crate::data_structure as ds;
                use tymetafuncspec_core::IdxBoxHeapBak;
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[rustfmt::skip]
                #[derive(Default)]
                pub struct Bak(pub IdxBoxHeapBak<ds::Heap, ds::Plus>);
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[rustfmt::skip]
            pub mod sum {
                use tymetafuncspec_core::IdxBoxHeapBak;
                use crate::data_structure as ds;
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[rustfmt::skip]
                #[derive(Default)]
                pub struct Bak(pub IdxBoxHeapBak<ds::Heap, ds::Sum>);
            }
        }
    }
    /// generated by [term_specialized_gen::gen_heap]
    #[rustfmt::skip]
    pub mod superheap {
        term::impl_superheap!(
            crate ::data_structure::Heap; tymetafuncspec_core::SetHeapBak < crate
            ::data_structure::Heap, crate ::data_structure::Nat >; set nat
        );
        term::impl_superheap!(
            crate ::data_structure::Heap; tymetafuncspec_core::BoundedNatHeapBak < crate
            ::data_structure::Heap, >; nat_lit
        );
        term::impl_superheap!(
            crate ::data_structure::Heap; tymetafuncspec_core::IdxBoxHeapBak < crate
            ::data_structure::Heap, crate ::data_structure::F >; idx_box f
        );
        term::impl_superheap!(
            crate ::data_structure::Heap; tymetafuncspec_core::IdxBoxHeapBak < crate
            ::data_structure::Heap, crate ::data_structure::Plus >; idx_box plus
        );
        term::impl_superheap!(
            crate ::data_structure::Heap; tymetafuncspec_core::IdxBoxHeapBak < crate
            ::data_structure::Heap, crate ::data_structure::Sum >; idx_box sum
        );
    }
    #[derive(Clone, Copy)]
    pub struct F {
        pub nat: ds::Nat,
    }
    #[derive(Clone, Copy)]
    pub struct Plus {
        pub left_operand: ds::LeftOperand,
        pub right_operand: ds::RightOperand,
    }
    #[derive(Clone, Copy)]
    pub struct LeftOperand {
        pub nat: ds::Nat,
    }
    #[derive(Clone, Copy)]
    pub struct RightOperand {
        pub nat: ds::Nat,
    }
    #[derive(Clone, Copy)]
    pub struct Sum {
        pub set: Set<ds::Heap, ds::Nat>,
    }
    #[derive(Clone, Copy)]
    pub enum Nat {
        NatLit(BoundedNat<ds::Heap>),
        F(IdxBox<ds::Heap, ds::F>),
        Plus(IdxBox<ds::Heap, ds::Plus>),
        Sum(IdxBox<ds::Heap, ds::Sum>),
    }
    /// generated by [term_specialized_gen::gen_heaped_impls]
    #[rustfmt::skip]
    pub mod heaped {
        use crate::data_structure as ds;
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        #[rustfmt::skip]
        impl term::Heaped for ds::F {
            type Heap = ds::Heap;
        }
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        #[rustfmt::skip]
        impl term::Heaped for ds::Plus {
            type Heap = ds::Heap;
        }
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        #[rustfmt::skip]
        impl term::Heaped for ds::LeftOperand {
            type Heap = ds::Heap;
        }
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        #[rustfmt::skip]
        impl term::Heaped for ds::RightOperand {
            type Heap = ds::Heap;
        }
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        #[rustfmt::skip]
        impl term::Heaped for ds::Sum {
            type Heap = ds::Heap;
        }
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        #[rustfmt::skip]
        impl term::Heaped for ds::Nat {
            type Heap = ds::Heap;
        }
    }
}
/// generated by [term_trait_gen::generate]
#[rustfmt::skip]
pub mod term_trait {
    use crate::term_trait::owned as tto;
    use crate::term_trait::words as ttw;
    use tymetafuncspec_core::SetHeapBak;
    use tymetafuncspec_core::BoundedNat;
    use tymetafuncspec_core::IdxBox;
    use tymetafuncspec_core::BoundedNatHeapBak;
    use tymetafuncspec_core::IdxBoxHeapBak;
    use tymetafuncspec_core::Set;
    use term::MapsTmf;
    use term::SuperHeap;
    /// generated by [term_trait_gen::heap_trait]
    #[rustfmt::skip]
    pub trait Heap: Sized + MapsTmf<
            ttw::L,
            Set<Self, Self::Nat>,
        > + MapsTmf<
            ttw::L,
            BoundedNat<Self>,
        > + MapsTmf<
            ttw::L,
            IdxBox<Self, Self::F>,
        > + MapsTmf<
            ttw::L,
            IdxBox<Self, Self::Plus>,
        > + MapsTmf<
            ttw::L,
            IdxBox<Self, Self::Sum>,
        > + SuperHeap<
            SetHeapBak<Self, Self::Nat>,
        > + SuperHeap<
            BoundedNatHeapBak<Self>,
        > + SuperHeap<
            IdxBoxHeapBak<Self, Self::F>,
        > + SuperHeap<
            IdxBoxHeapBak<Self, Self::Plus>,
        > + SuperHeap<IdxBoxHeapBak<Self, Self::Sum>> {
        type F: tto::F<Heap = Self>;
        type Plus: tto::Plus<Heap = Self>;
        type LeftOperand: tto::LeftOperand<Heap = Self>;
        type RightOperand: tto::RightOperand<Heap = Self>;
        type Sum: tto::Sum<Heap = Self>;
        type Nat: tto::Nat<Heap = Self>;
    }
    /// generated by [term_trait_gen::owned::generate]
    #[rustfmt::skip]
    pub mod owned {
        use crate::term_trait as tt;
        use tymetafuncspec_core::IdxBox;
        use tymetafuncspec_core::BoundedNat;
        use term::MapsTmf;
        use term::CanonicallyConstructibleFrom;
        use tymetafuncspec_core::Set;
        use crate::term_trait::words as ttw;
        use term::Heaped;
        pub trait F: Heaped + CanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (<<Self as Heaped>::Heap as tt::Heap>::Nat, ()),
            >
        where
            <Self as Heaped>::Heap: tt::Heap,
        {}
        pub trait Plus: Heaped + CanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (
                    <<Self as Heaped>::Heap as tt::Heap>::LeftOperand,
                    (<<Self as Heaped>::Heap as tt::Heap>::RightOperand, ()),
                ),
            >
        where
            <Self as Heaped>::Heap: tt::Heap,
        {}
        pub trait LeftOperand: Heaped + CanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (<<Self as Heaped>::Heap as tt::Heap>::Nat, ()),
            >
        where
            <Self as Heaped>::Heap: tt::Heap,
        {}
        pub trait RightOperand: Heaped + CanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (<<Self as Heaped>::Heap as tt::Heap>::Nat, ()),
            >
        where
            <Self as Heaped>::Heap: tt::Heap,
        {}
        pub trait Sum: Heaped + CanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        Set<
                            <Self as Heaped>::Heap,
                            <<Self as Heaped>::Heap as tt::Heap>::Nat,
                        >,
                    >>::Tmf,
                    (),
                ),
            >
        where
            <Self as Heaped>::Heap: tt::Heap,
        {}
        pub trait Nat: Heaped + CanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        BoundedNat<<Self as Heaped>::Heap>,
                    >>::Tmf,
                    (),
                ),
            > + CanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        IdxBox<
                            <Self as Heaped>::Heap,
                            <<Self as Heaped>::Heap as tt::Heap>::F,
                        >,
                    >>::Tmf,
                    (),
                ),
            > + CanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        IdxBox<
                            <Self as Heaped>::Heap,
                            <<Self as Heaped>::Heap as tt::Heap>::Plus,
                        >,
                    >>::Tmf,
                    (),
                ),
            > + CanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        IdxBox<
                            <Self as Heaped>::Heap,
                            <<Self as Heaped>::Heap as tt::Heap>::Sum,
                        >,
                    >>::Tmf,
                    (),
                ),
            >
        where
            <Self as Heaped>::Heap: tt::Heap,
        {}
    }
    /// generated by [words::words_mod]
    #[rustfmt::skip]
    pub mod words {
        pub struct L;
        pub mod sorts {
            pub struct F;
            pub struct Plus;
            pub struct LeftOperand;
            pub struct RightOperand;
            pub struct Sum;
            pub struct Nat;
        }
    }
}
/// generated by [term_pattern_match_strategy_provider_impl_gen::generate]
#[rustfmt::skip]
pub mod pattern_match_strategy {
    use term::MapsTmf;
    use crate::pattern_match_strategy as pms;
    use tymetafuncspec_core::BoundedNat;
    use std::marker::PhantomData;
    use crate::term_trait::words as ttw;
    use crate::term_trait as tt;
    use tymetafuncspec_core::IdxBox;
    use words::Implements;
    use crate::data_structure as ds;
    use tymetafuncspec_core::Set;
    use term::case_split::HasPatternMatchStrategyFor;
    use crate::term_trait::words::sorts as ttws;
    impl<Heap: tt::Heap, T> term::case_split::HasPatternMatchStrategyFor<T>
    for PatternMatchStrategyProvider<Heap>
    where
        T: Implements<ttw::L>,
        PatternMatchStrategyProvider<Heap>: HasPatternMatchStrategyFor<T::LWord>,
    {
        type Strategy = <PatternMatchStrategyProvider<
            Heap,
        > as HasPatternMatchStrategyFor<T::LWord>>::Strategy;
    }
    pub struct PatternMatchStrategyProvider<Heap>(PhantomData<Heap>);
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
    #[rustfmt::skip]
    impl<Heap: tt::Heap> term::case_split::HasPatternMatchStrategyFor<ttws::F>
    for PatternMatchStrategyProvider<Heap> {
        type Strategy = ((Heap::Nat, ()), ());
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
    #[rustfmt::skip]
    impl<Heap: tt::Heap> term::case_split::HasPatternMatchStrategyFor<ttws::Plus>
    for PatternMatchStrategyProvider<Heap> {
        type Strategy = ((Heap::LeftOperand, (Heap::RightOperand, ())), ());
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
    #[rustfmt::skip]
    impl<Heap: tt::Heap> term::case_split::HasPatternMatchStrategyFor<ttws::LeftOperand>
    for PatternMatchStrategyProvider<Heap> {
        type Strategy = ((Heap::Nat, ()), ());
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
    #[rustfmt::skip]
    impl<Heap: tt::Heap> term::case_split::HasPatternMatchStrategyFor<ttws::RightOperand>
    for PatternMatchStrategyProvider<Heap> {
        type Strategy = ((Heap::Nat, ()), ());
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
    #[rustfmt::skip]
    impl<Heap: tt::Heap> term::case_split::HasPatternMatchStrategyFor<ttws::Sum>
    for PatternMatchStrategyProvider<Heap> {
        type Strategy = ((<Heap as MapsTmf<ttw::L, Set<Heap, Heap::Nat>>>::Tmf, ()), ());
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
    #[rustfmt::skip]
    impl<Heap: tt::Heap> term::case_split::HasPatternMatchStrategyFor<ttws::Nat>
    for PatternMatchStrategyProvider<Heap> {
        type Strategy = (
            (<Heap as MapsTmf<ttw::L, BoundedNat<Heap>>>::Tmf, ()),
            (
                (<Heap as MapsTmf<ttw::L, IdxBox<Heap, Heap::F>>>::Tmf, ()),
                (
                    (<Heap as MapsTmf<ttw::L, IdxBox<Heap, Heap::Plus>>>::Tmf, ()),
                    ((<Heap as MapsTmf<ttw::L, IdxBox<Heap, Heap::Sum>>>::Tmf, ()), ()),
                ),
            ),
        );
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
    #[rustfmt::skip]
    impl term::case_split::Adt for ds::F {
        type PatternMatchStrategyProvider = pms::PatternMatchStrategyProvider<ds::Heap>;
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
    #[rustfmt::skip]
    impl term::case_split::Adt for ds::Plus {
        type PatternMatchStrategyProvider = pms::PatternMatchStrategyProvider<ds::Heap>;
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
    #[rustfmt::skip]
    impl term::case_split::Adt for ds::LeftOperand {
        type PatternMatchStrategyProvider = pms::PatternMatchStrategyProvider<ds::Heap>;
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
    #[rustfmt::skip]
    impl term::case_split::Adt for ds::RightOperand {
        type PatternMatchStrategyProvider = pms::PatternMatchStrategyProvider<ds::Heap>;
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
    #[rustfmt::skip]
    impl term::case_split::Adt for ds::Sum {
        type PatternMatchStrategyProvider = pms::PatternMatchStrategyProvider<ds::Heap>;
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
    #[rustfmt::skip]
    impl term::case_split::Adt for ds::Nat {
        type PatternMatchStrategyProvider = pms::PatternMatchStrategyProvider<ds::Heap>;
    }
}
/// generated by [words::words_impls]
#[rustfmt::skip]
pub mod words_impls {
    use crate::term_trait::words::sorts as ttws;
    use crate::data_structure as ds;
    use crate::term_trait::words as ttw;
    impl words::Implements<ttw::L> for ds::F {
        type LWord = ttws::F;
    }
    impl words::Implements<ttw::L> for ds::Plus {
        type LWord = ttws::Plus;
    }
    impl words::Implements<ttw::L> for ds::LeftOperand {
        type LWord = ttws::LeftOperand;
    }
    impl words::Implements<ttw::L> for ds::RightOperand {
        type LWord = ttws::RightOperand;
    }
    impl words::Implements<ttw::L> for ds::Sum {
        type LWord = ttws::Sum;
    }
    impl words::Implements<ttw::L> for ds::Nat {
        type LWord = ttws::Nat;
    }
}
/// generated by [term_specialized_impl_gen::generate]
#[rustfmt::skip]
pub mod term_impls {
    use crate::data_structure as ds;
    /// generated by [term_specialized_impl_gen::gen_heap_impl]
    #[rustfmt::skip]
    impl crate::term_trait::Heap for ds::Heap {
        type F = ds::F;
        type Plus = ds::Plus;
        type LeftOperand = ds::LeftOperand;
        type RightOperand = ds::RightOperand;
        type Sum = ds::Sum;
        type Nat = ds::Nat;
    }
    /// generated by [term_specialized_impl_gen::gen_owned_mod]
    #[rustfmt::skip]
    pub mod owned_impls {
        use crate::data_structure as ds;
        impl crate::term_trait::owned::F for ds::F {}
        impl crate::term_trait::owned::Plus for ds::Plus {}
        impl crate::term_trait::owned::LeftOperand for ds::LeftOperand {}
        impl crate::term_trait::owned::RightOperand for ds::RightOperand {}
        impl crate::term_trait::owned::Sum for ds::Sum {}
        impl crate::term_trait::owned::Nat for ds::Nat {}
    }
    /// generated by [term_specialized_impl_gen::gen_ccf_mod]
    #[rustfmt::skip]
    pub mod ccf_impls {
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        #[rustfmt::skip]
        pub mod f {
            use crate::data_structure as ds;
            use term::Heaped;
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
            #[rustfmt::skip]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (ds::Nat, ()),
            > for ds::F {
                fn construct(
                    heap: &mut <Self as Heaped>::Heap,
                    t: (ds::Nat, ()),
                ) -> Self {
                    crate::data_structure::F {
                        nat: t.0,
                    }
                }
                fn deconstruct_succeeds(&self, heap: &<Self as Heaped>::Heap) -> bool {
                    true
                }
                fn deconstruct(self, heap: &<Self as Heaped>::Heap) -> (ds::Nat, ()) {
                    (self.nat, ())
                }
            }
        }
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        #[rustfmt::skip]
        pub mod plus {
            use crate::data_structure as ds;
            use term::Heaped;
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
            #[rustfmt::skip]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (ds::LeftOperand, (ds::RightOperand, ())),
            > for ds::Plus {
                fn construct(
                    heap: &mut <Self as Heaped>::Heap,
                    t: (ds::LeftOperand, (ds::RightOperand, ())),
                ) -> Self {
                    crate::data_structure::Plus {
                        left_operand: t.0,
                        right_operand: t.1.0,
                    }
                }
                fn deconstruct_succeeds(&self, heap: &<Self as Heaped>::Heap) -> bool {
                    true
                }
                fn deconstruct(
                    self,
                    heap: &<Self as Heaped>::Heap,
                ) -> (ds::LeftOperand, (ds::RightOperand, ())) {
                    (self.left_operand, (self.right_operand, ()))
                }
            }
        }
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        #[rustfmt::skip]
        pub mod left_operand {
            use term::Heaped;
            use crate::data_structure as ds;
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
            #[rustfmt::skip]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (ds::Nat, ()),
            > for ds::LeftOperand {
                fn construct(
                    heap: &mut <Self as Heaped>::Heap,
                    t: (ds::Nat, ()),
                ) -> Self {
                    crate::data_structure::LeftOperand {
                        nat: t.0,
                    }
                }
                fn deconstruct_succeeds(&self, heap: &<Self as Heaped>::Heap) -> bool {
                    true
                }
                fn deconstruct(self, heap: &<Self as Heaped>::Heap) -> (ds::Nat, ()) {
                    (self.nat, ())
                }
            }
        }
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        #[rustfmt::skip]
        pub mod right_operand {
            use crate::data_structure as ds;
            use term::Heaped;
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
            #[rustfmt::skip]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (ds::Nat, ()),
            > for ds::RightOperand {
                fn construct(
                    heap: &mut <Self as Heaped>::Heap,
                    t: (ds::Nat, ()),
                ) -> Self {
                    crate::data_structure::RightOperand {
                        nat: t.0,
                    }
                }
                fn deconstruct_succeeds(&self, heap: &<Self as Heaped>::Heap) -> bool {
                    true
                }
                fn deconstruct(self, heap: &<Self as Heaped>::Heap) -> (ds::Nat, ()) {
                    (self.nat, ())
                }
            }
        }
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        #[rustfmt::skip]
        pub mod sum {
            use tymetafuncspec_core::Set;
            use term::MapsTmf;
            use term::Heaped;
            use crate::data_structure as ds;
            use crate::term_trait::words as ttw;
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
            #[rustfmt::skip]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        Set<<Self as Heaped>::Heap, ds::Nat>,
                    >>::Tmf,
                    (),
                ),
            > for ds::Sum {
                fn construct(
                    heap: &mut <Self as Heaped>::Heap,
                    t: (
                        <<Self as Heaped>::Heap as MapsTmf<
                            ttw::L,
                            Set<<Self as Heaped>::Heap, ds::Nat>,
                        >>::Tmf,
                        (),
                    ),
                ) -> Self {
                    crate::data_structure::Sum {
                        set: t.0,
                    }
                }
                fn deconstruct_succeeds(&self, heap: &<Self as Heaped>::Heap) -> bool {
                    true
                }
                fn deconstruct(
                    self,
                    heap: &<Self as Heaped>::Heap,
                ) -> (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        Set<<Self as Heaped>::Heap, ds::Nat>,
                    >>::Tmf,
                    (),
                ) {
                    (self.set, ())
                }
            }
        }
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        #[rustfmt::skip]
        pub mod nat {
            use tymetafuncspec_core::BoundedNat;
            use term::MapsTmf;
            use term::Heaped;
            use crate::term_trait::words as ttw;
            use tymetafuncspec_core::IdxBox;
            use crate::data_structure as ds;
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
            #[rustfmt::skip]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        BoundedNat<<Self as Heaped>::Heap>,
                    >>::Tmf,
                    (),
                ),
            > for ds::Nat {
                fn construct(
                    heap: &mut <Self as Heaped>::Heap,
                    t: (
                        <<Self as Heaped>::Heap as MapsTmf<
                            ttw::L,
                            BoundedNat<<Self as Heaped>::Heap>,
                        >>::Tmf,
                        (),
                    ),
                ) -> Self {
                    crate::data_structure::Nat::NatLit(t.0)
                }
                fn deconstruct_succeeds(&self, heap: &<Self as Heaped>::Heap) -> bool {
                    match self {
                        crate::data_structure::Nat::NatLit(_) => true,
                        _ => false,
                    }
                }
                fn deconstruct(
                    self,
                    heap: &<Self as Heaped>::Heap,
                ) -> (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        BoundedNat<<Self as Heaped>::Heap>,
                    >>::Tmf,
                    (),
                ) {
                    match self {
                        crate::data_structure::Nat::NatLit(t) => (t, ()),
                        _ => panic!("conversion failure"),
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
            #[rustfmt::skip]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        IdxBox<<Self as Heaped>::Heap, ds::F>,
                    >>::Tmf,
                    (),
                ),
            > for ds::Nat {
                fn construct(
                    heap: &mut <Self as Heaped>::Heap,
                    t: (
                        <<Self as Heaped>::Heap as MapsTmf<
                            ttw::L,
                            IdxBox<<Self as Heaped>::Heap, ds::F>,
                        >>::Tmf,
                        (),
                    ),
                ) -> Self {
                    crate::data_structure::Nat::F(t.0)
                }
                fn deconstruct_succeeds(&self, heap: &<Self as Heaped>::Heap) -> bool {
                    match self {
                        crate::data_structure::Nat::F(_) => true,
                        _ => false,
                    }
                }
                fn deconstruct(
                    self,
                    heap: &<Self as Heaped>::Heap,
                ) -> (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        IdxBox<<Self as Heaped>::Heap, ds::F>,
                    >>::Tmf,
                    (),
                ) {
                    match self {
                        crate::data_structure::Nat::F(t) => (t, ()),
                        _ => panic!("conversion failure"),
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
            #[rustfmt::skip]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        IdxBox<<Self as Heaped>::Heap, ds::Plus>,
                    >>::Tmf,
                    (),
                ),
            > for ds::Nat {
                fn construct(
                    heap: &mut <Self as Heaped>::Heap,
                    t: (
                        <<Self as Heaped>::Heap as MapsTmf<
                            ttw::L,
                            IdxBox<<Self as Heaped>::Heap, ds::Plus>,
                        >>::Tmf,
                        (),
                    ),
                ) -> Self {
                    crate::data_structure::Nat::Plus(t.0)
                }
                fn deconstruct_succeeds(&self, heap: &<Self as Heaped>::Heap) -> bool {
                    match self {
                        crate::data_structure::Nat::Plus(_) => true,
                        _ => false,
                    }
                }
                fn deconstruct(
                    self,
                    heap: &<Self as Heaped>::Heap,
                ) -> (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        IdxBox<<Self as Heaped>::Heap, ds::Plus>,
                    >>::Tmf,
                    (),
                ) {
                    match self {
                        crate::data_structure::Nat::Plus(t) => (t, ()),
                        _ => panic!("conversion failure"),
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
            #[rustfmt::skip]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        IdxBox<<Self as Heaped>::Heap, ds::Sum>,
                    >>::Tmf,
                    (),
                ),
            > for ds::Nat {
                fn construct(
                    heap: &mut <Self as Heaped>::Heap,
                    t: (
                        <<Self as Heaped>::Heap as MapsTmf<
                            ttw::L,
                            IdxBox<<Self as Heaped>::Heap, ds::Sum>,
                        >>::Tmf,
                        (),
                    ),
                ) -> Self {
                    crate::data_structure::Nat::Sum(t.0)
                }
                fn deconstruct_succeeds(&self, heap: &<Self as Heaped>::Heap) -> bool {
                    match self {
                        crate::data_structure::Nat::Sum(_) => true,
                        _ => false,
                    }
                }
                fn deconstruct(
                    self,
                    heap: &<Self as Heaped>::Heap,
                ) -> (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        IdxBox<<Self as Heaped>::Heap, ds::Sum>,
                    >>::Tmf,
                    (),
                ) {
                    match self {
                        crate::data_structure::Nat::Sum(t) => (t, ()),
                        _ => panic!("conversion failure"),
                    }
                }
            }
        }
    }
    /// generated by [term_specialized_impl_gen::gen_transitive_ccf_mod]
    #[rustfmt::skip]
    pub mod transitive_ccf {
        use tymetafuncspec_core::Set;
        use crate::data_structure as ds;
        use tymetafuncspec_core::IdxBox;
        use tymetafuncspec_core::BoundedNat;
        /// generated by [term_specialized_impl_gen::tuc_impls]
        #[rustfmt::skip]
        impl term::TransitivelyUnitCcf<ds::Heap, ds::Nat> for ds::LeftOperand {
            type Intermediary = ds::Nat;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        #[rustfmt::skip]
        impl term::TransitivelyUnitCcf<ds::Heap, ds::Nat> for ds::RightOperand {
            type Intermediary = ds::Nat;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        #[rustfmt::skip]
        impl term::TransitivelyUnitCcf<ds::Heap, ds::Nat> for ds::F {
            type Intermediary = ds::Nat;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        #[rustfmt::skip]
        impl term::TransitivelyUnitCcf<ds::Heap, Set<ds::Heap, ds::Nat>> for ds::Sum {
            type Intermediary = Set<ds::Heap, ds::Nat>;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        #[rustfmt::skip]
        impl term::TransitivelyUnitCcf<ds::Heap, BoundedNat<ds::Heap>> for ds::Nat {
            type Intermediary = BoundedNat<ds::Heap>;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        #[rustfmt::skip]
        impl term::TransitivelyUnitCcf<ds::Heap, IdxBox<ds::Heap, ds::Plus>>
        for ds::Nat {
            type Intermediary = IdxBox<ds::Heap, ds::Plus>;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        #[rustfmt::skip]
        impl term::TransitivelyUnitCcf<ds::Heap, IdxBox<ds::Heap, ds::F>> for ds::Nat {
            type Intermediary = IdxBox<ds::Heap, ds::F>;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        #[rustfmt::skip]
        impl term::TransitivelyUnitCcf<ds::Heap, IdxBox<ds::Heap, ds::Sum>> for ds::Nat {
            type Intermediary = IdxBox<ds::Heap, ds::Sum>;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        #[rustfmt::skip]
        impl term::TransitivelyUnitCcf<ds::Heap, ds::Plus>
        for IdxBox<ds::Heap, ds::Plus> {
            type Intermediary = ds::Plus;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        #[rustfmt::skip]
        impl term::TransitivelyUnitCcf<ds::Heap, ds::F> for IdxBox<ds::Heap, ds::F> {
            type Intermediary = ds::F;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        #[rustfmt::skip]
        impl term::TransitivelyUnitCcf<ds::Heap, ds::Sum> for IdxBox<ds::Heap, ds::Sum> {
            type Intermediary = ds::Sum;
        }
        /// generated by [term_specialized_impl_gen::tac_impls]
        #[rustfmt::skip]
        impl term::TransitivelyAllCcf<
            ds::Heap,
            (ds::LeftOperand, (ds::RightOperand, ())),
        > for ds::Plus {
            type Intermediary = ds::Plus;
            type Intermediaries = (ds::LeftOperand, (ds::RightOperand, ()));
        }
        /// generated by [term_specialized_impl_gen::tac_impls]
        #[rustfmt::skip]
        impl term::TransitivelyAllCcf<
            ds::Heap,
            (ds::LeftOperand, (ds::RightOperand, ())),
        > for IdxBox<ds::Heap, ds::Plus> {
            type Intermediary = ds::Plus;
            type Intermediaries = (ds::LeftOperand, (ds::RightOperand, ()));
        }
        /// generated by [term_specialized_impl_gen::tac_impls]
        #[rustfmt::skip]
        impl term::TransitivelyAllCcf<ds::Heap, (ds::LeftOperand, (ds::Nat, ()))>
        for ds::Plus {
            type Intermediary = ds::Plus;
            type Intermediaries = (ds::LeftOperand, (ds::RightOperand, ()));
        }
        /// generated by [term_specialized_impl_gen::tac_impls]
        #[rustfmt::skip]
        impl term::TransitivelyAllCcf<ds::Heap, (ds::LeftOperand, (ds::Nat, ()))>
        for IdxBox<ds::Heap, ds::Plus> {
            type Intermediary = ds::Plus;
            type Intermediaries = (ds::LeftOperand, (ds::RightOperand, ()));
        }
        /// generated by [term_specialized_impl_gen::tac_impls]
        #[rustfmt::skip]
        impl term::TransitivelyAllCcf<ds::Heap, (ds::Nat, (ds::RightOperand, ()))>
        for ds::Plus {
            type Intermediary = ds::Plus;
            type Intermediaries = (ds::LeftOperand, (ds::RightOperand, ()));
        }
        /// generated by [term_specialized_impl_gen::tac_impls]
        #[rustfmt::skip]
        impl term::TransitivelyAllCcf<ds::Heap, (ds::Nat, (ds::RightOperand, ()))>
        for IdxBox<ds::Heap, ds::Plus> {
            type Intermediary = ds::Plus;
            type Intermediaries = (ds::LeftOperand, (ds::RightOperand, ()));
        }
        /// generated by [term_specialized_impl_gen::tac_impls]
        #[rustfmt::skip]
        impl term::TransitivelyAllCcf<ds::Heap, (ds::Nat, (ds::Nat, ()))> for ds::Plus {
            type Intermediary = ds::Plus;
            type Intermediaries = (ds::LeftOperand, (ds::RightOperand, ()));
        }
        /// generated by [term_specialized_impl_gen::tac_impls]
        #[rustfmt::skip]
        impl term::TransitivelyAllCcf<ds::Heap, (ds::Nat, (ds::Nat, ()))>
        for IdxBox<ds::Heap, ds::Plus> {
            type Intermediary = ds::Plus;
            type Intermediaries = (ds::LeftOperand, (ds::RightOperand, ()));
        }
    }
    /// generated by [term_specialized_impl_gen::gen_ccf_auto_impls]
    #[rustfmt::skip]
    pub mod ccf_auto_impls {
        term::auto_impl_ccf!(crate ::data_structure::Heap, crate ::data_structure::F);
        term::auto_impl_ccf!(crate ::data_structure::Heap, crate ::data_structure::Plus);
        term::auto_impl_ccf!(
            crate ::data_structure::Heap, crate ::data_structure::LeftOperand
        );
        term::auto_impl_ccf!(
            crate ::data_structure::Heap, crate ::data_structure::RightOperand
        );
        term::auto_impl_ccf!(crate ::data_structure::Heap, crate ::data_structure::Sum);
        term::auto_impl_ccf!(crate ::data_structure::Heap, crate ::data_structure::Nat);
        term::auto_impl_ccf!(
            crate ::data_structure::Heap, tymetafuncspec_core::Set < crate
            ::data_structure::Heap, crate ::data_structure::Nat, >
        );
        term::auto_impl_ccf!(
            crate ::data_structure::Heap, tymetafuncspec_core::BoundedNat < crate
            ::data_structure::Heap, >
        );
        term::auto_impl_ccf!(
            crate ::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
            ::data_structure::Heap, crate ::data_structure::F, >
        );
        term::auto_impl_ccf!(
            crate ::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
            ::data_structure::Heap, crate ::data_structure::Plus, >
        );
        term::auto_impl_ccf!(
            crate ::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
            ::data_structure::Heap, crate ::data_structure::Sum, >
        );
    }
    /// generated by [term_specialized_impl_gen::gen_maps_tmf]
    #[rustfmt::skip]
    pub mod maps_tmf_impls {
        use crate::term_trait::words as ttw;
        use term::CanonicallyConstructibleFrom;
        use crate::data_structure as ds;
        impl<TmfMonomorphization> term::MapsTmf<ttw::L, TmfMonomorphization> for ds::Heap
        where
            TmfMonomorphization: CanonicallyConstructibleFrom<
                Self,
                (TmfMonomorphization, ()),
            >,
        {
            type Tmf = TmfMonomorphization;
        }
    }
}
