/// generated by [parse_gen::generate]
pub mod parse {
    use crate::cst;

    /// generated by [parse_gen::generate_parse]
    impl parse::Parse<crate::cst::data_structure::Heap>
        for tymetafuncspec_core::Cstfy<
            crate::cst::data_structure::Heap,
            crate::cst::data_structure::F,
        >
    {
        fn parse(
            source: &str,
            offset: parse::miette::SourceOffset,
            heap: &mut crate::cst::data_structure::Heap,
            errors: &mut Vec<parse::ParseError>,
        ) -> (
            tymetafuncspec_core::Cstfy<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::F,
            >,
            parse::miette::SourceOffset,
        ) {
            let mut ute = None;
            /// generated by [parse_gen::gen_parse_current]
            fn parse_directly(
                source: &str,
                initial_offset: parse::miette::SourceOffset,
                heap: &mut crate::cst::data_structure::Heap,
                errors: &mut Vec<parse::ParseError>,
                default_ret: parse::ParseError,
            ) -> (
                tymetafuncspec_core::Cstfy<
                    crate::cst::data_structure::Heap,
                    crate::cst::data_structure::F,
                >,
                parse::miette::SourceOffset,
            ) {
                match parse::unicode_segmentation::UnicodeSegmentation::unicode_words(
                    &source[initial_offset.offset()..],
                )
                .next()
                {
                    Some(stringify!(f)) => {
                        let mut offset = initial_offset;
                        let args = (
                            {
                                let (res, new_offset) = <tymetafuncspec_core::Either<
                                    crate::cst::data_structure::Heap,
                                    crate::cst::data_structure::Nat,
                                    std_parse_error::ParseError<crate::cst::data_structure::Heap>,
                                > as parse::Parse<_>>::parse(
                                    source, offset, heap, errors
                                );
                                offset = new_offset;
                                res
                            },
                            (),
                        );
                        (
                            (|x| tymetafuncspec_core::cstfy_ok(
                                x,
                                initial_offset,
                                offset,
                            ))(
                                <crate::cst::data_structure::F as term::CanonicallyConstructibleFrom<
                                    (
                                        tymetafuncspec_core::Either<
                                            crate::cst::data_structure::Heap,
                                            crate::cst::data_structure::Nat,
                                            std_parse_error::ParseError<
                                                crate::cst::data_structure::Heap,
                                            >,
                                        >,
                                        (),
                                    ),
                                >>::construct(heap, args),
                            ),
                            offset,
                        )
                    }
                    None => (
                        tymetafuncspec_core::Either::Right(
                            std_parse_error::ParseError::new(
                                parse::ParseError::UnexpectedEndOfInput(initial_offset.into()),
                            ),
                            std::marker::PhantomData,
                        ),
                        initial_offset,
                    ),
                    _ => (
                        tymetafuncspec_core::Either::Right(
                            std_parse_error::ParseError::new(default_ret),
                            std::marker::PhantomData,
                        ),
                        initial_offset,
                    ),
                }
            }
            match <tymetafuncspec_core::Either<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::Nat,
                std_parse_error::ParseError<crate::cst::data_structure::Heap>,
            > as parse::Parse<crate::cst::data_structure::Heap>>::parse(
                source, offset, heap, errors,
            ) {
                Ok((cst, offset)) => {
                    return (
                        <crate::cst::data_structure::F as term::CanonicallyConstructibleFrom<(
                            tymetafuncspec_core::Either<
                                crate::cst::data_structure::Heap,
                                crate::cst::data_structure::Nat,
                                std_parse_error::ParseError<crate::cst::data_structure::Heap>,
                            >,
                            (),
                        )>>::construct(
                            heap,
                            (
                                tymetafuncspec_core::Either::Left(cst, std::marker::PhantomData),
                                tymetafuncspec_core::Maybe::Nothing,
                            ),
                        ),
                        offset,
                    );
                }
                Err(e) => {
                    ute = parse::ParseError::merge_over(e, ute);
                }
            }
            parse_directly(source, offset, heap, errors, ute.unwrap())
        }
        fn unparse(&self, heap: &crate::cst::data_structure::Heap) -> parse::Unparse {
            todo!()
        }
    }
    /// generated by [parse_gen::generate_parse]
    impl parse::Parse<crate::cst::data_structure::Heap>
        for tymetafuncspec_core::Cstfy<
            crate::cst::data_structure::Heap,
            crate::cst::data_structure::Plus,
        >
    {
        fn parse(
            source: &str,
            offset: parse::miette::SourceOffset,
            heap: &mut crate::cst::data_structure::Heap,
            errors: &mut Vec<parse::ParseError>,
        ) -> (
            tymetafuncspec_core::Cstfy<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::Plus,
            >,
            parse::miette::SourceOffset,
        ) {
            let mut ute = None;
            /// generated by [parse_gen::gen_parse_current]
            fn parse_directly(
                source: &str,
                initial_offset: parse::miette::SourceOffset,
                heap: &mut crate::cst::data_structure::Heap,
                errors: &mut Vec<parse::ParseError>,
                default_ret: parse::ParseError,
            ) -> (
                tymetafuncspec_core::Cstfy<
                    crate::cst::data_structure::Heap,
                    crate::cst::data_structure::Plus,
                >,
                parse::miette::SourceOffset,
            ) {
                match parse::unicode_segmentation::UnicodeSegmentation::unicode_words(
                    &source[initial_offset.offset()..],
                )
                .next()
                {
                    Some(stringify!(plus)) => {
                        let mut offset = initial_offset;
                        let args = (
                            {
                                let (res, new_offset) = <tymetafuncspec_core::Either<
                                    crate::cst::data_structure::Heap,
                                    tymetafuncspec_core::Pair<
                                        crate::cst::data_structure::Heap,
                                        crate::cst::data_structure::LeftOperand,
                                        tymetafuncspec_core::Maybe<
                                            crate::cst::data_structure::Heap,
                                            std_parse_metadata::ParseMetadata<
                                                crate::cst::data_structure::Heap,
                                            >,
                                        >,
                                    >,
                                    std_parse_error::ParseError<crate::cst::data_structure::Heap>,
                                > as parse::Parse<_>>::parse(
                                    source, offset, heap, errors
                                );
                                offset = new_offset;
                                res
                            },
                            (
                                {
                                    let (res, new_offset) = <tymetafuncspec_core::Either<
                                        crate::cst::data_structure::Heap,
                                        tymetafuncspec_core::Pair<
                                            crate::cst::data_structure::Heap,
                                            crate::cst::data_structure::RightOperand,
                                            tymetafuncspec_core::Maybe<
                                                crate::cst::data_structure::Heap,
                                                std_parse_metadata::ParseMetadata<
                                                    crate::cst::data_structure::Heap,
                                                >,
                                            >,
                                        >,
                                        std_parse_error::ParseError<
                                            crate::cst::data_structure::Heap,
                                        >,
                                    > as parse::Parse<_>>::parse(
                                        source, offset, heap, errors
                                    );
                                    offset = new_offset;
                                    res
                                },
                                (),
                            ),
                        );
                        (
                            (|x| tymetafuncspec_core::cstfy_ok(
                                x,
                                initial_offset,
                                offset,
                            ))(
                                <crate::cst::data_structure::Plus as term::CanonicallyConstructibleFrom<
                                    (
                                        tymetafuncspec_core::Either<
                                            crate::cst::data_structure::Heap,
                                            tymetafuncspec_core::Pair<
                                                crate::cst::data_structure::Heap,
                                                crate::cst::data_structure::LeftOperand,
                                                tymetafuncspec_core::Maybe<
                                                    crate::cst::data_structure::Heap,
                                                    std_parse_metadata::ParseMetadata<
                                                        crate::cst::data_structure::Heap,
                                                    >,
                                                >,
                                            >,
                                            std_parse_error::ParseError<
                                                crate::cst::data_structure::Heap,
                                            >,
                                        >,
                                        (
                                            tymetafuncspec_core::Either<
                                                crate::cst::data_structure::Heap,
                                                tymetafuncspec_core::Pair<
                                                    crate::cst::data_structure::Heap,
                                                    crate::cst::data_structure::RightOperand,
                                                    tymetafuncspec_core::Maybe<
                                                        crate::cst::data_structure::Heap,
                                                        std_parse_metadata::ParseMetadata<
                                                            crate::cst::data_structure::Heap,
                                                        >,
                                                    >,
                                                >,
                                                std_parse_error::ParseError<
                                                    crate::cst::data_structure::Heap,
                                                >,
                                            >,
                                            (),
                                        ),
                                    ),
                                >>::construct(heap, args),
                            ),
                            offset,
                        )
                    }
                    None => (
                        tymetafuncspec_core::Either::Right(
                            std_parse_error::ParseError::new(
                                parse::ParseError::UnexpectedEndOfInput(initial_offset.into()),
                            ),
                            std::marker::PhantomData,
                        ),
                        initial_offset,
                    ),
                    _ => (
                        tymetafuncspec_core::Either::Right(
                            std_parse_error::ParseError::new(default_ret),
                            std::marker::PhantomData,
                        ),
                        initial_offset,
                    ),
                }
            }
            parse_directly(source, offset, heap, errors, ute.unwrap())
        }
        fn unparse(&self, heap: &crate::cst::data_structure::Heap) -> parse::Unparse {
            todo!()
        }
    }
    /// generated by [parse_gen::generate_parse]
    impl parse::Parse<crate::cst::data_structure::Heap>
        for tymetafuncspec_core::Cstfy<
            crate::cst::data_structure::Heap,
            crate::cst::data_structure::LeftOperand,
        >
    {
        fn parse(
            source: &str,
            offset: parse::miette::SourceOffset,
            heap: &mut crate::cst::data_structure::Heap,
            errors: &mut Vec<parse::ParseError>,
        ) -> (
            tymetafuncspec_core::Cstfy<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::LeftOperand,
            >,
            parse::miette::SourceOffset,
        ) {
            let mut ute = None;
            /// generated by [parse_gen::gen_parse_current]
            fn parse_directly(
                source: &str,
                initial_offset: parse::miette::SourceOffset,
                heap: &mut crate::cst::data_structure::Heap,
                errors: &mut Vec<parse::ParseError>,
                default_ret: parse::ParseError,
            ) -> (
                tymetafuncspec_core::Cstfy<
                    crate::cst::data_structure::Heap,
                    crate::cst::data_structure::LeftOperand,
                >,
                parse::miette::SourceOffset,
            ) {
                match parse::unicode_segmentation::UnicodeSegmentation::unicode_words(
                    &source[initial_offset.offset()..],
                )
                .next()
                {
                    Some(stringify!(left_operand)) => {
                        let mut offset = initial_offset;
                        let args = (
                            {
                                let (res, new_offset) = <tymetafuncspec_core::Either<
                                    crate::cst::data_structure::Heap,
                                    crate::cst::data_structure::Nat,
                                    std_parse_error::ParseError<crate::cst::data_structure::Heap>,
                                > as parse::Parse<_>>::parse(
                                    source, offset, heap, errors
                                );
                                offset = new_offset;
                                res
                            },
                            (),
                        );
                        (
                            (|x| tymetafuncspec_core::cstfy_ok(
                                x,
                                initial_offset,
                                offset,
                            ))(
                                <crate::cst::data_structure::LeftOperand as term::CanonicallyConstructibleFrom<
                                    (
                                        tymetafuncspec_core::Either<
                                            crate::cst::data_structure::Heap,
                                            crate::cst::data_structure::Nat,
                                            std_parse_error::ParseError<
                                                crate::cst::data_structure::Heap,
                                            >,
                                        >,
                                        (),
                                    ),
                                >>::construct(heap, args),
                            ),
                            offset,
                        )
                    }
                    None => (
                        tymetafuncspec_core::Either::Right(
                            std_parse_error::ParseError::new(
                                parse::ParseError::UnexpectedEndOfInput(initial_offset.into()),
                            ),
                            std::marker::PhantomData,
                        ),
                        initial_offset,
                    ),
                    _ => (
                        tymetafuncspec_core::Either::Right(
                            std_parse_error::ParseError::new(default_ret),
                            std::marker::PhantomData,
                        ),
                        initial_offset,
                    ),
                }
            }
            match <tymetafuncspec_core::Either<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::Nat,
                std_parse_error::ParseError<crate::cst::data_structure::Heap>,
            > as parse::Parse>::parse(source, offset, heap, errors)
            {
                Ok((cst, offset)) => {
                    return Ok((
                        <crate::cst::data_structure::LeftOperand as term::CanonicallyConstructibleFrom<
                            (
                                tymetafuncspec_core::Either<
                                    crate::cst::data_structure::Heap,
                                    crate::cst::data_structure::Nat,
                                    std_parse_error::ParseError<
                                        crate::cst::data_structure::Heap,
                                    >,
                                >,
                                (),
                            ),
                        >>::construct(
                            heap,
                            (
                                tymetafuncspec_core::Either::Left(
                                    cst,
                                    std::marker::PhantomData,
                                ),
                                tymetafuncspec_core::Maybe::Nothing,
                            ),
                        ),
                        offset,
                    ));
                }
                Err(e) => {
                    ute = parse::ParseError::merge_over(e, ute);
                }
            }
            parse_directly(source, offset, heap, errors, ute.unwrap())
        }
        fn unparse(&self, heap: &crate::cst::data_structure::Heap) -> parse::Unparse {
            todo!()
        }
    }
    /// generated by [parse_gen::generate_parse]
    impl parse::Parse<crate::cst::data_structure::Heap>
        for tymetafuncspec_core::Cstfy<
            crate::cst::data_structure::Heap,
            crate::cst::data_structure::RightOperand,
        >
    {
        fn parse(
            source: &str,
            offset: parse::miette::SourceOffset,
            heap: &mut crate::cst::data_structure::Heap,
            errors: &mut Vec<parse::ParseError>,
        ) -> (
            tymetafuncspec_core::Cstfy<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::RightOperand,
            >,
            parse::miette::SourceOffset,
        ) {
            let mut ute = None;
            /// generated by [parse_gen::gen_parse_current]
            fn parse_directly(
                source: &str,
                initial_offset: parse::miette::SourceOffset,
                heap: &mut crate::cst::data_structure::Heap,
                errors: &mut Vec<parse::ParseError>,
                default_ret: parse::ParseError,
            ) -> (
                tymetafuncspec_core::Cstfy<
                    crate::cst::data_structure::Heap,
                    crate::cst::data_structure::RightOperand,
                >,
                parse::miette::SourceOffset,
            ) {
                match parse::unicode_segmentation::UnicodeSegmentation::unicode_words(
                    &source[initial_offset.offset()..],
                )
                .next()
                {
                    Some(stringify!(right_operand)) => {
                        let mut offset = initial_offset;
                        let args = (
                            {
                                let (res, new_offset) = <tymetafuncspec_core::Either<
                                    crate::cst::data_structure::Heap,
                                    crate::cst::data_structure::Nat,
                                    std_parse_error::ParseError<crate::cst::data_structure::Heap>,
                                > as parse::Parse<_>>::parse(
                                    source, offset, heap, errors
                                );
                                offset = new_offset;
                                res
                            },
                            (),
                        );
                        (
                            (|x| tymetafuncspec_core::cstfy_ok(
                                x,
                                initial_offset,
                                offset,
                            ))(
                                <crate::cst::data_structure::RightOperand as term::CanonicallyConstructibleFrom<
                                    (
                                        tymetafuncspec_core::Either<
                                            crate::cst::data_structure::Heap,
                                            crate::cst::data_structure::Nat,
                                            std_parse_error::ParseError<
                                                crate::cst::data_structure::Heap,
                                            >,
                                        >,
                                        (),
                                    ),
                                >>::construct(heap, args),
                            ),
                            offset,
                        )
                    }
                    None => (
                        tymetafuncspec_core::Either::Right(
                            std_parse_error::ParseError::new(
                                parse::ParseError::UnexpectedEndOfInput(initial_offset.into()),
                            ),
                            std::marker::PhantomData,
                        ),
                        initial_offset,
                    ),
                    _ => (
                        tymetafuncspec_core::Either::Right(
                            std_parse_error::ParseError::new(default_ret),
                            std::marker::PhantomData,
                        ),
                        initial_offset,
                    ),
                }
            }
            match <tymetafuncspec_core::Either<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::Nat,
                std_parse_error::ParseError<crate::cst::data_structure::Heap>,
            > as parse::Parse>::parse(source, offset, heap, errors)
            {
                Ok((cst, offset)) => {
                    return Ok((
                        <crate::cst::data_structure::RightOperand as term::CanonicallyConstructibleFrom<
                            (
                                tymetafuncspec_core::Either<
                                    crate::cst::data_structure::Heap,
                                    crate::cst::data_structure::Nat,
                                    std_parse_error::ParseError<
                                        crate::cst::data_structure::Heap,
                                    >,
                                >,
                                (),
                            ),
                        >>::construct(
                            heap,
                            (
                                tymetafuncspec_core::Either::Left(
                                    cst,
                                    std::marker::PhantomData,
                                ),
                                tymetafuncspec_core::Maybe::Nothing,
                            ),
                        ),
                        offset,
                    ));
                }
                Err(e) => {
                    ute = parse::ParseError::merge_over(e, ute);
                }
            }
            parse_directly(source, offset, heap, errors, ute.unwrap())
        }
        fn unparse(&self, heap: &crate::cst::data_structure::Heap) -> parse::Unparse {
            todo!()
        }
    }
    /// generated by [parse_gen::generate_parse]
    impl parse::Parse<crate::cst::data_structure::Heap>
        for tymetafuncspec_core::Cstfy<
            crate::cst::data_structure::Heap,
            crate::cst::data_structure::Sum,
        >
    {
        fn parse(
            source: &str,
            offset: parse::miette::SourceOffset,
            heap: &mut crate::cst::data_structure::Heap,
            errors: &mut Vec<parse::ParseError>,
        ) -> (
            tymetafuncspec_core::Cstfy<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::Sum,
            >,
            parse::miette::SourceOffset,
        ) {
            let mut ute = None;
            /// generated by [parse_gen::gen_parse_current]
            fn parse_directly(
                source: &str,
                initial_offset: parse::miette::SourceOffset,
                heap: &mut crate::cst::data_structure::Heap,
                errors: &mut Vec<parse::ParseError>,
                default_ret: parse::ParseError,
            ) -> (
                tymetafuncspec_core::Cstfy<
                    crate::cst::data_structure::Heap,
                    crate::cst::data_structure::Sum,
                >,
                parse::miette::SourceOffset,
            ) {
                match parse::unicode_segmentation::UnicodeSegmentation::unicode_words(
                    &source[initial_offset.offset()..],
                )
                .next()
                {
                    Some(stringify!(sum)) => {
                        let mut offset = initial_offset;
                        let args = (
                            {
                                let (res, new_offset) = <tymetafuncspec_core::Either<
                                    crate::cst::data_structure::Heap,
                                    tymetafuncspec_core::Pair<
                                        crate::cst::data_structure::Heap,
                                        tymetafuncspec_core::Set<
                                            crate::cst::data_structure::Heap,
                                            tymetafuncspec_core::Either<
                                                crate::cst::data_structure::Heap,
                                                crate::cst::data_structure::Nat,
                                                std_parse_error::ParseError<
                                                    crate::cst::data_structure::Heap,
                                                >,
                                            >,
                                        >,
                                        tymetafuncspec_core::Maybe<
                                            crate::cst::data_structure::Heap,
                                            std_parse_metadata::ParseMetadata<
                                                crate::cst::data_structure::Heap,
                                            >,
                                        >,
                                    >,
                                    std_parse_error::ParseError<crate::cst::data_structure::Heap>,
                                > as parse::Parse<_>>::parse(
                                    source, offset, heap, errors
                                );
                                offset = new_offset;
                                res
                            },
                            (),
                        );
                        (
                            (|x| tymetafuncspec_core::cstfy_ok(
                                x,
                                initial_offset,
                                offset,
                            ))(
                                <crate::cst::data_structure::Sum as term::CanonicallyConstructibleFrom<
                                    (
                                        tymetafuncspec_core::Either<
                                            crate::cst::data_structure::Heap,
                                            tymetafuncspec_core::Pair<
                                                crate::cst::data_structure::Heap,
                                                tymetafuncspec_core::Set<
                                                    crate::cst::data_structure::Heap,
                                                    tymetafuncspec_core::Either<
                                                        crate::cst::data_structure::Heap,
                                                        crate::cst::data_structure::Nat,
                                                        std_parse_error::ParseError<
                                                            crate::cst::data_structure::Heap,
                                                        >,
                                                    >,
                                                >,
                                                tymetafuncspec_core::Maybe<
                                                    crate::cst::data_structure::Heap,
                                                    std_parse_metadata::ParseMetadata<
                                                        crate::cst::data_structure::Heap,
                                                    >,
                                                >,
                                            >,
                                            std_parse_error::ParseError<
                                                crate::cst::data_structure::Heap,
                                            >,
                                        >,
                                        (),
                                    ),
                                >>::construct(heap, args),
                            ),
                            offset,
                        )
                    }
                    None => (
                        tymetafuncspec_core::Either::Right(
                            std_parse_error::ParseError::new(
                                parse::ParseError::UnexpectedEndOfInput(initial_offset.into()),
                            ),
                            std::marker::PhantomData,
                        ),
                        initial_offset,
                    ),
                    _ => (
                        tymetafuncspec_core::Either::Right(
                            std_parse_error::ParseError::new(default_ret),
                            std::marker::PhantomData,
                        ),
                        initial_offset,
                    ),
                }
            }
            match <tymetafuncspec_core::Either<
                crate::cst::data_structure::Heap,
                tymetafuncspec_core::Pair<
                    crate::cst::data_structure::Heap,
                    tymetafuncspec_core::Set<
                        crate::cst::data_structure::Heap,
                        tymetafuncspec_core::Either<
                            crate::cst::data_structure::Heap,
                            crate::cst::data_structure::Nat,
                            std_parse_error::ParseError<crate::cst::data_structure::Heap>,
                        >,
                    >,
                    tymetafuncspec_core::Maybe<
                        crate::cst::data_structure::Heap,
                        std_parse_metadata::ParseMetadata<crate::cst::data_structure::Heap>,
                    >,
                >,
                std_parse_error::ParseError<crate::cst::data_structure::Heap>,
            > as parse::Parse>::parse(source, offset, heap, errors)
            {
                Ok((cst, offset)) => {
                    return Ok((
                        <crate::cst::data_structure::Sum as term::CanonicallyConstructibleFrom<
                            (
                                tymetafuncspec_core::Either<
                                    crate::cst::data_structure::Heap,
                                    tymetafuncspec_core::Pair<
                                        crate::cst::data_structure::Heap,
                                        tymetafuncspec_core::Set<
                                            crate::cst::data_structure::Heap,
                                            tymetafuncspec_core::Either<
                                                crate::cst::data_structure::Heap,
                                                crate::cst::data_structure::Nat,
                                                std_parse_error::ParseError<
                                                    crate::cst::data_structure::Heap,
                                                >,
                                            >,
                                        >,
                                        tymetafuncspec_core::Maybe<
                                            crate::cst::data_structure::Heap,
                                            std_parse_metadata::ParseMetadata<
                                                crate::cst::data_structure::Heap,
                                            >,
                                        >,
                                    >,
                                    std_parse_error::ParseError<crate::cst::data_structure::Heap>,
                                >,
                                (),
                            ),
                        >>::construct(
                            heap,
                            (
                                tymetafuncspec_core::Either::Left(cst, std::marker::PhantomData),
                                tymetafuncspec_core::Maybe::Nothing,
                            ),
                        ),
                        offset,
                    ));
                }
                Err(e) => {
                    ute = parse::ParseError::merge_over(e, ute);
                }
            }
            parse_directly(source, offset, heap, errors, ute.unwrap())
        }
        fn unparse(&self, heap: &crate::cst::data_structure::Heap) -> parse::Unparse {
            todo!()
        }
    }
    /// generated by [parse_gen::generate_parse]
    impl parse::Parse<crate::cst::data_structure::Heap>
        for tymetafuncspec_core::CstfyTransparent<
            crate::cst::data_structure::Heap,
            crate::cst::data_structure::Nat,
        >
    {
        fn parse(
            source: &str,
            offset: parse::miette::SourceOffset,
            heap: &mut crate::cst::data_structure::Heap,
            errors: &mut Vec<parse::ParseError>,
        ) -> (
            tymetafuncspec_core::CstfyTransparent<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::Nat,
            >,
            parse::miette::SourceOffset,
        ) {
            let mut ute = None;
            let parse_directly = |_, _, _, _, ret| ret;
            match <tymetafuncspec_core::Pair<
                crate::cst::data_structure::Heap,
                tymetafuncspec_core::BoundedNat<crate::cst::data_structure::Heap>,
                tymetafuncspec_core::Maybe<
                    crate::cst::data_structure::Heap,
                    std_parse_metadata::ParseMetadata<crate::cst::data_structure::Heap>,
                >,
            > as parse::Parse<cst::data_structure::Heap>>::parse(
                source, offset, heap, errors
            ) {
                Ok((cst, offset)) => {
                    return (
                        <crate::cst::data_structure::Nat as term::CanonicallyConstructibleFrom<
                            (
                                tymetafuncspec_core::Pair<
                                    crate::cst::data_structure::Heap,
                                    tymetafuncspec_core::BoundedNat<
                                        crate::cst::data_structure::Heap,
                                    >,
                                    tymetafuncspec_core::Maybe<
                                        crate::cst::data_structure::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            crate::cst::data_structure::Heap,
                                        >,
                                    >,
                                >,
                                (),
                            ),
                        >>::construct(
                            heap,
                            (
                                tymetafuncspec_core::Either::Left(cst, std::marker::PhantomData),
                                tymetafuncspec_core::Maybe::Nothing,
                            ),
                        ),
                        offset,
                    );
                }
                Err(e) => {
                    ute = parse::ParseError::merge_over(e, ute);
                }
            }
            match <tymetafuncspec_core::Pair<
                crate::cst::data_structure::Heap,
                tymetafuncspec_core::IdxBox<
                    crate::cst::data_structure::Heap,
                    tymetafuncspec_core::Pair<
                        crate::cst::data_structure::Heap,
                        crate::cst::data_structure::F,
                        tymetafuncspec_core::Maybe<
                            crate::cst::data_structure::Heap,
                            std_parse_metadata::ParseMetadata<crate::cst::data_structure::Heap>,
                        >,
                    >,
                >,
                tymetafuncspec_core::Maybe<
                    crate::cst::data_structure::Heap,
                    std_parse_metadata::ParseMetadata<crate::cst::data_structure::Heap>,
                >,
            > as parse::Parse>::parse(source, offset, heap, errors)
            {
                Ok((cst, offset)) => {
                    return Ok((
                        <crate::cst::data_structure::Nat as term::CanonicallyConstructibleFrom<
                            (
                                tymetafuncspec_core::Pair<
                                    crate::cst::data_structure::Heap,
                                    tymetafuncspec_core::IdxBox<
                                        crate::cst::data_structure::Heap,
                                        tymetafuncspec_core::Pair<
                                            crate::cst::data_structure::Heap,
                                            crate::cst::data_structure::F,
                                            tymetafuncspec_core::Maybe<
                                                crate::cst::data_structure::Heap,
                                                std_parse_metadata::ParseMetadata<
                                                    crate::cst::data_structure::Heap,
                                                >,
                                            >,
                                        >,
                                    >,
                                    tymetafuncspec_core::Maybe<
                                        crate::cst::data_structure::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            crate::cst::data_structure::Heap,
                                        >,
                                    >,
                                >,
                                (),
                            ),
                        >>::construct(
                            heap,
                            (
                                tymetafuncspec_core::Either::Left(cst, std::marker::PhantomData),
                                tymetafuncspec_core::Maybe::Nothing,
                            ),
                        ),
                        offset,
                    ));
                }
                Err(e) => {
                    ute = parse::ParseError::merge_over(e, ute);
                }
            }
            match <tymetafuncspec_core::Pair<
                crate::cst::data_structure::Heap,
                tymetafuncspec_core::IdxBox<
                    crate::cst::data_structure::Heap,
                    tymetafuncspec_core::Pair<
                        crate::cst::data_structure::Heap,
                        crate::cst::data_structure::Plus,
                        tymetafuncspec_core::Maybe<
                            crate::cst::data_structure::Heap,
                            std_parse_metadata::ParseMetadata<crate::cst::data_structure::Heap>,
                        >,
                    >,
                >,
                tymetafuncspec_core::Maybe<
                    crate::cst::data_structure::Heap,
                    std_parse_metadata::ParseMetadata<crate::cst::data_structure::Heap>,
                >,
            > as parse::Parse>::parse(source, offset, heap, errors)
            {
                Ok((cst, offset)) => {
                    return Ok((
                        <crate::cst::data_structure::Nat as term::CanonicallyConstructibleFrom<
                            (
                                tymetafuncspec_core::Pair<
                                    crate::cst::data_structure::Heap,
                                    tymetafuncspec_core::IdxBox<
                                        crate::cst::data_structure::Heap,
                                        tymetafuncspec_core::Pair<
                                            crate::cst::data_structure::Heap,
                                            crate::cst::data_structure::Plus,
                                            tymetafuncspec_core::Maybe<
                                                crate::cst::data_structure::Heap,
                                                std_parse_metadata::ParseMetadata<
                                                    crate::cst::data_structure::Heap,
                                                >,
                                            >,
                                        >,
                                    >,
                                    tymetafuncspec_core::Maybe<
                                        crate::cst::data_structure::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            crate::cst::data_structure::Heap,
                                        >,
                                    >,
                                >,
                                (),
                            ),
                        >>::construct(
                            heap,
                            (
                                tymetafuncspec_core::Either::Left(cst, std::marker::PhantomData),
                                tymetafuncspec_core::Maybe::Nothing,
                            ),
                        ),
                        offset,
                    ));
                }
                Err(e) => {
                    ute = parse::ParseError::merge_over(e, ute);
                }
            }
            parse_directly(source, offset, heap, errors, ute.unwrap())
        }
        fn unparse(&self, heap: &crate::cst::data_structure::Heap) -> parse::Unparse {
            todo!()
        }
    }
}
pub mod cst {
    /// generated by [term_specialized_gen::generate]
    pub mod data_structure {
        /// generated by [term_specialized_gen::gen_heap]
        #[derive(Default)]
        pub struct Heap {
            either: crate::cst::data_structure::heap::either::Bak,
            parse_error: crate::cst::data_structure::heap::parse_error::Bak,
            pair: crate::cst::data_structure::heap::pair::Bak,
            maybe: crate::cst::data_structure::heap::maybe::Bak,
            parse_metadata: crate::cst::data_structure::heap::parse_metadata::Bak,
            set: crate::cst::data_structure::heap::set::Bak,
            nat_lit: crate::cst::data_structure::heap::nat_lit::Bak,
            idx_box: crate::cst::data_structure::heap::idx_box::Bak,
        }
        pub mod heap {
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[derive(Default)]
            pub struct Bak {
                pub either: crate::cst::data_structure::heap::either::Bak,
                pub parse_error: crate::cst::data_structure::heap::parse_error::Bak,
                pub pair: crate::cst::data_structure::heap::pair::Bak,
                pub maybe: crate::cst::data_structure::heap::maybe::Bak,
                pub parse_metadata: crate::cst::data_structure::heap::parse_metadata::Bak,
                pub set: crate::cst::data_structure::heap::set::Bak,
                pub nat_lit: crate::cst::data_structure::heap::nat_lit::Bak,
                pub idx_box: crate::cst::data_structure::heap::idx_box::Bak,
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod either {
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[derive(Default)]
                pub struct Bak {
                    pub nat: crate::cst::data_structure::heap::either::nat::Bak,
                    pub pair: crate::cst::data_structure::heap::either::pair::Bak,
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod nat {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub parse_error:
                            crate::cst::data_structure::heap::either::nat::parse_error::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod parse_error {
                        /// generated by [term_specialized_gen::gen_heapbak_module]
                        #[derive(Default)]
                        pub struct Bak(
                            pub  tymetafuncspec_core::EitherHeapBak<
                                crate::cst::data_structure::Heap,
                                crate::cst::data_structure::Nat,
                                std_parse_error::ParseError<crate::cst::data_structure::Heap>,
                            >,
                        );
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod pair {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub left_operand:
                            crate::cst::data_structure::heap::either::pair::left_operand::Bak,
                        pub right_operand:
                            crate::cst::data_structure::heap::either::pair::right_operand::Bak,
                        pub set: crate::cst::data_structure::heap::either::pair::set::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod left_operand {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub maybe: crate::cst::data_structure::heap::either::pair::left_operand::maybe::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod maybe {
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[derive(Default)]
                            pub struct Bak {
                                pub parse_metadata: crate::cst::data_structure::heap::either::pair::left_operand::maybe::parse_metadata::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            pub mod parse_metadata {
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub parse_error: crate::cst::data_structure::heap::either::pair::left_operand::maybe::parse_metadata::parse_error::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                pub mod parse_error {
                                    /// generated by [term_specialized_gen::gen_heapbak_module]
                                    #[derive(Default)]
                                    pub struct Bak(
                                        pub  tymetafuncspec_core::EitherHeapBak<
                                            crate::cst::data_structure::Heap,
                                            tymetafuncspec_core::Pair<
                                                crate::cst::data_structure::Heap,
                                                crate::cst::data_structure::LeftOperand,
                                                tymetafuncspec_core::Maybe<
                                                    crate::cst::data_structure::Heap,
                                                    std_parse_metadata::ParseMetadata<
                                                        crate::cst::data_structure::Heap,
                                                    >,
                                                >,
                                            >,
                                            std_parse_error::ParseError<
                                                crate::cst::data_structure::Heap,
                                            >,
                                        >,
                                    );
                                }
                            }
                        }
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod right_operand {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub maybe: crate::cst::data_structure::heap::either::pair::right_operand::maybe::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod maybe {
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[derive(Default)]
                            pub struct Bak {
                                pub parse_metadata: crate::cst::data_structure::heap::either::pair::right_operand::maybe::parse_metadata::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            pub mod parse_metadata {
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub parse_error: crate::cst::data_structure::heap::either::pair::right_operand::maybe::parse_metadata::parse_error::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                pub mod parse_error {
                                    /// generated by [term_specialized_gen::gen_heapbak_module]
                                    #[derive(Default)]
                                    pub struct Bak(
                                        pub  tymetafuncspec_core::EitherHeapBak<
                                            crate::cst::data_structure::Heap,
                                            tymetafuncspec_core::Pair<
                                                crate::cst::data_structure::Heap,
                                                crate::cst::data_structure::RightOperand,
                                                tymetafuncspec_core::Maybe<
                                                    crate::cst::data_structure::Heap,
                                                    std_parse_metadata::ParseMetadata<
                                                        crate::cst::data_structure::Heap,
                                                    >,
                                                >,
                                            >,
                                            std_parse_error::ParseError<
                                                crate::cst::data_structure::Heap,
                                            >,
                                        >,
                                    );
                                }
                            }
                        }
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod set {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub either:
                                crate::cst::data_structure::heap::either::pair::set::either::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod either {
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[derive(Default)]
                            pub struct Bak {
                                pub nat: crate::cst::data_structure::heap::either::pair::set::either::nat::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            pub mod nat {
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub parse_error: crate::cst::data_structure::heap::either::pair::set::either::nat::parse_error::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                pub mod parse_error {
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[derive(Default)]
                                    pub struct Bak {
                                        pub maybe: crate::cst::data_structure::heap::either::pair::set::either::nat::parse_error::maybe::Bak,
                                    }
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    pub mod maybe {
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        #[derive(Default)]
                                        pub struct Bak {
                                            pub parse_metadata: crate::cst::data_structure::heap::either::pair::set::either::nat::parse_error::maybe::parse_metadata::Bak,
                                        }
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        pub mod parse_metadata {
                                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                            #[derive(Default)]
                                            pub struct Bak {
                                                pub parse_error: crate::cst::data_structure::heap::either::pair::set::either::nat::parse_error::maybe::parse_metadata::parse_error::Bak,
                                            }
                                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                            pub mod parse_error {
                                                /// generated by [term_specialized_gen::gen_heapbak_module]
                                                #[derive(Default)]
                                                pub struct Bak(
                                                    pub tymetafuncspec_core::EitherHeapBak<
                                                        crate::cst::data_structure::Heap,
                                                        tymetafuncspec_core::Pair<
                                                            crate::cst::data_structure::Heap,
                                                            tymetafuncspec_core::Set<
                                                                crate::cst::data_structure::Heap,
                                                                tymetafuncspec_core::Either<
                                                                    crate::cst::data_structure::Heap,
                                                                    crate::cst::data_structure::Nat,
                                                                    std_parse_error::ParseError<
                                                                        crate::cst::data_structure::Heap,
                                                                    >,
                                                                >,
                                                            >,
                                                            tymetafuncspec_core::Maybe<
                                                                crate::cst::data_structure::Heap,
                                                                std_parse_metadata::ParseMetadata<
                                                                    crate::cst::data_structure::Heap,
                                                                >,
                                                            >,
                                                        >,
                                                        std_parse_error::ParseError<
                                                            crate::cst::data_structure::Heap,
                                                        >,
                                                    >,
                                                );
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod parse_error {
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[derive(Default)]
                pub struct Bak(
                    pub std_parse_error::ParseErrorBak<crate::cst::data_structure::Heap>,
                );
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod pair {
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[derive(Default)]
                pub struct Bak {
                    pub left_operand: crate::cst::data_structure::heap::pair::left_operand::Bak,
                    pub right_operand: crate::cst::data_structure::heap::pair::right_operand::Bak,
                    pub set: crate::cst::data_structure::heap::pair::set::Bak,
                    pub nat_lit: crate::cst::data_structure::heap::pair::nat_lit::Bak,
                    pub idx_box: crate::cst::data_structure::heap::pair::idx_box::Bak,
                    pub f: crate::cst::data_structure::heap::pair::f::Bak,
                    pub plus: crate::cst::data_structure::heap::pair::plus::Bak,
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod left_operand {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub maybe: crate::cst::data_structure::heap::pair::left_operand::maybe::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod maybe {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub parse_metadata: crate::cst::data_structure::heap::pair::left_operand::maybe::parse_metadata::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod parse_metadata {
                            /// generated by [term_specialized_gen::gen_heapbak_module]
                            #[derive(Default)]
                            pub struct Bak(
                                pub  tymetafuncspec_core::PairHeapBak<
                                    crate::cst::data_structure::Heap,
                                    crate::cst::data_structure::LeftOperand,
                                    tymetafuncspec_core::Maybe<
                                        crate::cst::data_structure::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            crate::cst::data_structure::Heap,
                                        >,
                                    >,
                                >,
                            );
                        }
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod right_operand {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub maybe:
                            crate::cst::data_structure::heap::pair::right_operand::maybe::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod maybe {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub parse_metadata: crate::cst::data_structure::heap::pair::right_operand::maybe::parse_metadata::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod parse_metadata {
                            /// generated by [term_specialized_gen::gen_heapbak_module]
                            #[derive(Default)]
                            pub struct Bak(
                                pub  tymetafuncspec_core::PairHeapBak<
                                    crate::cst::data_structure::Heap,
                                    crate::cst::data_structure::RightOperand,
                                    tymetafuncspec_core::Maybe<
                                        crate::cst::data_structure::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            crate::cst::data_structure::Heap,
                                        >,
                                    >,
                                >,
                            );
                        }
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod set {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub either: crate::cst::data_structure::heap::pair::set::either::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod either {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub nat: crate::cst::data_structure::heap::pair::set::either::nat::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod nat {
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[derive(Default)]
                            pub struct Bak {
                                pub parse_error: crate::cst::data_structure::heap::pair::set::either::nat::parse_error::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            pub mod parse_error {
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub maybe: crate::cst::data_structure::heap::pair::set::either::nat::parse_error::maybe::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                pub mod maybe {
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[derive(Default)]
                                    pub struct Bak {
                                        pub parse_metadata: crate::cst::data_structure::heap::pair::set::either::nat::parse_error::maybe::parse_metadata::Bak,
                                    }
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    pub mod parse_metadata {
                                        /// generated by [term_specialized_gen::gen_heapbak_module]
                                        #[derive(Default)]
                                        pub struct Bak(
                                            pub  tymetafuncspec_core::PairHeapBak<
                                                crate::cst::data_structure::Heap,
                                                tymetafuncspec_core::Set<
                                                    crate::cst::data_structure::Heap,
                                                    tymetafuncspec_core::Either<
                                                        crate::cst::data_structure::Heap,
                                                        crate::cst::data_structure::Nat,
                                                        std_parse_error::ParseError<
                                                            crate::cst::data_structure::Heap,
                                                        >,
                                                    >,
                                                >,
                                                tymetafuncspec_core::Maybe<
                                                    crate::cst::data_structure::Heap,
                                                    std_parse_metadata::ParseMetadata<
                                                        crate::cst::data_structure::Heap,
                                                    >,
                                                >,
                                            >,
                                        );
                                    }
                                }
                            }
                        }
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod nat_lit {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub maybe: crate::cst::data_structure::heap::pair::nat_lit::maybe::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod maybe {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub parse_metadata: crate::cst::data_structure::heap::pair::nat_lit::maybe::parse_metadata::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod parse_metadata {
                            /// generated by [term_specialized_gen::gen_heapbak_module]
                            #[derive(Default)]
                            pub struct Bak(
                                pub  tymetafuncspec_core::PairHeapBak<
                                    crate::cst::data_structure::Heap,
                                    tymetafuncspec_core::BoundedNat<
                                        crate::cst::data_structure::Heap,
                                    >,
                                    tymetafuncspec_core::Maybe<
                                        crate::cst::data_structure::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            crate::cst::data_structure::Heap,
                                        >,
                                    >,
                                >,
                            );
                        }
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod idx_box {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub pair: crate::cst::data_structure::heap::pair::idx_box::pair::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod pair {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub f: crate::cst::data_structure::heap::pair::idx_box::pair::f::Bak,
                            pub plus:
                                crate::cst::data_structure::heap::pair::idx_box::pair::plus::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod f {
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[derive(Default)]
                            pub struct Bak {
                                pub maybe: crate::cst::data_structure::heap::pair::idx_box::pair::f::maybe::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            pub mod maybe {
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub parse_metadata: crate::cst::data_structure::heap::pair::idx_box::pair::f::maybe::parse_metadata::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                pub mod parse_metadata {
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[derive(Default)]
                                    pub struct Bak {
                                        pub maybe: crate::cst::data_structure::heap::pair::idx_box::pair::f::maybe::parse_metadata::maybe::Bak,
                                    }
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    pub mod maybe {
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        #[derive(Default)]
                                        pub struct Bak {
                                            pub parse_metadata: crate::cst::data_structure::heap::pair::idx_box::pair::f::maybe::parse_metadata::maybe::parse_metadata::Bak,
                                        }
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        pub mod parse_metadata {
                                            /// generated by [term_specialized_gen::gen_heapbak_module]
                                            #[derive(Default)]
                                            pub struct Bak(
                                                pub tymetafuncspec_core::PairHeapBak<
                                                    crate::cst::data_structure::Heap,
                                                    tymetafuncspec_core::IdxBox<
                                                        crate::cst::data_structure::Heap,
                                                        tymetafuncspec_core::Pair<
                                                            crate::cst::data_structure::Heap,
                                                            crate::cst::data_structure::F,
                                                            tymetafuncspec_core::Maybe<
                                                                crate::cst::data_structure::Heap,
                                                                std_parse_metadata::ParseMetadata<
                                                                    crate::cst::data_structure::Heap,
                                                                >,
                                                            >,
                                                        >,
                                                    >,
                                                    tymetafuncspec_core::Maybe<
                                                        crate::cst::data_structure::Heap,
                                                        std_parse_metadata::ParseMetadata<
                                                            crate::cst::data_structure::Heap,
                                                        >,
                                                    >,
                                                >,
                                            );
                                        }
                                    }
                                }
                            }
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod plus {
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[derive(Default)]
                            pub struct Bak {
                                pub maybe: crate::cst::data_structure::heap::pair::idx_box::pair::plus::maybe::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            pub mod maybe {
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                #[derive(Default)]
                                pub struct Bak {
                                    pub parse_metadata: crate::cst::data_structure::heap::pair::idx_box::pair::plus::maybe::parse_metadata::Bak,
                                }
                                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                pub mod parse_metadata {
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    #[derive(Default)]
                                    pub struct Bak {
                                        pub maybe: crate::cst::data_structure::heap::pair::idx_box::pair::plus::maybe::parse_metadata::maybe::Bak,
                                    }
                                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                    pub mod maybe {
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        #[derive(Default)]
                                        pub struct Bak {
                                            pub parse_metadata: crate::cst::data_structure::heap::pair::idx_box::pair::plus::maybe::parse_metadata::maybe::parse_metadata::Bak,
                                        }
                                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                                        pub mod parse_metadata {
                                            /// generated by [term_specialized_gen::gen_heapbak_module]
                                            #[derive(Default)]
                                            pub struct Bak(
                                                pub tymetafuncspec_core::PairHeapBak<
                                                    crate::cst::data_structure::Heap,
                                                    tymetafuncspec_core::IdxBox<
                                                        crate::cst::data_structure::Heap,
                                                        tymetafuncspec_core::Pair<
                                                            crate::cst::data_structure::Heap,
                                                            crate::cst::data_structure::Plus,
                                                            tymetafuncspec_core::Maybe<
                                                                crate::cst::data_structure::Heap,
                                                                std_parse_metadata::ParseMetadata<
                                                                    crate::cst::data_structure::Heap,
                                                                >,
                                                            >,
                                                        >,
                                                    >,
                                                    tymetafuncspec_core::Maybe<
                                                        crate::cst::data_structure::Heap,
                                                        std_parse_metadata::ParseMetadata<
                                                            crate::cst::data_structure::Heap,
                                                        >,
                                                    >,
                                                >,
                                            );
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod f {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub maybe: crate::cst::data_structure::heap::pair::f::maybe::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod maybe {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub parse_metadata: crate::cst::data_structure::heap::pair::f::maybe::parse_metadata::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod parse_metadata {
                            /// generated by [term_specialized_gen::gen_heapbak_module]
                            #[derive(Default)]
                            pub struct Bak(
                                pub  tymetafuncspec_core::PairHeapBak<
                                    crate::cst::data_structure::Heap,
                                    crate::cst::data_structure::F,
                                    tymetafuncspec_core::Maybe<
                                        crate::cst::data_structure::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            crate::cst::data_structure::Heap,
                                        >,
                                    >,
                                >,
                            );
                        }
                    }
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod plus {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub maybe: crate::cst::data_structure::heap::pair::plus::maybe::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod maybe {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub parse_metadata: crate::cst::data_structure::heap::pair::plus::maybe::parse_metadata::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod parse_metadata {
                            /// generated by [term_specialized_gen::gen_heapbak_module]
                            #[derive(Default)]
                            pub struct Bak(
                                pub  tymetafuncspec_core::PairHeapBak<
                                    crate::cst::data_structure::Heap,
                                    crate::cst::data_structure::Plus,
                                    tymetafuncspec_core::Maybe<
                                        crate::cst::data_structure::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            crate::cst::data_structure::Heap,
                                        >,
                                    >,
                                >,
                            );
                        }
                    }
                }
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod maybe {
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[derive(Default)]
                pub struct Bak {
                    pub parse_metadata:
                        crate::cst::data_structure::heap::maybe::parse_metadata::Bak,
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod parse_metadata {
                    /// generated by [term_specialized_gen::gen_heapbak_module]
                    #[derive(Default)]
                    pub struct Bak(
                        pub  tymetafuncspec_core::MaybeHeapBak<
                            crate::cst::data_structure::Heap,
                            std_parse_metadata::ParseMetadata<crate::cst::data_structure::Heap>,
                        >,
                    );
                }
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod parse_metadata {
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[derive(Default)]
                pub struct Bak(
                    pub std_parse_metadata::ParseMetadataBak<crate::cst::data_structure::Heap>,
                );
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod set {
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[derive(Default)]
                pub struct Bak {
                    pub either: crate::cst::data_structure::heap::set::either::Bak,
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod either {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub nat: crate::cst::data_structure::heap::set::either::nat::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod nat {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub parse_error: crate::cst::data_structure::heap::set::either::nat::parse_error::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod parse_error {
                            /// generated by [term_specialized_gen::gen_heapbak_module]
                            #[derive(Default)]
                            pub struct Bak(
                                pub  tymetafuncspec_core::SetHeapBak<
                                    crate::cst::data_structure::Heap,
                                    tymetafuncspec_core::Either<
                                        crate::cst::data_structure::Heap,
                                        crate::cst::data_structure::Nat,
                                        std_parse_error::ParseError<
                                            crate::cst::data_structure::Heap,
                                        >,
                                    >,
                                >,
                            );
                        }
                    }
                }
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod nat_lit {
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[derive(Default)]
                pub struct Bak(
                    pub tymetafuncspec_core::BoundedNatHeapBak<crate::cst::data_structure::Heap>,
                );
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod idx_box {
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                #[derive(Default)]
                pub struct Bak {
                    pub pair: crate::cst::data_structure::heap::idx_box::pair::Bak,
                }
                /// generated by [term_specialized_gen::gen_modules_with_prefix]
                pub mod pair {
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    #[derive(Default)]
                    pub struct Bak {
                        pub f: crate::cst::data_structure::heap::idx_box::pair::f::Bak,
                        pub plus: crate::cst::data_structure::heap::idx_box::pair::plus::Bak,
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod f {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub maybe:
                                crate::cst::data_structure::heap::idx_box::pair::f::maybe::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod maybe {
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[derive(Default)]
                            pub struct Bak {
                                pub parse_metadata: crate::cst::data_structure::heap::idx_box::pair::f::maybe::parse_metadata::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            pub mod parse_metadata {
                                /// generated by [term_specialized_gen::gen_heapbak_module]
                                #[derive(Default)]
                                pub struct Bak(
                                    pub  tymetafuncspec_core::IdxBoxHeapBak<
                                        crate::cst::data_structure::Heap,
                                        tymetafuncspec_core::Pair<
                                            crate::cst::data_structure::Heap,
                                            crate::cst::data_structure::F,
                                            tymetafuncspec_core::Maybe<
                                                crate::cst::data_structure::Heap,
                                                std_parse_metadata::ParseMetadata<
                                                    crate::cst::data_structure::Heap,
                                                >,
                                            >,
                                        >,
                                    >,
                                );
                            }
                        }
                    }
                    /// generated by [term_specialized_gen::gen_modules_with_prefix]
                    pub mod plus {
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        #[derive(Default)]
                        pub struct Bak {
                            pub maybe:
                                crate::cst::data_structure::heap::idx_box::pair::plus::maybe::Bak,
                        }
                        /// generated by [term_specialized_gen::gen_modules_with_prefix]
                        pub mod maybe {
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            #[derive(Default)]
                            pub struct Bak {
                                pub parse_metadata: crate::cst::data_structure::heap::idx_box::pair::plus::maybe::parse_metadata::Bak,
                            }
                            /// generated by [term_specialized_gen::gen_modules_with_prefix]
                            pub mod parse_metadata {
                                /// generated by [term_specialized_gen::gen_heapbak_module]
                                #[derive(Default)]
                                pub struct Bak(
                                    pub  tymetafuncspec_core::IdxBoxHeapBak<
                                        crate::cst::data_structure::Heap,
                                        tymetafuncspec_core::Pair<
                                            crate::cst::data_structure::Heap,
                                            crate::cst::data_structure::Plus,
                                            tymetafuncspec_core::Maybe<
                                                crate::cst::data_structure::Heap,
                                                std_parse_metadata::ParseMetadata<
                                                    crate::cst::data_structure::Heap,
                                                >,
                                            >,
                                        >,
                                    >,
                                );
                            }
                        }
                    }
                }
            }
        }
        pub mod superheap {
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::EitherHeapBak <
                crate ::cst::data_structure::Heap, crate ::cst::data_structure::Nat,
                std_parse_error::ParseError < crate ::cst::data_structure::Heap, > >;
                either nat parse_error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; std_parse_error::ParseErrorBak < crate
                ::cst::data_structure::Heap, >; parse_error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::EitherHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::LeftOperand,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >
                >; either pair left_operand maybe parse_metadata parse_error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::PairHeapBak <
                crate ::cst::data_structure::Heap, crate
                ::cst::data_structure::LeftOperand, tymetafuncspec_core::Maybe < crate
                ::cst::data_structure::Heap, std_parse_metadata::ParseMetadata < crate
                ::cst::data_structure::Heap, >, > >; pair left_operand maybe
                parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::MaybeHeapBak <
                crate ::cst::data_structure::Heap, std_parse_metadata::ParseMetadata <
                crate ::cst::data_structure::Heap, > >; maybe parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; std_parse_metadata::ParseMetadataBak <
                crate ::cst::data_structure::Heap, >; parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::EitherHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::RightOperand,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >
                >; either pair right_operand maybe parse_metadata parse_error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::PairHeapBak <
                crate ::cst::data_structure::Heap, crate
                ::cst::data_structure::RightOperand, tymetafuncspec_core::Maybe < crate
                ::cst::data_structure::Heap, std_parse_metadata::ParseMetadata < crate
                ::cst::data_structure::Heap, >, > >; pair right_operand maybe
                parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::EitherHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Set < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Nat,
                std_parse_error::ParseError < crate ::cst::data_structure::Heap, >, >, >,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, std_parse_error::ParseError < crate ::cst::data_structure::Heap, >
                >; either pair set either nat parse_error maybe parse_metadata
                parse_error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::PairHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Set < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Nat,
                std_parse_error::ParseError < crate ::cst::data_structure::Heap, >, >, >,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                > >; pair set either nat parse_error maybe parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::SetHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Either < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Nat,
                std_parse_error::ParseError < crate ::cst::data_structure::Heap, >, > >;
                set either nat parse_error
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::PairHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::BoundedNat <
                crate ::cst::data_structure::Heap, >, tymetafuncspec_core::Maybe < crate
                ::cst::data_structure::Heap, std_parse_metadata::ParseMetadata < crate
                ::cst::data_structure::Heap, >, > >; pair nat_lit maybe parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::BoundedNatHeapBak
                < crate ::cst::data_structure::Heap, >; nat_lit
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::PairHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::F,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, >, tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                > >; pair idx_box pair f maybe parse_metadata maybe parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::IdxBoxHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::F,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, > >; idx_box pair f maybe parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::PairHeapBak <
                crate ::cst::data_structure::Heap, crate ::cst::data_structure::F,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                > >; pair f maybe parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::PairHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
                ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Plus,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, >, >, tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                > >; pair idx_box pair plus maybe parse_metadata maybe parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::IdxBoxHeapBak <
                crate ::cst::data_structure::Heap, tymetafuncspec_core::Pair < crate
                ::cst::data_structure::Heap, crate ::cst::data_structure::Plus,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                >, > >; idx_box pair plus maybe parse_metadata
            );
            term::impl_superheap!(
                crate ::cst::data_structure::Heap; tymetafuncspec_core::PairHeapBak <
                crate ::cst::data_structure::Heap, crate ::cst::data_structure::Plus,
                tymetafuncspec_core::Maybe < crate ::cst::data_structure::Heap,
                std_parse_metadata::ParseMetadata < crate ::cst::data_structure::Heap, >,
                > >; pair plus maybe parse_metadata
            );
        }
        #[derive(Clone, Copy)]
        pub struct F {
            pub nat: tymetafuncspec_core::Either<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::Nat,
                std_parse_error::ParseError<crate::cst::data_structure::Heap>,
            >,
        }
        #[derive(Clone, Copy)]
        pub struct Plus {
            pub left_operand: tymetafuncspec_core::Either<
                crate::cst::data_structure::Heap,
                tymetafuncspec_core::Pair<
                    crate::cst::data_structure::Heap,
                    crate::cst::data_structure::LeftOperand,
                    tymetafuncspec_core::Maybe<
                        crate::cst::data_structure::Heap,
                        std_parse_metadata::ParseMetadata<crate::cst::data_structure::Heap>,
                    >,
                >,
                std_parse_error::ParseError<crate::cst::data_structure::Heap>,
            >,
            pub right_operand: tymetafuncspec_core::Either<
                crate::cst::data_structure::Heap,
                tymetafuncspec_core::Pair<
                    crate::cst::data_structure::Heap,
                    crate::cst::data_structure::RightOperand,
                    tymetafuncspec_core::Maybe<
                        crate::cst::data_structure::Heap,
                        std_parse_metadata::ParseMetadata<crate::cst::data_structure::Heap>,
                    >,
                >,
                std_parse_error::ParseError<crate::cst::data_structure::Heap>,
            >,
        }
        #[derive(Clone, Copy)]
        pub struct LeftOperand {
            pub nat: tymetafuncspec_core::Either<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::Nat,
                std_parse_error::ParseError<crate::cst::data_structure::Heap>,
            >,
        }
        #[derive(Clone, Copy)]
        pub struct RightOperand {
            pub nat: tymetafuncspec_core::Either<
                crate::cst::data_structure::Heap,
                crate::cst::data_structure::Nat,
                std_parse_error::ParseError<crate::cst::data_structure::Heap>,
            >,
        }
        #[derive(Clone, Copy)]
        pub struct Sum {
            pub set: tymetafuncspec_core::Either<
                crate::cst::data_structure::Heap,
                tymetafuncspec_core::Pair<
                    crate::cst::data_structure::Heap,
                    tymetafuncspec_core::Set<
                        crate::cst::data_structure::Heap,
                        tymetafuncspec_core::Either<
                            crate::cst::data_structure::Heap,
                            crate::cst::data_structure::Nat,
                            std_parse_error::ParseError<crate::cst::data_structure::Heap>,
                        >,
                    >,
                    tymetafuncspec_core::Maybe<
                        crate::cst::data_structure::Heap,
                        std_parse_metadata::ParseMetadata<crate::cst::data_structure::Heap>,
                    >,
                >,
                std_parse_error::ParseError<crate::cst::data_structure::Heap>,
            >,
        }
        #[derive(Clone, Copy)]
        pub enum Nat {
            NatLit(
                tymetafuncspec_core::Pair<
                    crate::cst::data_structure::Heap,
                    tymetafuncspec_core::BoundedNat<crate::cst::data_structure::Heap>,
                    tymetafuncspec_core::Maybe<
                        crate::cst::data_structure::Heap,
                        std_parse_metadata::ParseMetadata<crate::cst::data_structure::Heap>,
                    >,
                >,
            ),
            F(
                tymetafuncspec_core::Pair<
                    crate::cst::data_structure::Heap,
                    tymetafuncspec_core::IdxBox<
                        crate::cst::data_structure::Heap,
                        tymetafuncspec_core::Pair<
                            crate::cst::data_structure::Heap,
                            crate::cst::data_structure::F,
                            tymetafuncspec_core::Maybe<
                                crate::cst::data_structure::Heap,
                                std_parse_metadata::ParseMetadata<crate::cst::data_structure::Heap>,
                            >,
                        >,
                    >,
                    tymetafuncspec_core::Maybe<
                        crate::cst::data_structure::Heap,
                        std_parse_metadata::ParseMetadata<crate::cst::data_structure::Heap>,
                    >,
                >,
            ),
            Plus(
                tymetafuncspec_core::Pair<
                    crate::cst::data_structure::Heap,
                    tymetafuncspec_core::IdxBox<
                        crate::cst::data_structure::Heap,
                        tymetafuncspec_core::Pair<
                            crate::cst::data_structure::Heap,
                            crate::cst::data_structure::Plus,
                            tymetafuncspec_core::Maybe<
                                crate::cst::data_structure::Heap,
                                std_parse_metadata::ParseMetadata<crate::cst::data_structure::Heap>,
                            >,
                        >,
                    >,
                    tymetafuncspec_core::Maybe<
                        crate::cst::data_structure::Heap,
                        std_parse_metadata::ParseMetadata<crate::cst::data_structure::Heap>,
                    >,
                >,
            ),
        }
        /// generated by [term_specialized_gen::gen_heaped_impls]
        pub mod heaped {
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::data_structure::F {
                type Heap = crate::cst::data_structure::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::data_structure::Plus {
                type Heap = crate::cst::data_structure::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::data_structure::LeftOperand {
                type Heap = crate::cst::data_structure::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::data_structure::RightOperand {
                type Heap = crate::cst::data_structure::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::data_structure::Sum {
                type Heap = crate::cst::data_structure::Heap;
            }
            /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
            impl term::Heaped for crate::cst::data_structure::Nat {
                type Heap = crate::cst::data_structure::Heap;
            }
        }
    }
    /// generated by [term_trait_gen::generate]
    pub mod extension_of {
        /// generated by [term_trait_gen::heap_trait]
        pub trait Heap:
            term::SuperHeap<
                tymetafuncspec_core::EitherHeapBak<
                    Self,
                    Self::Nat,
                    std_parse_error::ParseError<Self>,
                >,
            > + term::SuperHeap<std_parse_error::ParseErrorBak<Self>>
            + term::SuperHeap<
                tymetafuncspec_core::EitherHeapBak<
                    Self,
                    tymetafuncspec_core::Pair<
                        Self,
                        Self::LeftOperand,
                        tymetafuncspec_core::Maybe<Self, std_parse_metadata::ParseMetadata<Self>>,
                    >,
                    std_parse_error::ParseError<Self>,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::PairHeapBak<
                    Self,
                    Self::LeftOperand,
                    tymetafuncspec_core::Maybe<Self, std_parse_metadata::ParseMetadata<Self>>,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::MaybeHeapBak<Self, std_parse_metadata::ParseMetadata<Self>>,
            > + term::SuperHeap<std_parse_metadata::ParseMetadataBak<Self>>
            + term::SuperHeap<
                tymetafuncspec_core::EitherHeapBak<
                    Self,
                    tymetafuncspec_core::Pair<
                        Self,
                        Self::RightOperand,
                        tymetafuncspec_core::Maybe<Self, std_parse_metadata::ParseMetadata<Self>>,
                    >,
                    std_parse_error::ParseError<Self>,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::PairHeapBak<
                    Self,
                    Self::RightOperand,
                    tymetafuncspec_core::Maybe<Self, std_parse_metadata::ParseMetadata<Self>>,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::EitherHeapBak<
                    Self,
                    tymetafuncspec_core::Pair<
                        Self,
                        tymetafuncspec_core::Set<
                            Self,
                            tymetafuncspec_core::Either<
                                Self,
                                Self::Nat,
                                std_parse_error::ParseError<Self>,
                            >,
                        >,
                        tymetafuncspec_core::Maybe<Self, std_parse_metadata::ParseMetadata<Self>>,
                    >,
                    std_parse_error::ParseError<Self>,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::PairHeapBak<
                    Self,
                    tymetafuncspec_core::Set<
                        Self,
                        tymetafuncspec_core::Either<
                            Self,
                            Self::Nat,
                            std_parse_error::ParseError<Self>,
                        >,
                    >,
                    tymetafuncspec_core::Maybe<Self, std_parse_metadata::ParseMetadata<Self>>,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::SetHeapBak<
                    Self,
                    tymetafuncspec_core::Either<Self, Self::Nat, std_parse_error::ParseError<Self>>,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::PairHeapBak<
                    Self,
                    tymetafuncspec_core::BoundedNat<Self>,
                    tymetafuncspec_core::Maybe<Self, std_parse_metadata::ParseMetadata<Self>>,
                >,
            > + term::SuperHeap<tymetafuncspec_core::BoundedNatHeapBak<Self>>
            + term::SuperHeap<
                tymetafuncspec_core::PairHeapBak<
                    Self,
                    tymetafuncspec_core::IdxBox<
                        Self,
                        tymetafuncspec_core::Pair<
                            Self,
                            Self::F,
                            tymetafuncspec_core::Maybe<
                                Self,
                                std_parse_metadata::ParseMetadata<Self>,
                            >,
                        >,
                    >,
                    tymetafuncspec_core::Maybe<Self, std_parse_metadata::ParseMetadata<Self>>,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::IdxBoxHeapBak<
                    Self,
                    tymetafuncspec_core::Pair<
                        Self,
                        Self::F,
                        tymetafuncspec_core::Maybe<Self, std_parse_metadata::ParseMetadata<Self>>,
                    >,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::PairHeapBak<
                    Self,
                    Self::F,
                    tymetafuncspec_core::Maybe<Self, std_parse_metadata::ParseMetadata<Self>>,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::PairHeapBak<
                    Self,
                    tymetafuncspec_core::IdxBox<
                        Self,
                        tymetafuncspec_core::Pair<
                            Self,
                            Self::Plus,
                            tymetafuncspec_core::Maybe<
                                Self,
                                std_parse_metadata::ParseMetadata<Self>,
                            >,
                        >,
                    >,
                    tymetafuncspec_core::Maybe<Self, std_parse_metadata::ParseMetadata<Self>>,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::IdxBoxHeapBak<
                    Self,
                    tymetafuncspec_core::Pair<
                        Self,
                        Self::Plus,
                        tymetafuncspec_core::Maybe<Self, std_parse_metadata::ParseMetadata<Self>>,
                    >,
                >,
            > + term::SuperHeap<
                tymetafuncspec_core::PairHeapBak<
                    Self,
                    Self::Plus,
                    tymetafuncspec_core::Maybe<Self, std_parse_metadata::ParseMetadata<Self>>,
                >,
            > + Sized
        {
            type F: crate::cst::extension_of::owned::F<Heap = Self>;
            type Plus: crate::cst::extension_of::owned::Plus<Heap = Self>;
            type LeftOperand: crate::cst::extension_of::owned::LeftOperand<Heap = Self>;
            type RightOperand: crate::cst::extension_of::owned::RightOperand<Heap = Self>;
            type Sum: crate::cst::extension_of::owned::Sum<Heap = Self>;
            type Nat: crate::cst::extension_of::owned::Nat<Heap = Self>;
        }
        /// generated by [term_trait_gen::owned::generate]
        pub mod owned {
            pub trait F:
                term::Heaped
                + term::CanonicallyConstructibleFrom<(
                    tymetafuncspec_core::Either<
                        <Self as term::Heaped>::Heap,
                        <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Nat,
                        std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                    >,
                    (),
                )> where
                <Self as term::Heaped>::Heap: crate::cst::extension_of::Heap,
            {
            }
            pub trait Plus: term::Heaped + term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::Pair<
                                <Self as term::Heaped>::Heap,
                                <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::LeftOperand,
                                tymetafuncspec_core::Maybe<
                                    <Self as term::Heaped>::Heap,
                                    std_parse_metadata::ParseMetadata<
                                        <Self as term::Heaped>::Heap,
                                    >,
                                >,
                            >,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                        (
                            tymetafuncspec_core::Either<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Pair<
                                    <Self as term::Heaped>::Heap,
                                    <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::RightOperand,
                                    tymetafuncspec_core::Maybe<
                                        <Self as term::Heaped>::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            <Self as term::Heaped>::Heap,
                                        >,
                                    >,
                                >,
                                std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                            >,
                            (),
                        ),
                    ),
                >
            where
                <Self as term::Heaped>::Heap: crate::cst::extension_of::Heap,
            {}
            pub trait LeftOperand:
                term::Heaped
                + term::CanonicallyConstructibleFrom<(
                    tymetafuncspec_core::Either<
                        <Self as term::Heaped>::Heap,
                        <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Nat,
                        std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                    >,
                    (),
                )>
            where
                <Self as term::Heaped>::Heap: crate::cst::extension_of::Heap,
            {
            }
            pub trait RightOperand:
                term::Heaped
                + term::CanonicallyConstructibleFrom<(
                    tymetafuncspec_core::Either<
                        <Self as term::Heaped>::Heap,
                        <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Nat,
                        std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                    >,
                    (),
                )>
            where
                <Self as term::Heaped>::Heap: crate::cst::extension_of::Heap,
            {
            }
            pub trait Sum: term::Heaped + term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::Pair<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Set<
                                    <Self as term::Heaped>::Heap,
                                    tymetafuncspec_core::Either<
                                        <Self as term::Heaped>::Heap,
                                        <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Nat,
                                        std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                                    >,
                                >,
                                tymetafuncspec_core::Maybe<
                                    <Self as term::Heaped>::Heap,
                                    std_parse_metadata::ParseMetadata<
                                        <Self as term::Heaped>::Heap,
                                    >,
                                >,
                            >,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                        (),
                    ),
                >
            where
                <Self as term::Heaped>::Heap: crate::cst::extension_of::Heap,
            {}
            pub trait Nat: term::Heaped + term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Pair<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::BoundedNat<
                                <Self as term::Heaped>::Heap,
                            >,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                std_parse_metadata::ParseMetadata<
                                    <Self as term::Heaped>::Heap,
                                >,
                            >,
                        >,
                        (),
                    ),
                > + term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Pair<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::IdxBox<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Pair<
                                    <Self as term::Heaped>::Heap,
                                    <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::F,
                                    tymetafuncspec_core::Maybe<
                                        <Self as term::Heaped>::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            <Self as term::Heaped>::Heap,
                                        >,
                                    >,
                                >,
                            >,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                std_parse_metadata::ParseMetadata<
                                    <Self as term::Heaped>::Heap,
                                >,
                            >,
                        >,
                        (),
                    ),
                > + term::CanonicallyConstructibleFrom<
                    (
                        tymetafuncspec_core::Pair<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::IdxBox<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Pair<
                                    <Self as term::Heaped>::Heap,
                                    <<Self as term::Heaped>::Heap as crate::cst::extension_of::Heap>::Plus,
                                    tymetafuncspec_core::Maybe<
                                        <Self as term::Heaped>::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            <Self as term::Heaped>::Heap,
                                        >,
                                    >,
                                >,
                            >,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                std_parse_metadata::ParseMetadata<
                                    <Self as term::Heaped>::Heap,
                                >,
                            >,
                        >,
                        (),
                    ),
                >
            where
                <Self as term::Heaped>::Heap: crate::cst::extension_of::Heap,
            {}
        }
        /// generated by [term_trait_gen::reference::generate]
        pub mod reference {}
    }
    /// generated by [term_specialized_impl_gen::generate]
    pub mod term_impls {
        /// generated by [term_specialized_impl_gen::gen_heap_impl]
        impl crate::cst::extension_of::Heap for crate::cst::data_structure::Heap {
            type F = crate::cst::data_structure::F;
            type Plus = crate::cst::data_structure::Plus;
            type LeftOperand = crate::cst::data_structure::LeftOperand;
            type RightOperand = crate::cst::data_structure::RightOperand;
            type Sum = crate::cst::data_structure::Sum;
            type Nat = crate::cst::data_structure::Nat;
        }
        /// generated by [term_specialized_impl_gen::gen_owned_mod]
        pub mod owned_impls {
            impl crate::cst::extension_of::owned::F for crate::cst::data_structure::F {}
            impl crate::cst::extension_of::owned::Plus for crate::cst::data_structure::Plus {}
            impl crate::cst::extension_of::owned::LeftOperand for crate::cst::data_structure::LeftOperand {}
            impl crate::cst::extension_of::owned::RightOperand for crate::cst::data_structure::RightOperand {}
            impl crate::cst::extension_of::owned::Sum for crate::cst::data_structure::Sum {}
            impl crate::cst::extension_of::owned::Nat for crate::cst::data_structure::Nat {}
        }
        /// generated by [term_specialized_impl_gen::gen_ccf_mod]
        pub mod ccf_impls {
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod f {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                impl
                    term::CanonicallyConstructibleFrom<(
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Nat,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                        (),
                    )> for crate::cst::data_structure::F
                {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::Either<
                                <Self as term::Heaped>::Heap,
                                crate::cst::data_structure::Nat,
                                std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                            >,
                            (),
                        ),
                    ) -> Self {
                        crate::cst::data_structure::F { nat: t.0 }
                    }
                    fn deconstruct_succeeds(&self, heap: &Self::Heap) -> bool {
                        true
                    }
                    fn deconstruct(
                        self,
                        heap: &Self::Heap,
                    ) -> (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Nat,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                        (),
                    ) {
                        (self.nat, ())
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod plus {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                impl
                    term::CanonicallyConstructibleFrom<(
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::Pair<
                                <Self as term::Heaped>::Heap,
                                crate::cst::data_structure::LeftOperand,
                                tymetafuncspec_core::Maybe<
                                    <Self as term::Heaped>::Heap,
                                    std_parse_metadata::ParseMetadata<<Self as term::Heaped>::Heap>,
                                >,
                            >,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                        (
                            tymetafuncspec_core::Either<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Pair<
                                    <Self as term::Heaped>::Heap,
                                    crate::cst::data_structure::RightOperand,
                                    tymetafuncspec_core::Maybe<
                                        <Self as term::Heaped>::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            <Self as term::Heaped>::Heap,
                                        >,
                                    >,
                                >,
                                std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                            >,
                            (),
                        ),
                    )> for crate::cst::data_structure::Plus
                {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::Either<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Pair<
                                    <Self as term::Heaped>::Heap,
                                    crate::cst::data_structure::LeftOperand,
                                    tymetafuncspec_core::Maybe<
                                        <Self as term::Heaped>::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            <Self as term::Heaped>::Heap,
                                        >,
                                    >,
                                >,
                                std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                            >,
                            (
                                tymetafuncspec_core::Either<
                                    <Self as term::Heaped>::Heap,
                                    tymetafuncspec_core::Pair<
                                        <Self as term::Heaped>::Heap,
                                        crate::cst::data_structure::RightOperand,
                                        tymetafuncspec_core::Maybe<
                                            <Self as term::Heaped>::Heap,
                                            std_parse_metadata::ParseMetadata<
                                                <Self as term::Heaped>::Heap,
                                            >,
                                        >,
                                    >,
                                    std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                                >,
                                (),
                            ),
                        ),
                    ) -> Self {
                        crate::cst::data_structure::Plus {
                            left_operand: t.0,
                            right_operand: t.1 .0,
                        }
                    }
                    fn deconstruct_succeeds(&self, heap: &Self::Heap) -> bool {
                        true
                    }
                    fn deconstruct(
                        self,
                        heap: &Self::Heap,
                    ) -> (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::Pair<
                                <Self as term::Heaped>::Heap,
                                crate::cst::data_structure::LeftOperand,
                                tymetafuncspec_core::Maybe<
                                    <Self as term::Heaped>::Heap,
                                    std_parse_metadata::ParseMetadata<<Self as term::Heaped>::Heap>,
                                >,
                            >,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                        (
                            tymetafuncspec_core::Either<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Pair<
                                    <Self as term::Heaped>::Heap,
                                    crate::cst::data_structure::RightOperand,
                                    tymetafuncspec_core::Maybe<
                                        <Self as term::Heaped>::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            <Self as term::Heaped>::Heap,
                                        >,
                                    >,
                                >,
                                std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                            >,
                            (),
                        ),
                    ) {
                        (self.left_operand, (self.right_operand, ()))
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod left_operand {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                impl
                    term::CanonicallyConstructibleFrom<(
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Nat,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                        (),
                    )> for crate::cst::data_structure::LeftOperand
                {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::Either<
                                <Self as term::Heaped>::Heap,
                                crate::cst::data_structure::Nat,
                                std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                            >,
                            (),
                        ),
                    ) -> Self {
                        crate::cst::data_structure::LeftOperand { nat: t.0 }
                    }
                    fn deconstruct_succeeds(&self, heap: &Self::Heap) -> bool {
                        true
                    }
                    fn deconstruct(
                        self,
                        heap: &Self::Heap,
                    ) -> (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Nat,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                        (),
                    ) {
                        (self.nat, ())
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod right_operand {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                impl
                    term::CanonicallyConstructibleFrom<(
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Nat,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                        (),
                    )> for crate::cst::data_structure::RightOperand
                {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::Either<
                                <Self as term::Heaped>::Heap,
                                crate::cst::data_structure::Nat,
                                std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                            >,
                            (),
                        ),
                    ) -> Self {
                        crate::cst::data_structure::RightOperand { nat: t.0 }
                    }
                    fn deconstruct_succeeds(&self, heap: &Self::Heap) -> bool {
                        true
                    }
                    fn deconstruct(
                        self,
                        heap: &Self::Heap,
                    ) -> (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            crate::cst::data_structure::Nat,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                        (),
                    ) {
                        (self.nat, ())
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod sum {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
                impl
                    term::CanonicallyConstructibleFrom<(
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::Pair<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Set<
                                    <Self as term::Heaped>::Heap,
                                    tymetafuncspec_core::Either<
                                        <Self as term::Heaped>::Heap,
                                        crate::cst::data_structure::Nat,
                                        std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                                    >,
                                >,
                                tymetafuncspec_core::Maybe<
                                    <Self as term::Heaped>::Heap,
                                    std_parse_metadata::ParseMetadata<<Self as term::Heaped>::Heap>,
                                >,
                            >,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                        (),
                    )> for crate::cst::data_structure::Sum
                {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::Either<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Pair<
                                    <Self as term::Heaped>::Heap,
                                    tymetafuncspec_core::Set<
                                        <Self as term::Heaped>::Heap,
                                        tymetafuncspec_core::Either<
                                            <Self as term::Heaped>::Heap,
                                            crate::cst::data_structure::Nat,
                                            std_parse_error::ParseError<
                                                <Self as term::Heaped>::Heap,
                                            >,
                                        >,
                                    >,
                                    tymetafuncspec_core::Maybe<
                                        <Self as term::Heaped>::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            <Self as term::Heaped>::Heap,
                                        >,
                                    >,
                                >,
                                std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                            >,
                            (),
                        ),
                    ) -> Self {
                        crate::cst::data_structure::Sum { set: t.0 }
                    }
                    fn deconstruct_succeeds(&self, heap: &Self::Heap) -> bool {
                        true
                    }
                    fn deconstruct(
                        self,
                        heap: &Self::Heap,
                    ) -> (
                        tymetafuncspec_core::Either<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::Pair<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Set<
                                    <Self as term::Heaped>::Heap,
                                    tymetafuncspec_core::Either<
                                        <Self as term::Heaped>::Heap,
                                        crate::cst::data_structure::Nat,
                                        std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                                    >,
                                >,
                                tymetafuncspec_core::Maybe<
                                    <Self as term::Heaped>::Heap,
                                    std_parse_metadata::ParseMetadata<<Self as term::Heaped>::Heap>,
                                >,
                            >,
                            std_parse_error::ParseError<<Self as term::Heaped>::Heap>,
                        >,
                        (),
                    ) {
                        (self.set, ())
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impls]
            pub mod nat {
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
                impl
                    term::CanonicallyConstructibleFrom<(
                        tymetafuncspec_core::Pair<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                std_parse_metadata::ParseMetadata<<Self as term::Heaped>::Heap>,
                            >,
                        >,
                        (),
                    )> for crate::cst::data_structure::Nat
                {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::Pair<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>,
                                tymetafuncspec_core::Maybe<
                                    <Self as term::Heaped>::Heap,
                                    std_parse_metadata::ParseMetadata<<Self as term::Heaped>::Heap>,
                                >,
                            >,
                            (),
                        ),
                    ) -> Self {
                        crate::cst::data_structure::Nat::NatLit(t.0)
                    }
                    fn deconstruct_succeeds(&self, heap: &Self::Heap) -> bool {
                        match self {
                            crate::cst::data_structure::Nat::NatLit(_) => true,
                            _ => false,
                        }
                    }
                    fn deconstruct(
                        self,
                        heap: &Self::Heap,
                    ) -> (
                        tymetafuncspec_core::Pair<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                std_parse_metadata::ParseMetadata<<Self as term::Heaped>::Heap>,
                            >,
                        >,
                        (),
                    ) {
                        match self {
                            crate::cst::data_structure::Nat::NatLit(t) => (t, ()),
                            _ => panic!("conversion failure"),
                        }
                    }
                }
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
                impl
                    term::CanonicallyConstructibleFrom<(
                        tymetafuncspec_core::Pair<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::IdxBox<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Pair<
                                    <Self as term::Heaped>::Heap,
                                    crate::cst::data_structure::F,
                                    tymetafuncspec_core::Maybe<
                                        <Self as term::Heaped>::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            <Self as term::Heaped>::Heap,
                                        >,
                                    >,
                                >,
                            >,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                std_parse_metadata::ParseMetadata<<Self as term::Heaped>::Heap>,
                            >,
                        >,
                        (),
                    )> for crate::cst::data_structure::Nat
                {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::Pair<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::IdxBox<
                                    <Self as term::Heaped>::Heap,
                                    tymetafuncspec_core::Pair<
                                        <Self as term::Heaped>::Heap,
                                        crate::cst::data_structure::F,
                                        tymetafuncspec_core::Maybe<
                                            <Self as term::Heaped>::Heap,
                                            std_parse_metadata::ParseMetadata<
                                                <Self as term::Heaped>::Heap,
                                            >,
                                        >,
                                    >,
                                >,
                                tymetafuncspec_core::Maybe<
                                    <Self as term::Heaped>::Heap,
                                    std_parse_metadata::ParseMetadata<<Self as term::Heaped>::Heap>,
                                >,
                            >,
                            (),
                        ),
                    ) -> Self {
                        crate::cst::data_structure::Nat::F(t.0)
                    }
                    fn deconstruct_succeeds(&self, heap: &Self::Heap) -> bool {
                        match self {
                            crate::cst::data_structure::Nat::F(_) => true,
                            _ => false,
                        }
                    }
                    fn deconstruct(
                        self,
                        heap: &Self::Heap,
                    ) -> (
                        tymetafuncspec_core::Pair<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::IdxBox<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Pair<
                                    <Self as term::Heaped>::Heap,
                                    crate::cst::data_structure::F,
                                    tymetafuncspec_core::Maybe<
                                        <Self as term::Heaped>::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            <Self as term::Heaped>::Heap,
                                        >,
                                    >,
                                >,
                            >,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                std_parse_metadata::ParseMetadata<<Self as term::Heaped>::Heap>,
                            >,
                        >,
                        (),
                    ) {
                        match self {
                            crate::cst::data_structure::Nat::F(t) => (t, ()),
                            _ => panic!("conversion failure"),
                        }
                    }
                }
                /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
                impl
                    term::CanonicallyConstructibleFrom<(
                        tymetafuncspec_core::Pair<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::IdxBox<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Pair<
                                    <Self as term::Heaped>::Heap,
                                    crate::cst::data_structure::Plus,
                                    tymetafuncspec_core::Maybe<
                                        <Self as term::Heaped>::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            <Self as term::Heaped>::Heap,
                                        >,
                                    >,
                                >,
                            >,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                std_parse_metadata::ParseMetadata<<Self as term::Heaped>::Heap>,
                            >,
                        >,
                        (),
                    )> for crate::cst::data_structure::Nat
                {
                    fn construct(
                        heap: &mut Self::Heap,
                        t: (
                            tymetafuncspec_core::Pair<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::IdxBox<
                                    <Self as term::Heaped>::Heap,
                                    tymetafuncspec_core::Pair<
                                        <Self as term::Heaped>::Heap,
                                        crate::cst::data_structure::Plus,
                                        tymetafuncspec_core::Maybe<
                                            <Self as term::Heaped>::Heap,
                                            std_parse_metadata::ParseMetadata<
                                                <Self as term::Heaped>::Heap,
                                            >,
                                        >,
                                    >,
                                >,
                                tymetafuncspec_core::Maybe<
                                    <Self as term::Heaped>::Heap,
                                    std_parse_metadata::ParseMetadata<<Self as term::Heaped>::Heap>,
                                >,
                            >,
                            (),
                        ),
                    ) -> Self {
                        crate::cst::data_structure::Nat::Plus(t.0)
                    }
                    fn deconstruct_succeeds(&self, heap: &Self::Heap) -> bool {
                        match self {
                            crate::cst::data_structure::Nat::Plus(_) => true,
                            _ => false,
                        }
                    }
                    fn deconstruct(
                        self,
                        heap: &Self::Heap,
                    ) -> (
                        tymetafuncspec_core::Pair<
                            <Self as term::Heaped>::Heap,
                            tymetafuncspec_core::IdxBox<
                                <Self as term::Heaped>::Heap,
                                tymetafuncspec_core::Pair<
                                    <Self as term::Heaped>::Heap,
                                    crate::cst::data_structure::Plus,
                                    tymetafuncspec_core::Maybe<
                                        <Self as term::Heaped>::Heap,
                                        std_parse_metadata::ParseMetadata<
                                            <Self as term::Heaped>::Heap,
                                        >,
                                    >,
                                >,
                            >,
                            tymetafuncspec_core::Maybe<
                                <Self as term::Heaped>::Heap,
                                std_parse_metadata::ParseMetadata<<Self as term::Heaped>::Heap>,
                            >,
                        >,
                        (),
                    ) {
                        match self {
                            crate::cst::data_structure::Nat::Plus(t) => (t, ()),
                            _ => panic!("conversion failure"),
                        }
                    }
                }
            }
        }
        /// generated by [term_specialized_impl_gen::gen_mct_mod]
        pub mod mct_impls {}
    }
}
