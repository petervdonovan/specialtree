use langspec::tymetafunc::{RustTyMap, TyMetaFuncSpec};
use langspec::{
    langspec::{AlgebraicSortId, LangSpec, MappedType, SortId, SortIdOf},
    tymetafunc::TyMetaFuncData,
};

pub use proc_macro2;

#[macro_export]
macro_rules! byline {
    () => {{
        let ret: $crate::proc_macro2::TokenStream =
            format!("/// generated by [{}]", $crate::function!())
                .parse()
                .unwrap();
        ret
    }};
}
#[macro_export]
macro_rules! function {
    () => {{
        fn f() {}
        fn type_name_of<T>(_: T) -> &'static str {
            std::any::type_name::<T>()
        }
        let name = type_name_of(f);
        name.strip_suffix("::f")
            .unwrap()
            .trim_end_matches("::{{closure}}")
    }};
}
#[macro_export]
macro_rules! transpose {
    ($records:expr, $($field:ident),*) => {
        $(
            let mut $field = vec![];
        )*
        for record67142647 in $records {
            $(
                $field.push(record67142647.$field);
            )*
        }
        $(
            let $field = $field;
        )*
    };
}

pub struct TyGenData<'a, L: LangSpec> {
    pub id: Option<AlgebraicSortId<L::ProductId, L::SumId>>,
    pub snake_ident: syn::Ident,
    pub camel_ident: syn::Ident,
    pub cmt: CanonicallyMaybeToGenData<'a>,
    pub ccf: CanonicallyConstructibleFromGenData<'a>,
}
pub struct CanonicallyMaybeToGenData<'a> {
    pub cmt_sort_tys: Box<dyn Fn(HeapType, AlgebraicsBasePath) -> Vec<syn::Type> + 'a>,
    pub algebraic_cmt_sort_tys: Box<dyn Fn(HeapType, AlgebraicsBasePath) -> Vec<syn::Type> + 'a>,
}
// pub type TyRelPath2Ty<'a> = &'a dyn Fn(syn::Type, SortShape) -> syn::Type;
pub struct AlgebraicsBasePath(pub proc_macro2::TokenStream); // a prefix of a syn::TypePath
pub struct HeapType(pub syn::Type);
pub struct CanonicallyConstructibleFromGenData<'a> {
    pub ccf_sort_tys: Box<dyn Fn(HeapType, AlgebraicsBasePath) -> Vec<syn::Type> + 'a>,
}
pub struct AbstractedLsGen<'a, L: LangSpec> {
    pub bak: &'a L,
}
impl<L: LangSpec> AbstractedLsGen<'_, L> {
    pub fn ty_gen_datas(&self) -> impl Iterator<Item = TyGenData<'_, L>> {
        self.bak
            .products()
            .map(move |pid| TyGenData {
                id: Some(AlgebraicSortId::Product(pid.clone())),
                snake_ident: syn::Ident::new(
                    &self.bak.product_name(pid.clone()).snake.clone(),
                    proc_macro2::Span::call_site(),
                ),
                camel_ident: syn::Ident::new(
                    &self.bak.product_name(pid.clone()).camel.clone(),
                    proc_macro2::Span::call_site(),
                ),
                cmt: CanonicallyMaybeToGenData {
                    cmt_sort_tys: {
                        let pidc = pid.clone();
                        Box::new(move |ht, abp| {
                            self.bak
                                .product_sorts(pidc.clone())
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp))
                                .collect()
                        })
                    },
                    algebraic_cmt_sort_tys: {
                        let pidc = pid.clone();
                        Box::new(move |ht, abp| {
                            algebraics(self.bak.product_sorts(pidc.clone()))
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp))
                                .collect()
                        })
                    },
                },
                ccf: CanonicallyConstructibleFromGenData {
                    ccf_sort_tys: Box::new(move |ht, abp| {
                        let fields_tys = self
                            .bak
                            .product_sorts(pid.clone())
                            .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp));
                        vec![syn::parse_quote! {
                            (#( #fields_tys, )*)
                        }]
                    }),
                },
            })
            .chain(self.bak.sums().map(move |sid| TyGenData {
                id: Some(AlgebraicSortId::Sum(sid.clone())),
                snake_ident: syn::Ident::new(
                    &self.bak.sum_name(sid.clone()).snake.clone(),
                    proc_macro2::Span::call_site(),
                ),
                camel_ident: syn::Ident::new(
                    &self.bak.sum_name(sid.clone()).camel.clone(),
                    proc_macro2::Span::call_site(),
                ),
                cmt: CanonicallyMaybeToGenData {
                    cmt_sort_tys: {
                        let sidc = sid.clone();
                        Box::new(move |ht, abp| {
                            self.bak
                                .sum_sorts(sidc.clone())
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp))
                                .collect()
                        })
                    },
                    algebraic_cmt_sort_tys: {
                        let sidc = sid.clone();
                        Box::new(move |ht, abp| {
                            algebraics(self.bak.sum_sorts(sidc.clone()))
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp))
                                .collect()
                        })
                    },
                },
                ccf: CanonicallyConstructibleFromGenData {
                    ccf_sort_tys: Box::new(move |ht, abp| {
                        let fields_tys = self
                            .bak
                            .sum_sorts(sid.clone())
                            .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp));
                        vec![syn::parse_quote! {
                            (#( #fields_tys, )*)
                        }]
                    }),
                },
            }))
    }
    pub fn sort2rs_ty(
        &self,
        sort: SortIdOf<L>,
        ht: &HeapType,
        abp: &AlgebraicsBasePath,
    ) -> syn::Type {
        match sort {
            SortId::Algebraic(asi) => {
                let name = self.bak.algebraic_sort_name(asi);
                let ident = syn::Ident::new(&name.camel, proc_macro2::Span::call_site());
                let abp = &abp.0;
                syn::parse_quote! { #abp #ident }
            }
            SortId::TyMetaFunc(MappedType { f, a }) => {
                let TyMetaFuncData {
                    imp: RustTyMap { ty_func, args: _ },
                    ..
                } = L::Tmfs::ty_meta_func_data(&f);
                let args = a
                    .iter()
                    .map(|arg| self.sort2rs_ty(SortId::Algebraic(arg.clone()), ht, abp));
                let ht = &ht.0;
                syn::parse_quote! { #ty_func<#ht, #( #args, )* > }
            }
        }
    }
}

fn algebraics<
    ProductId: Clone + 'static,
    SumId: Clone + 'static,
    TyMetaFuncId: Clone + 'static,
    I: Iterator<Item = SortId<ProductId, SumId, TyMetaFuncId>>,
>(
    it: I,
) -> impl Iterator<Item = SortId<ProductId, SumId, TyMetaFuncId>> {
    it.flat_map(|sort| match &sort {
        SortId::Algebraic(_) => {
            Box::new(std::iter::once(sort.clone())) as Box<dyn Iterator<Item = _>>
        }
        SortId::TyMetaFunc(mapped_type) => {
            Box::new(mapped_type.a.clone().into_iter().map(SortId::Algebraic))
        }
    })
}
