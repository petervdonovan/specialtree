//! Utilities for Rust code generation
//!
//! This crate provides standalone utilities for generating Rust code,
//! extracted from langspec-gen-util to provide better organization
//! and reduced dependencies.

pub use proc_macro2;

/// Generates a byline comment indicating the generating function
#[macro_export]
macro_rules! byline {
    () => {{
        let ret: $crate::proc_macro2::TokenStream =
            format!("/// @generated by [{}]", $crate::function!())
                .parse()
                .unwrap();
        ret
    }};
}

/// Generates a kebab-case codegen ID based on the current function and language name
#[macro_export]
macro_rules! kebab_id {
    ($l:ident) => {
        codegen_component::KebabCodegenId({
            let func = $crate::function!();
            let id = if func.ends_with("::default") {
                let segment = func.split(":").next().unwrap();
                segment.strip_suffix("_gen").unwrap_or(segment)
            } else {
                func.split("::").last().unwrap()
            };
            format!(
                "{}-{}",
                id.replace("_", "-"),
                $l.name().kebab_str()
            )
        })
    };
}

/// Gets the current function name at compile time
#[macro_export]
macro_rules! function {
    () => {{
        fn f() {}
        fn type_name_of<T>(_: T) -> &'static str {
            std::any::type_name::<T>()
        }
        let name = type_name_of(f);
        name.strip_suffix("::f")
            .unwrap()
            .trim_end_matches("::{{closure}}")
    }};
}

/// Transposes a collection of records with named fields into separate vectors for each field
#[macro_export]
macro_rules! transpose {
    ($records:expr, $($field:ident),*) => {
        $(
            let mut $field = vec![];
        )*
        for record67142647 in $records {
            $(
                $field.push(record67142647.$field);
            )*
        }
        $(
            let $field = $field;
        )*
    };
}

/// Creates a cons list from an iterator of items
pub fn cons_list<T: quote::ToTokens + syn::parse::Parse>(it: impl Iterator<Item = T>) -> T {
    let mut ret = syn::parse_quote! { () };
    for item in it.collect::<Vec<_>>().into_iter().rev() {
        ret = syn::parse_quote! { (#item, #ret) };
    }
    ret
}

/// Generates a range of literal integers
pub fn number_range(n: usize) -> impl Iterator<Item = syn::LitInt> {
    (0..n).map(|i| syn::LitInt::new(&i.to_string(), proc_macro2::Span::call_site()))
}

/// Generates cons list index expressions for a range
pub fn cons_list_index_range(n: usize, expr: syn::Expr) -> impl Iterator<Item = syn::Expr> {
    (0..n).map(move |i| {
        let ones = (0..i).map(|_| quote::quote! {1});
        syn::parse_quote! {
            #expr #(. #ones)*.0
        }
    })
}

/// Generates all combinations from a vector of sequences
pub fn combinations<I: Clone + IntoIterator>(seqs: Vec<I>) -> impl Iterator<Item = Vec<I::Item>>
where
    I::Item: Clone,
{
    let mut iterators = vec![];
    for seq in seqs.iter() {
        iterators.push(seq.clone().into_iter());
    }
    let mut previous: Option<Vec<I::Item>> = None;
    std::iter::from_fn(move || match &mut previous {
        Some(value) => {
            for currently_incrementing_iterator in 0..iterators.len() {
                if let Some(next_value) = iterators[currently_incrementing_iterator].next() {
                    value[currently_incrementing_iterator] = next_value;
                    return Some(value.clone());
                } else {
                    iterators[currently_incrementing_iterator] =
                        seqs[currently_incrementing_iterator].clone().into_iter();
                    if let Some(next_value) = iterators[currently_incrementing_iterator].next() {
                        value[currently_incrementing_iterator] = next_value;
                    } else {
                        return None;
                    }
                }
            }
            None // All iterators are exhausted
        }
        None => {
            let mut new_value = vec![];
            for iterator in iterators.iter_mut() {
                if let Some(next_value) = iterator.next() {
                    new_value.push(next_value);
                } else {
                    return None;
                }
            }
            previous = Some(new_value.clone());
            Some(new_value)
        }
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_combinations() {
        let a = vec![2, 4, 6];
        let b = vec![3, 6, 9];
        let c = vec![5, 10, 15];
        let all: Vec<_> = combinations(vec![a, b, c]).collect();

        expect_test::expect!["27"].assert_eq(&all.len().to_string());
        // Verify we get all combinations
        expect_test::expect![[r#"
            [
                [
                    2,
                    3,
                    5,
                ],
                [
                    4,
                    3,
                    5,
                ],
                [
                    6,
                    3,
                    5,
                ],
                [
                    2,
                    6,
                    5,
                ],
                [
                    4,
                    6,
                    5,
                ],
                [
                    6,
                    6,
                    5,
                ],
                [
                    2,
                    9,
                    5,
                ],
                [
                    4,
                    9,
                    5,
                ],
                [
                    6,
                    9,
                    5,
                ],
                [
                    2,
                    3,
                    10,
                ],
                [
                    4,
                    3,
                    10,
                ],
                [
                    6,
                    3,
                    10,
                ],
                [
                    2,
                    6,
                    10,
                ],
                [
                    4,
                    6,
                    10,
                ],
                [
                    6,
                    6,
                    10,
                ],
                [
                    2,
                    9,
                    10,
                ],
                [
                    4,
                    9,
                    10,
                ],
                [
                    6,
                    9,
                    10,
                ],
                [
                    2,
                    3,
                    15,
                ],
                [
                    4,
                    3,
                    15,
                ],
                [
                    6,
                    3,
                    15,
                ],
                [
                    2,
                    6,
                    15,
                ],
                [
                    4,
                    6,
                    15,
                ],
                [
                    6,
                    6,
                    15,
                ],
                [
                    2,
                    9,
                    15,
                ],
                [
                    4,
                    9,
                    15,
                ],
                [
                    6,
                    9,
                    15,
                ],
            ]
        "#]].assert_debug_eq(&all);
    }

    #[test]
    fn test_cons_list() {
        let items = vec![
            syn::parse_quote! { u32 },
            syn::parse_quote! { String },
            syn::parse_quote! { bool },
        ];
        let result: syn::Type = cons_list(items.into_iter());

        expect_test::expect!["(u32 , (String , (bool , ())))"]
            .assert_eq(&quote::quote!(#result).to_string());
    }

    #[test]
    fn test_number_range() {
        let nums: Vec<_> = number_range(3)
            .map(|lit| lit.base10_digits().to_string())
            .collect();

        expect_test::expect![[r#"
            [
                "0",
                "1",
                "2",
            ]
        "#]]
        .assert_debug_eq(&nums);
    }

    #[test]
    fn test_cons_list_index_range() {
        let expr: syn::Expr = syn::parse_quote! { data };
        let indices: Vec<String> = cons_list_index_range(3, expr)
            .map(|expr| quote::quote!(#expr).to_string())
            .collect();

        expect_test::expect![[r#"
            [
                "data . 0",
                "data . 1 . 0",
                "data . 1 . 1 . 0",
            ]
        "#]]
        .assert_debug_eq(&indices);
    }

    #[test]
    fn test_function_macro() {
        fn test_fn() -> &'static str {
            function!()
        }
        let name = test_fn();
        expect_test::expect!["rustgen_utils::tests::test_function_macro::test_fn"].assert_eq(name);
    }
}
