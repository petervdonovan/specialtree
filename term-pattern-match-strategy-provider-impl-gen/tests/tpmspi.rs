/// generated by [term_pattern_match_strategy_provider_impl_gen::generate]
#[rustfmt::skip]
#[allow(warnings)]
#[allow(unknown_lints)]
pub mod pattern_match_strategy {
    impl<
        Heap: crate::term_trait::Heap,
        T,
    > term::case_split::HasPatternMatchStrategyFor<T>
    for PatternMatchStrategyProvider<Heap>
    where
        T: words::Implements<crate::term_trait::words::L>,
        PatternMatchStrategyProvider<
            Heap,
        >: term::case_split::HasPatternMatchStrategyFor<T::LWord>,
    {
        type Strategy = <PatternMatchStrategyProvider<
            Heap,
        > as term::case_split::HasPatternMatchStrategyFor<T::LWord>>::Strategy;
    }
    pub struct PatternMatchStrategyProvider<Heap>(std::marker::PhantomData<Heap>);
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    impl<
        Heap: crate::term_trait::Heap,
    > term::case_split::HasPatternMatchStrategyFor<crate::term_trait::words::sorts::Plus>
    for PatternMatchStrategyProvider<Heap> {
        type Strategy = ((Heap::LeftOperand, (Heap::RightOperand, ())), ());
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    impl<
        Heap: crate::term_trait::Heap,
    > term::case_split::HasPatternMatchStrategyFor<
        crate::term_trait::words::sorts::LeftOperand,
    > for PatternMatchStrategyProvider<Heap> {
        type Strategy = ((Heap::Nat, ()), ());
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    impl<
        Heap: crate::term_trait::Heap,
    > term::case_split::HasPatternMatchStrategyFor<
        crate::term_trait::words::sorts::RightOperand,
    > for PatternMatchStrategyProvider<Heap> {
        type Strategy = ((Heap::Nat, ()), ());
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    impl<
        Heap: crate::term_trait::Heap,
    > term::case_split::HasPatternMatchStrategyFor<crate::term_trait::words::sorts::F>
    for PatternMatchStrategyProvider<Heap> {
        type Strategy = ((Heap::Nat, ()), ());
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    impl<
        Heap: crate::term_trait::Heap,
    > term::case_split::HasPatternMatchStrategyFor<crate::term_trait::words::sorts::Sum>
    for PatternMatchStrategyProvider<Heap> {
        type Strategy = (
            (
                <Heap as term::MapsTmf<
                    crate::term_trait::words::L,
                    tymetafuncspec_core::Set<Heap, Heap::Nat>,
                >>::Tmf,
                (),
            ),
            (),
        );
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    impl<
        Heap: crate::term_trait::Heap,
    > term::case_split::HasPatternMatchStrategyFor<crate::term_trait::words::sorts::Nat>
    for PatternMatchStrategyProvider<Heap> {
        type Strategy = (
            (
                <Heap as term::MapsTmf<
                    crate::term_trait::words::L,
                    tymetafuncspec_core::BoundedNat<Heap>,
                >>::Tmf,
                (),
            ),
            (
                (
                    <Heap as term::MapsTmf<
                        crate::term_trait::words::L,
                        tymetafuncspec_core::IdxBox<Heap, Heap::F>,
                    >>::Tmf,
                    (),
                ),
                (
                    (
                        <Heap as term::MapsTmf<
                            crate::term_trait::words::L,
                            tymetafuncspec_core::IdxBox<Heap, Heap::Plus>,
                        >>::Tmf,
                        (),
                    ),
                    (
                        (
                            <Heap as term::MapsTmf<
                                crate::term_trait::words::L,
                                tymetafuncspec_core::IdxBox<Heap, Heap::Sum>,
                            >>::Tmf,
                            (),
                        ),
                        (),
                    ),
                ),
            ),
        );
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    impl term::case_split::Adt for crate::data_structure::Plus {
        type PatternMatchStrategyProvider = crate::pattern_match_strategy::PatternMatchStrategyProvider<
            crate::data_structure::Heap,
        >;
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    impl term::case_split::Adt for crate::data_structure::LeftOperand {
        type PatternMatchStrategyProvider = crate::pattern_match_strategy::PatternMatchStrategyProvider<
            crate::data_structure::Heap,
        >;
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    impl term::case_split::Adt for crate::data_structure::RightOperand {
        type PatternMatchStrategyProvider = crate::pattern_match_strategy::PatternMatchStrategyProvider<
            crate::data_structure::Heap,
        >;
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    impl term::case_split::Adt for crate::data_structure::F {
        type PatternMatchStrategyProvider = crate::pattern_match_strategy::PatternMatchStrategyProvider<
            crate::data_structure::Heap,
        >;
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    impl term::case_split::Adt for crate::data_structure::Sum {
        type PatternMatchStrategyProvider = crate::pattern_match_strategy::PatternMatchStrategyProvider<
            crate::data_structure::Heap,
        >;
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    impl term::case_split::Adt for crate::data_structure::Nat {
        type PatternMatchStrategyProvider = crate::pattern_match_strategy::PatternMatchStrategyProvider<
            crate::data_structure::Heap,
        >;
    }
}
/// generated by [term_trait_gen::generate]
#[rustfmt::skip]
#[allow(warnings)]
#[allow(unknown_lints)]
pub mod term_trait {
    /// generated by [term_trait_gen::heap_trait]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    pub trait Heap: Sized + term::MapsTmf<
            crate::term_trait::words::L,
            tymetafuncspec_core::Set<Self, Self::Nat>,
        > + term::MapsTmf<
            crate::term_trait::words::L,
            tymetafuncspec_core::BoundedNat<Self>,
        > + term::MapsTmf<
            crate::term_trait::words::L,
            tymetafuncspec_core::IdxBox<Self, Self::F>,
        > + term::MapsTmf<
            crate::term_trait::words::L,
            tymetafuncspec_core::IdxBox<Self, Self::Plus>,
        > + term::MapsTmf<
            crate::term_trait::words::L,
            tymetafuncspec_core::IdxBox<Self, Self::Sum>,
        > + term::SuperHeap<
            tymetafuncspec_core::SetHeapBak<Self, Self::Nat>,
        > + term::SuperHeap<
            tymetafuncspec_core::BoundedNatHeapBak<Self>,
        > + term::SuperHeap<
            tymetafuncspec_core::IdxBoxHeapBak<Self, Self::F>,
        > + term::SuperHeap<
            tymetafuncspec_core::IdxBoxHeapBak<Self, Self::Plus>,
        > + term::SuperHeap<tymetafuncspec_core::IdxBoxHeapBak<Self, Self::Sum>> {
        type Plus: crate::term_trait::owned::Plus<Heap = Self>;
        type LeftOperand: crate::term_trait::owned::LeftOperand<Heap = Self>;
        type RightOperand: crate::term_trait::owned::RightOperand<Heap = Self>;
        type F: crate::term_trait::owned::F<Heap = Self>;
        type Sum: crate::term_trait::owned::Sum<Heap = Self>;
        type Nat: crate::term_trait::owned::Nat<Heap = Self>;
    }
    /// generated by [term_trait_gen::owned::generate]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    pub mod owned {
        pub trait Plus: term::Heaped + term::CanonicallyConstructibleFrom<
                <Self as term::Heaped>::Heap,
                (
                    <<Self as term::Heaped>::Heap as crate::term_trait::Heap>::LeftOperand,
                    (
                        <<Self as term::Heaped>::Heap as crate::term_trait::Heap>::RightOperand,
                        (),
                    ),
                ),
            >
        where
            <Self as term::Heaped>::Heap: crate::term_trait::Heap,
        {}
        pub trait LeftOperand: term::Heaped + term::CanonicallyConstructibleFrom<
                <Self as term::Heaped>::Heap,
                (<<Self as term::Heaped>::Heap as crate::term_trait::Heap>::Nat, ()),
            >
        where
            <Self as term::Heaped>::Heap: crate::term_trait::Heap,
        {}
        pub trait RightOperand: term::Heaped + term::CanonicallyConstructibleFrom<
                <Self as term::Heaped>::Heap,
                (<<Self as term::Heaped>::Heap as crate::term_trait::Heap>::Nat, ()),
            >
        where
            <Self as term::Heaped>::Heap: crate::term_trait::Heap,
        {}
        pub trait F: term::Heaped + term::CanonicallyConstructibleFrom<
                <Self as term::Heaped>::Heap,
                (<<Self as term::Heaped>::Heap as crate::term_trait::Heap>::Nat, ()),
            >
        where
            <Self as term::Heaped>::Heap: crate::term_trait::Heap,
        {}
        pub trait Sum: term::Heaped + term::CanonicallyConstructibleFrom<
                <Self as term::Heaped>::Heap,
                (
                    <<Self as term::Heaped>::Heap as term::MapsTmf<
                        crate::term_trait::words::L,
                        tymetafuncspec_core::Set<
                            <Self as term::Heaped>::Heap,
                            <<Self as term::Heaped>::Heap as crate::term_trait::Heap>::Nat,
                        >,
                    >>::Tmf,
                    (),
                ),
            >
        where
            <Self as term::Heaped>::Heap: crate::term_trait::Heap,
        {}
        pub trait Nat: term::Heaped + term::CanonicallyConstructibleFrom<
                <Self as term::Heaped>::Heap,
                (
                    <<Self as term::Heaped>::Heap as term::MapsTmf<
                        crate::term_trait::words::L,
                        tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>,
                    >>::Tmf,
                    (),
                ),
            > + term::CanonicallyConstructibleFrom<
                <Self as term::Heaped>::Heap,
                (
                    <<Self as term::Heaped>::Heap as term::MapsTmf<
                        crate::term_trait::words::L,
                        tymetafuncspec_core::IdxBox<
                            <Self as term::Heaped>::Heap,
                            <<Self as term::Heaped>::Heap as crate::term_trait::Heap>::F,
                        >,
                    >>::Tmf,
                    (),
                ),
            > + term::CanonicallyConstructibleFrom<
                <Self as term::Heaped>::Heap,
                (
                    <<Self as term::Heaped>::Heap as term::MapsTmf<
                        crate::term_trait::words::L,
                        tymetafuncspec_core::IdxBox<
                            <Self as term::Heaped>::Heap,
                            <<Self as term::Heaped>::Heap as crate::term_trait::Heap>::Plus,
                        >,
                    >>::Tmf,
                    (),
                ),
            > + term::CanonicallyConstructibleFrom<
                <Self as term::Heaped>::Heap,
                (
                    <<Self as term::Heaped>::Heap as term::MapsTmf<
                        crate::term_trait::words::L,
                        tymetafuncspec_core::IdxBox<
                            <Self as term::Heaped>::Heap,
                            <<Self as term::Heaped>::Heap as crate::term_trait::Heap>::Sum,
                        >,
                    >>::Tmf,
                    (),
                ),
            >
        where
            <Self as term::Heaped>::Heap: crate::term_trait::Heap,
        {}
    }
    /// generated by [words::words_mod]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    pub mod words {
        pub struct L;
        pub mod sorts {
            pub struct Plus;
            pub struct LeftOperand;
            pub struct RightOperand;
            pub struct F;
            pub struct Sum;
            pub struct Nat;
        }
    }
}
/// generated by [term_specialized_gen::generate]
#[rustfmt::skip]
#[allow(warnings)]
#[allow(unknown_lints)]
pub mod data_structure {
    /// generated by [term_specialized_gen::gen_heap]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    #[derive(Default)]
    pub struct Heap {
        set: crate::data_structure::heap::set::Bak,
        nat_lit: crate::data_structure::heap::nat_lit::Bak,
        idx_box: crate::data_structure::heap::idx_box::Bak,
    }
    /// generated by [term_specialized_gen::gen_heap]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    pub mod heap {
        /// generated by [term_specialized_gen::gen_modules_with_prefix]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        #[derive(Default)]
        pub struct Bak {
            pub set: crate::data_structure::heap::set::Bak,
            pub nat_lit: crate::data_structure::heap::nat_lit::Bak,
            pub idx_box: crate::data_structure::heap::idx_box::Bak,
        }
        /// generated by [term_specialized_gen::gen_modules_with_prefix]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        pub mod set {
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[rustfmt::skip]
            #[allow(warnings)]
            #[allow(unknown_lints)]
            #[derive(Default)]
            pub struct Bak {
                pub nat: crate::data_structure::heap::set::nat::Bak,
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[rustfmt::skip]
            #[allow(warnings)]
            #[allow(unknown_lints)]
            pub mod nat {
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[rustfmt::skip]
                #[allow(warnings)]
                #[allow(unknown_lints)]
                #[derive(Default)]
                pub struct Bak(
                    pub tymetafuncspec_core::SetHeapBak<
                        crate::data_structure::Heap,
                        crate::data_structure::Nat,
                    >,
                );
            }
        }
        /// generated by [term_specialized_gen::gen_modules_with_prefix]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        pub mod nat_lit {
            /// generated by [term_specialized_gen::gen_heapbak_module]
            #[rustfmt::skip]
            #[allow(warnings)]
            #[allow(unknown_lints)]
            #[derive(Default)]
            pub struct Bak(
                pub tymetafuncspec_core::BoundedNatHeapBak<crate::data_structure::Heap>,
            );
        }
        /// generated by [term_specialized_gen::gen_modules_with_prefix]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        pub mod idx_box {
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[rustfmt::skip]
            #[allow(warnings)]
            #[allow(unknown_lints)]
            #[derive(Default)]
            pub struct Bak {
                pub f: crate::data_structure::heap::idx_box::f::Bak,
                pub plus: crate::data_structure::heap::idx_box::plus::Bak,
                pub sum: crate::data_structure::heap::idx_box::sum::Bak,
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[rustfmt::skip]
            #[allow(warnings)]
            #[allow(unknown_lints)]
            pub mod f {
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[rustfmt::skip]
                #[allow(warnings)]
                #[allow(unknown_lints)]
                #[derive(Default)]
                pub struct Bak(
                    pub tymetafuncspec_core::IdxBoxHeapBak<
                        crate::data_structure::Heap,
                        crate::data_structure::F,
                    >,
                );
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[rustfmt::skip]
            #[allow(warnings)]
            #[allow(unknown_lints)]
            pub mod plus {
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[rustfmt::skip]
                #[allow(warnings)]
                #[allow(unknown_lints)]
                #[derive(Default)]
                pub struct Bak(
                    pub tymetafuncspec_core::IdxBoxHeapBak<
                        crate::data_structure::Heap,
                        crate::data_structure::Plus,
                    >,
                );
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[rustfmt::skip]
            #[allow(warnings)]
            #[allow(unknown_lints)]
            pub mod sum {
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[rustfmt::skip]
                #[allow(warnings)]
                #[allow(unknown_lints)]
                #[derive(Default)]
                pub struct Bak(
                    pub tymetafuncspec_core::IdxBoxHeapBak<
                        crate::data_structure::Heap,
                        crate::data_structure::Sum,
                    >,
                );
            }
        }
    }
    /// generated by [term_specialized_gen::gen_heap]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    pub mod superheap {
        term::impl_superheap!(
            crate ::data_structure::Heap; tymetafuncspec_core::SetHeapBak < crate
            ::data_structure::Heap, crate ::data_structure::Nat >; set nat
        );
        term::impl_superheap!(
            crate ::data_structure::Heap; tymetafuncspec_core::BoundedNatHeapBak < crate
            ::data_structure::Heap, >; nat_lit
        );
        term::impl_superheap!(
            crate ::data_structure::Heap; tymetafuncspec_core::IdxBoxHeapBak < crate
            ::data_structure::Heap, crate ::data_structure::F >; idx_box f
        );
        term::impl_superheap!(
            crate ::data_structure::Heap; tymetafuncspec_core::IdxBoxHeapBak < crate
            ::data_structure::Heap, crate ::data_structure::Plus >; idx_box plus
        );
        term::impl_superheap!(
            crate ::data_structure::Heap; tymetafuncspec_core::IdxBoxHeapBak < crate
            ::data_structure::Heap, crate ::data_structure::Sum >; idx_box sum
        );
    }
    #[derive(Clone, Copy)]
    pub struct Plus {
        pub left_operand: crate::data_structure::LeftOperand,
        pub right_operand: crate::data_structure::RightOperand,
    }
    #[derive(Clone, Copy)]
    pub struct LeftOperand {
        pub nat: crate::data_structure::Nat,
    }
    #[derive(Clone, Copy)]
    pub struct RightOperand {
        pub nat: crate::data_structure::Nat,
    }
    #[derive(Clone, Copy)]
    pub struct F {
        pub nat: crate::data_structure::Nat,
    }
    #[derive(Clone, Copy)]
    pub struct Sum {
        pub set: tymetafuncspec_core::Set<
            crate::data_structure::Heap,
            crate::data_structure::Nat,
        >,
    }
    #[derive(Clone, Copy)]
    pub enum Nat {
        NatLit(tymetafuncspec_core::BoundedNat<crate::data_structure::Heap>),
        F(
            tymetafuncspec_core::IdxBox<
                crate::data_structure::Heap,
                crate::data_structure::F,
            >,
        ),
        Plus(
            tymetafuncspec_core::IdxBox<
                crate::data_structure::Heap,
                crate::data_structure::Plus,
            >,
        ),
        Sum(
            tymetafuncspec_core::IdxBox<
                crate::data_structure::Heap,
                crate::data_structure::Sum,
            >,
        ),
    }
    /// generated by [term_specialized_gen::gen_heaped_impls]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    pub mod heaped {
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::Heaped for crate::data_structure::Plus {
            type Heap = crate::data_structure::Heap;
        }
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::Heaped for crate::data_structure::LeftOperand {
            type Heap = crate::data_structure::Heap;
        }
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::Heaped for crate::data_structure::RightOperand {
            type Heap = crate::data_structure::Heap;
        }
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::Heaped for crate::data_structure::F {
            type Heap = crate::data_structure::Heap;
        }
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::Heaped for crate::data_structure::Sum {
            type Heap = crate::data_structure::Heap;
        }
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::Heaped for crate::data_structure::Nat {
            type Heap = crate::data_structure::Heap;
        }
    }
}
/// generated by [words::words_impls]
#[rustfmt::skip]
#[allow(warnings)]
#[allow(unknown_lints)]
pub mod words_impls {
    impl words::Implements<crate::term_trait::words::L> for crate::data_structure::Plus {
        type LWord = crate::term_trait::words::sorts::Plus;
    }
    impl words::Implements<crate::term_trait::words::L>
    for crate::data_structure::LeftOperand {
        type LWord = crate::term_trait::words::sorts::LeftOperand;
    }
    impl words::Implements<crate::term_trait::words::L>
    for crate::data_structure::RightOperand {
        type LWord = crate::term_trait::words::sorts::RightOperand;
    }
    impl words::Implements<crate::term_trait::words::L> for crate::data_structure::F {
        type LWord = crate::term_trait::words::sorts::F;
    }
    impl words::Implements<crate::term_trait::words::L> for crate::data_structure::Sum {
        type LWord = crate::term_trait::words::sorts::Sum;
    }
    impl words::Implements<crate::term_trait::words::L> for crate::data_structure::Nat {
        type LWord = crate::term_trait::words::sorts::Nat;
    }
}
/// generated by [term_specialized_impl_gen::generate]
#[rustfmt::skip]
#[allow(warnings)]
#[allow(unknown_lints)]
pub mod term_impls {
    /// generated by [term_specialized_impl_gen::gen_heap_impl]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    impl crate::term_trait::Heap for crate::data_structure::Heap {
        type Plus = crate::data_structure::Plus;
        type LeftOperand = crate::data_structure::LeftOperand;
        type RightOperand = crate::data_structure::RightOperand;
        type F = crate::data_structure::F;
        type Sum = crate::data_structure::Sum;
        type Nat = crate::data_structure::Nat;
    }
    /// generated by [term_specialized_impl_gen::gen_owned_mod]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    pub mod owned_impls {
        impl crate::term_trait::owned::Plus for crate::data_structure::Plus {}
        impl crate::term_trait::owned::LeftOperand
        for crate::data_structure::LeftOperand {}
        impl crate::term_trait::owned::RightOperand
        for crate::data_structure::RightOperand {}
        impl crate::term_trait::owned::F for crate::data_structure::F {}
        impl crate::term_trait::owned::Sum for crate::data_structure::Sum {}
        impl crate::term_trait::owned::Nat for crate::data_structure::Nat {}
    }
    /// generated by [term_specialized_impl_gen::gen_ccf_mod]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    pub mod ccf_impls {
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        pub mod plus {
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
            #[rustfmt::skip]
            #[allow(warnings)]
            #[allow(unknown_lints)]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as term::Heaped>::Heap,
                (
                    crate::data_structure::LeftOperand,
                    (crate::data_structure::RightOperand, ()),
                ),
            > for crate::data_structure::Plus {
                fn construct(
                    heap: &mut <Self as term::Heaped>::Heap,
                    t: (
                        crate::data_structure::LeftOperand,
                        (crate::data_structure::RightOperand, ()),
                    ),
                ) -> Self {
                    crate::data_structure::Plus {
                        left_operand: t.0,
                        right_operand: t.1.0,
                    }
                }
                fn deconstruct_succeeds(
                    &self,
                    heap: &<Self as term::Heaped>::Heap,
                ) -> bool {
                    true
                }
                fn deconstruct(
                    self,
                    heap: &<Self as term::Heaped>::Heap,
                ) -> (
                    crate::data_structure::LeftOperand,
                    (crate::data_structure::RightOperand, ()),
                ) {
                    (self.left_operand, (self.right_operand, ()))
                }
            }
        }
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        pub mod left_operand {
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
            #[rustfmt::skip]
            #[allow(warnings)]
            #[allow(unknown_lints)]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as term::Heaped>::Heap,
                (crate::data_structure::Nat, ()),
            > for crate::data_structure::LeftOperand {
                fn construct(
                    heap: &mut <Self as term::Heaped>::Heap,
                    t: (crate::data_structure::Nat, ()),
                ) -> Self {
                    crate::data_structure::LeftOperand {
                        nat: t.0,
                    }
                }
                fn deconstruct_succeeds(
                    &self,
                    heap: &<Self as term::Heaped>::Heap,
                ) -> bool {
                    true
                }
                fn deconstruct(
                    self,
                    heap: &<Self as term::Heaped>::Heap,
                ) -> (crate::data_structure::Nat, ()) {
                    (self.nat, ())
                }
            }
        }
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        pub mod right_operand {
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
            #[rustfmt::skip]
            #[allow(warnings)]
            #[allow(unknown_lints)]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as term::Heaped>::Heap,
                (crate::data_structure::Nat, ()),
            > for crate::data_structure::RightOperand {
                fn construct(
                    heap: &mut <Self as term::Heaped>::Heap,
                    t: (crate::data_structure::Nat, ()),
                ) -> Self {
                    crate::data_structure::RightOperand {
                        nat: t.0,
                    }
                }
                fn deconstruct_succeeds(
                    &self,
                    heap: &<Self as term::Heaped>::Heap,
                ) -> bool {
                    true
                }
                fn deconstruct(
                    self,
                    heap: &<Self as term::Heaped>::Heap,
                ) -> (crate::data_structure::Nat, ()) {
                    (self.nat, ())
                }
            }
        }
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        pub mod f {
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
            #[rustfmt::skip]
            #[allow(warnings)]
            #[allow(unknown_lints)]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as term::Heaped>::Heap,
                (crate::data_structure::Nat, ()),
            > for crate::data_structure::F {
                fn construct(
                    heap: &mut <Self as term::Heaped>::Heap,
                    t: (crate::data_structure::Nat, ()),
                ) -> Self {
                    crate::data_structure::F {
                        nat: t.0,
                    }
                }
                fn deconstruct_succeeds(
                    &self,
                    heap: &<Self as term::Heaped>::Heap,
                ) -> bool {
                    true
                }
                fn deconstruct(
                    self,
                    heap: &<Self as term::Heaped>::Heap,
                ) -> (crate::data_structure::Nat, ()) {
                    (self.nat, ())
                }
            }
        }
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        pub mod sum {
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
            #[rustfmt::skip]
            #[allow(warnings)]
            #[allow(unknown_lints)]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as term::Heaped>::Heap,
                (
                    <<Self as term::Heaped>::Heap as term::MapsTmf<
                        crate::term_trait::words::L,
                        tymetafuncspec_core::Set<
                            <Self as term::Heaped>::Heap,
                            crate::data_structure::Nat,
                        >,
                    >>::Tmf,
                    (),
                ),
            > for crate::data_structure::Sum {
                fn construct(
                    heap: &mut <Self as term::Heaped>::Heap,
                    t: (
                        <<Self as term::Heaped>::Heap as term::MapsTmf<
                            crate::term_trait::words::L,
                            tymetafuncspec_core::Set<
                                <Self as term::Heaped>::Heap,
                                crate::data_structure::Nat,
                            >,
                        >>::Tmf,
                        (),
                    ),
                ) -> Self {
                    crate::data_structure::Sum {
                        set: t.0,
                    }
                }
                fn deconstruct_succeeds(
                    &self,
                    heap: &<Self as term::Heaped>::Heap,
                ) -> bool {
                    true
                }
                fn deconstruct(
                    self,
                    heap: &<Self as term::Heaped>::Heap,
                ) -> (
                    <<Self as term::Heaped>::Heap as term::MapsTmf<
                        crate::term_trait::words::L,
                        tymetafuncspec_core::Set<
                            <Self as term::Heaped>::Heap,
                            crate::data_structure::Nat,
                        >,
                    >>::Tmf,
                    (),
                ) {
                    (self.set, ())
                }
            }
        }
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        pub mod nat {
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
            #[rustfmt::skip]
            #[allow(warnings)]
            #[allow(unknown_lints)]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as term::Heaped>::Heap,
                (
                    <<Self as term::Heaped>::Heap as term::MapsTmf<
                        crate::term_trait::words::L,
                        tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>,
                    >>::Tmf,
                    (),
                ),
            > for crate::data_structure::Nat {
                fn construct(
                    heap: &mut <Self as term::Heaped>::Heap,
                    t: (
                        <<Self as term::Heaped>::Heap as term::MapsTmf<
                            crate::term_trait::words::L,
                            tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>,
                        >>::Tmf,
                        (),
                    ),
                ) -> Self {
                    crate::data_structure::Nat::NatLit(t.0)
                }
                fn deconstruct_succeeds(
                    &self,
                    heap: &<Self as term::Heaped>::Heap,
                ) -> bool {
                    match self {
                        crate::data_structure::Nat::NatLit(_) => true,
                        _ => false,
                    }
                }
                fn deconstruct(
                    self,
                    heap: &<Self as term::Heaped>::Heap,
                ) -> (
                    <<Self as term::Heaped>::Heap as term::MapsTmf<
                        crate::term_trait::words::L,
                        tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>,
                    >>::Tmf,
                    (),
                ) {
                    match self {
                        crate::data_structure::Nat::NatLit(t) => (t, ()),
                        _ => panic!("conversion failure"),
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
            #[rustfmt::skip]
            #[allow(warnings)]
            #[allow(unknown_lints)]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as term::Heaped>::Heap,
                (
                    <<Self as term::Heaped>::Heap as term::MapsTmf<
                        crate::term_trait::words::L,
                        tymetafuncspec_core::IdxBox<
                            <Self as term::Heaped>::Heap,
                            crate::data_structure::F,
                        >,
                    >>::Tmf,
                    (),
                ),
            > for crate::data_structure::Nat {
                fn construct(
                    heap: &mut <Self as term::Heaped>::Heap,
                    t: (
                        <<Self as term::Heaped>::Heap as term::MapsTmf<
                            crate::term_trait::words::L,
                            tymetafuncspec_core::IdxBox<
                                <Self as term::Heaped>::Heap,
                                crate::data_structure::F,
                            >,
                        >>::Tmf,
                        (),
                    ),
                ) -> Self {
                    crate::data_structure::Nat::F(t.0)
                }
                fn deconstruct_succeeds(
                    &self,
                    heap: &<Self as term::Heaped>::Heap,
                ) -> bool {
                    match self {
                        crate::data_structure::Nat::F(_) => true,
                        _ => false,
                    }
                }
                fn deconstruct(
                    self,
                    heap: &<Self as term::Heaped>::Heap,
                ) -> (
                    <<Self as term::Heaped>::Heap as term::MapsTmf<
                        crate::term_trait::words::L,
                        tymetafuncspec_core::IdxBox<
                            <Self as term::Heaped>::Heap,
                            crate::data_structure::F,
                        >,
                    >>::Tmf,
                    (),
                ) {
                    match self {
                        crate::data_structure::Nat::F(t) => (t, ()),
                        _ => panic!("conversion failure"),
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
            #[rustfmt::skip]
            #[allow(warnings)]
            #[allow(unknown_lints)]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as term::Heaped>::Heap,
                (
                    <<Self as term::Heaped>::Heap as term::MapsTmf<
                        crate::term_trait::words::L,
                        tymetafuncspec_core::IdxBox<
                            <Self as term::Heaped>::Heap,
                            crate::data_structure::Plus,
                        >,
                    >>::Tmf,
                    (),
                ),
            > for crate::data_structure::Nat {
                fn construct(
                    heap: &mut <Self as term::Heaped>::Heap,
                    t: (
                        <<Self as term::Heaped>::Heap as term::MapsTmf<
                            crate::term_trait::words::L,
                            tymetafuncspec_core::IdxBox<
                                <Self as term::Heaped>::Heap,
                                crate::data_structure::Plus,
                            >,
                        >>::Tmf,
                        (),
                    ),
                ) -> Self {
                    crate::data_structure::Nat::Plus(t.0)
                }
                fn deconstruct_succeeds(
                    &self,
                    heap: &<Self as term::Heaped>::Heap,
                ) -> bool {
                    match self {
                        crate::data_structure::Nat::Plus(_) => true,
                        _ => false,
                    }
                }
                fn deconstruct(
                    self,
                    heap: &<Self as term::Heaped>::Heap,
                ) -> (
                    <<Self as term::Heaped>::Heap as term::MapsTmf<
                        crate::term_trait::words::L,
                        tymetafuncspec_core::IdxBox<
                            <Self as term::Heaped>::Heap,
                            crate::data_structure::Plus,
                        >,
                    >>::Tmf,
                    (),
                ) {
                    match self {
                        crate::data_structure::Nat::Plus(t) => (t, ()),
                        _ => panic!("conversion failure"),
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
            #[rustfmt::skip]
            #[allow(warnings)]
            #[allow(unknown_lints)]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as term::Heaped>::Heap,
                (
                    <<Self as term::Heaped>::Heap as term::MapsTmf<
                        crate::term_trait::words::L,
                        tymetafuncspec_core::IdxBox<
                            <Self as term::Heaped>::Heap,
                            crate::data_structure::Sum,
                        >,
                    >>::Tmf,
                    (),
                ),
            > for crate::data_structure::Nat {
                fn construct(
                    heap: &mut <Self as term::Heaped>::Heap,
                    t: (
                        <<Self as term::Heaped>::Heap as term::MapsTmf<
                            crate::term_trait::words::L,
                            tymetafuncspec_core::IdxBox<
                                <Self as term::Heaped>::Heap,
                                crate::data_structure::Sum,
                            >,
                        >>::Tmf,
                        (),
                    ),
                ) -> Self {
                    crate::data_structure::Nat::Sum(t.0)
                }
                fn deconstruct_succeeds(
                    &self,
                    heap: &<Self as term::Heaped>::Heap,
                ) -> bool {
                    match self {
                        crate::data_structure::Nat::Sum(_) => true,
                        _ => false,
                    }
                }
                fn deconstruct(
                    self,
                    heap: &<Self as term::Heaped>::Heap,
                ) -> (
                    <<Self as term::Heaped>::Heap as term::MapsTmf<
                        crate::term_trait::words::L,
                        tymetafuncspec_core::IdxBox<
                            <Self as term::Heaped>::Heap,
                            crate::data_structure::Sum,
                        >,
                    >>::Tmf,
                    (),
                ) {
                    match self {
                        crate::data_structure::Nat::Sum(t) => (t, ()),
                        _ => panic!("conversion failure"),
                    }
                }
            }
        }
    }
    /// generated by [term_specialized_impl_gen::gen_transitive_ccf_mod]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    pub mod transitive_ccf {
        /// generated by [term_specialized_impl_gen::tuc_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::TransitivelyUnitCcf<
            crate::data_structure::Heap,
            crate::data_structure::Nat,
        > for crate::data_structure::LeftOperand {
            type Intermediary = crate::data_structure::Nat;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::TransitivelyUnitCcf<
            crate::data_structure::Heap,
            crate::data_structure::Nat,
        > for crate::data_structure::RightOperand {
            type Intermediary = crate::data_structure::Nat;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::TransitivelyUnitCcf<
            crate::data_structure::Heap,
            crate::data_structure::Nat,
        > for crate::data_structure::F {
            type Intermediary = crate::data_structure::Nat;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::TransitivelyUnitCcf<
            crate::data_structure::Heap,
            tymetafuncspec_core::Set<
                crate::data_structure::Heap,
                crate::data_structure::Nat,
            >,
        > for crate::data_structure::Sum {
            type Intermediary = tymetafuncspec_core::Set<
                crate::data_structure::Heap,
                crate::data_structure::Nat,
            >;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::TransitivelyUnitCcf<
            crate::data_structure::Heap,
            tymetafuncspec_core::BoundedNat<crate::data_structure::Heap>,
        > for crate::data_structure::Nat {
            type Intermediary = tymetafuncspec_core::BoundedNat<
                crate::data_structure::Heap,
            >;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::TransitivelyUnitCcf<
            crate::data_structure::Heap,
            tymetafuncspec_core::IdxBox<
                crate::data_structure::Heap,
                crate::data_structure::Plus,
            >,
        > for crate::data_structure::Nat {
            type Intermediary = tymetafuncspec_core::IdxBox<
                crate::data_structure::Heap,
                crate::data_structure::Plus,
            >;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::TransitivelyUnitCcf<
            crate::data_structure::Heap,
            tymetafuncspec_core::IdxBox<
                crate::data_structure::Heap,
                crate::data_structure::F,
            >,
        > for crate::data_structure::Nat {
            type Intermediary = tymetafuncspec_core::IdxBox<
                crate::data_structure::Heap,
                crate::data_structure::F,
            >;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::TransitivelyUnitCcf<
            crate::data_structure::Heap,
            tymetafuncspec_core::IdxBox<
                crate::data_structure::Heap,
                crate::data_structure::Sum,
            >,
        > for crate::data_structure::Nat {
            type Intermediary = tymetafuncspec_core::IdxBox<
                crate::data_structure::Heap,
                crate::data_structure::Sum,
            >;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::TransitivelyUnitCcf<
            crate::data_structure::Heap,
            crate::data_structure::Plus,
        >
        for tymetafuncspec_core::IdxBox<
            crate::data_structure::Heap,
            crate::data_structure::Plus,
        > {
            type Intermediary = crate::data_structure::Plus;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::TransitivelyUnitCcf<
            crate::data_structure::Heap,
            crate::data_structure::F,
        >
        for tymetafuncspec_core::IdxBox<
            crate::data_structure::Heap,
            crate::data_structure::F,
        > {
            type Intermediary = crate::data_structure::F;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::TransitivelyUnitCcf<
            crate::data_structure::Heap,
            crate::data_structure::Sum,
        >
        for tymetafuncspec_core::IdxBox<
            crate::data_structure::Heap,
            crate::data_structure::Sum,
        > {
            type Intermediary = crate::data_structure::Sum;
        }
        /// generated by [term_specialized_impl_gen::tac_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::TransitivelyAllCcf<
            crate::data_structure::Heap,
            (
                crate::data_structure::LeftOperand,
                (crate::data_structure::RightOperand, ()),
            ),
        > for crate::data_structure::Plus {
            type Intermediary = crate::data_structure::Plus;
            type Intermediaries = (
                crate::data_structure::LeftOperand,
                (crate::data_structure::RightOperand, ()),
            );
        }
        /// generated by [term_specialized_impl_gen::tac_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::TransitivelyAllCcf<
            crate::data_structure::Heap,
            (
                crate::data_structure::LeftOperand,
                (crate::data_structure::RightOperand, ()),
            ),
        >
        for tymetafuncspec_core::IdxBox<
            crate::data_structure::Heap,
            crate::data_structure::Plus,
        > {
            type Intermediary = crate::data_structure::Plus;
            type Intermediaries = (
                crate::data_structure::LeftOperand,
                (crate::data_structure::RightOperand, ()),
            );
        }
        /// generated by [term_specialized_impl_gen::tac_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::TransitivelyAllCcf<
            crate::data_structure::Heap,
            (crate::data_structure::LeftOperand, (crate::data_structure::Nat, ())),
        > for crate::data_structure::Plus {
            type Intermediary = crate::data_structure::Plus;
            type Intermediaries = (
                crate::data_structure::LeftOperand,
                (crate::data_structure::RightOperand, ()),
            );
        }
        /// generated by [term_specialized_impl_gen::tac_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::TransitivelyAllCcf<
            crate::data_structure::Heap,
            (crate::data_structure::LeftOperand, (crate::data_structure::Nat, ())),
        >
        for tymetafuncspec_core::IdxBox<
            crate::data_structure::Heap,
            crate::data_structure::Plus,
        > {
            type Intermediary = crate::data_structure::Plus;
            type Intermediaries = (
                crate::data_structure::LeftOperand,
                (crate::data_structure::RightOperand, ()),
            );
        }
        /// generated by [term_specialized_impl_gen::tac_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::TransitivelyAllCcf<
            crate::data_structure::Heap,
            (crate::data_structure::Nat, (crate::data_structure::RightOperand, ())),
        > for crate::data_structure::Plus {
            type Intermediary = crate::data_structure::Plus;
            type Intermediaries = (
                crate::data_structure::LeftOperand,
                (crate::data_structure::RightOperand, ()),
            );
        }
        /// generated by [term_specialized_impl_gen::tac_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::TransitivelyAllCcf<
            crate::data_structure::Heap,
            (crate::data_structure::Nat, (crate::data_structure::RightOperand, ())),
        >
        for tymetafuncspec_core::IdxBox<
            crate::data_structure::Heap,
            crate::data_structure::Plus,
        > {
            type Intermediary = crate::data_structure::Plus;
            type Intermediaries = (
                crate::data_structure::LeftOperand,
                (crate::data_structure::RightOperand, ()),
            );
        }
        /// generated by [term_specialized_impl_gen::tac_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::TransitivelyAllCcf<
            crate::data_structure::Heap,
            (crate::data_structure::Nat, (crate::data_structure::Nat, ())),
        > for crate::data_structure::Plus {
            type Intermediary = crate::data_structure::Plus;
            type Intermediaries = (
                crate::data_structure::LeftOperand,
                (crate::data_structure::RightOperand, ()),
            );
        }
        /// generated by [term_specialized_impl_gen::tac_impls]
        #[rustfmt::skip]
        #[allow(warnings)]
        #[allow(unknown_lints)]
        impl term::TransitivelyAllCcf<
            crate::data_structure::Heap,
            (crate::data_structure::Nat, (crate::data_structure::Nat, ())),
        >
        for tymetafuncspec_core::IdxBox<
            crate::data_structure::Heap,
            crate::data_structure::Plus,
        > {
            type Intermediary = crate::data_structure::Plus;
            type Intermediaries = (
                crate::data_structure::LeftOperand,
                (crate::data_structure::RightOperand, ()),
            );
        }
    }
    /// generated by [term_specialized_impl_gen::gen_ccf_auto_impls]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    pub mod ccf_auto_impls {
        term::auto_impl_ccf!(crate ::data_structure::Heap, crate ::data_structure::Plus);
        term::auto_impl_ccf!(
            crate ::data_structure::Heap, crate ::data_structure::LeftOperand
        );
        term::auto_impl_ccf!(
            crate ::data_structure::Heap, crate ::data_structure::RightOperand
        );
        term::auto_impl_ccf!(crate ::data_structure::Heap, crate ::data_structure::F);
        term::auto_impl_ccf!(crate ::data_structure::Heap, crate ::data_structure::Sum);
        term::auto_impl_ccf!(crate ::data_structure::Heap, crate ::data_structure::Nat);
        term::auto_impl_ccf!(
            crate ::data_structure::Heap, tymetafuncspec_core::Set < crate
            ::data_structure::Heap, crate ::data_structure::Nat, >
        );
        term::auto_impl_ccf!(
            crate ::data_structure::Heap, tymetafuncspec_core::BoundedNat < crate
            ::data_structure::Heap, >
        );
        term::auto_impl_ccf!(
            crate ::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
            ::data_structure::Heap, crate ::data_structure::F, >
        );
        term::auto_impl_ccf!(
            crate ::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
            ::data_structure::Heap, crate ::data_structure::Plus, >
        );
        term::auto_impl_ccf!(
            crate ::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
            ::data_structure::Heap, crate ::data_structure::Sum, >
        );
    }
    /// generated by [term_specialized_impl_gen::gen_maps_tmf]
    #[rustfmt::skip]
    #[allow(warnings)]
    #[allow(unknown_lints)]
    pub mod maps_tmf_impls {
        impl<
            TmfMonomorphization,
        > term::MapsTmf<crate::term_trait::words::L, TmfMonomorphization>
        for crate::data_structure::Heap
        where
            TmfMonomorphization: term::CanonicallyConstructibleFrom<
                Self,
                (TmfMonomorphization, ()),
            >,
        {
            type Tmf = TmfMonomorphization;
        }
    }
}
