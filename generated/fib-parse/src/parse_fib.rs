#![feature(custom_inner_attributes)]
#![rustfmt::skip]
#![allow(warnings)]
#![allow(unknown_lints)]
//! @generated by [parse_gen::generate]
use parse_adt::ParseLLImplementor;
use typenum::U8;
use parse_adt::cstfy::CstfyTransparent;
use parse_adt::cstfy::Cstfy;
use parse_adt::Parser;
use fib::words_mod_fib::L;
use fib::term_pattern_match_strategy_provider_fib::PatternMatchStrategyProvider;
use crate::term_specialized_cst as tsc;
use crate::parse_fib::fnlut as pff;
/// @generated by [parse_gen::generate_parse]
pub fn plus(source: &str) -> (tsc::Heap, Cstfy<tsc::Heap, tsc::Plus>) {
    let mut parser = parse_adt::Parser::new(source);
    let mut heap = crate::term_specialized_cst::Heap::default();
    let _ = <<Cstfy<tsc::Heap, tsc::Plus> as words::Implements<tsc::Heap, L>>::LWord as parse_adt::NamesParseLLFor<tsc::Plus>>::START;
    let _ = <<Cstfy<tsc::Heap, tsc::Plus> as ParseLLImplementor>::LWord as parse_adt::NamesParseLLFor<tsc::Plus>>::START;
    let _ = <Cstfy<tsc::Heap, tsc::Plus> as parse_adt::ParseLL<_, _>>::START;
    let ret = <Cstfy<
        tsc::Heap,
        tsc::Plus,
    > as term::co_visit::CoVisitable<
        Parser<'_, L, ()>,
        PatternMatchStrategyProvider<tsc::Heap>,
        tsc::Heap,
        U8,
        pff::ParseWitness<'_>,
    >>::co_visit(&mut parser, &mut heap, crate::parse_fib::fnlut::ParseWitness::new());
    (heap, ret)
}
/// @generated by [parse_gen::generate_parse]
pub fn left_operand(source: &str) -> (tsc::Heap, Cstfy<tsc::Heap, tsc::LeftOperand>) {
    let mut parser = parse_adt::Parser::new(source);
    let mut heap = crate::term_specialized_cst::Heap::default();
    let ret = <Cstfy<
        tsc::Heap,
        tsc::LeftOperand,
    > as term::co_visit::CoVisitable<
        Parser<'_, L, ()>,
        PatternMatchStrategyProvider<tsc::Heap>,
        tsc::Heap,
        U8,
        pff::ParseWitness<'_>,
    >>::co_visit(&mut parser, &mut heap, crate::parse_fib::fnlut::ParseWitness::new());
    (heap, ret)
}
/// @generated by [parse_gen::generate_parse]
pub fn right_operand(source: &str) -> (tsc::Heap, Cstfy<tsc::Heap, tsc::RightOperand>) {
    let mut parser = parse_adt::Parser::new(source);
    let mut heap = crate::term_specialized_cst::Heap::default();
    let ret = <Cstfy<
        tsc::Heap,
        tsc::RightOperand,
    > as term::co_visit::CoVisitable<
        Parser<'_, L, ()>,
        PatternMatchStrategyProvider<tsc::Heap>,
        tsc::Heap,
        U8,
        pff::ParseWitness<'_>,
    >>::co_visit(&mut parser, &mut heap, crate::parse_fib::fnlut::ParseWitness::new());
    (heap, ret)
}
/// @generated by [parse_gen::generate_parse]
pub fn f(source: &str) -> (tsc::Heap, Cstfy<tsc::Heap, tsc::F>) {
    let mut parser = parse_adt::Parser::new(source);
    let mut heap = crate::term_specialized_cst::Heap::default();
    let ret = <Cstfy<
        tsc::Heap,
        tsc::F,
    > as term::co_visit::CoVisitable<
        Parser<'_, L, ()>,
        PatternMatchStrategyProvider<tsc::Heap>,
        tsc::Heap,
        U8,
        pff::ParseWitness<'_>,
    >>::co_visit(&mut parser, &mut heap, crate::parse_fib::fnlut::ParseWitness::new());
    (heap, ret)
}
/// @generated by [parse_gen::generate_parse]
pub fn sum(source: &str) -> (tsc::Heap, Cstfy<tsc::Heap, tsc::Sum>) {
    let mut parser = parse_adt::Parser::new(source);
    let mut heap = crate::term_specialized_cst::Heap::default();
    let ret = <Cstfy<
        tsc::Heap,
        tsc::Sum,
    > as term::co_visit::CoVisitable<
        Parser<'_, L, ()>,
        PatternMatchStrategyProvider<tsc::Heap>,
        tsc::Heap,
        U8,
        pff::ParseWitness<'_>,
    >>::co_visit(&mut parser, &mut heap, crate::parse_fib::fnlut::ParseWitness::new());
    (heap, ret)
}
/// @generated by [parse_gen::generate_parse]
pub fn nat(source: &str) -> (tsc::Heap, CstfyTransparent<tsc::Heap, tsc::Nat>) {
    let mut parser = parse_adt::Parser::new(source);
    let mut heap = crate::term_specialized_cst::Heap::default();
    let ret = <CstfyTransparent<
        tsc::Heap,
        tsc::Nat,
    > as term::co_visit::CoVisitable<
        Parser<'_, L, ()>,
        PatternMatchStrategyProvider<tsc::Heap>,
        tsc::Heap,
        U8,
        pff::ParseWitness<'_>,
    >>::co_visit(&mut parser, &mut heap, crate::parse_fib::fnlut::ParseWitness::new());
    (heap, ret)
}
pub mod parsell {
    use parse::KeywordSequence;
    use fib::words_mod_fib::sorts::Sum;
    use fib::words_mod_fib::sorts::RightOperand;
    use fib::words_mod_fib::sorts::Plus;
    use fib::words_mod_fib::sorts::Nat;
    use fib::words_mod_fib::sorts::LeftOperand;
    use fib::words_mod_fib::sorts::F;
    use crate::term_specialized_cst as tsc;
    /// @generated by [parse_gen::generate_parsell]
    impl parse_adt::LookaheadImplementor for tsc::Plus {}
    /// @generated by [parse_gen::generate_parsell]
    impl parse_adt::ParseLLImplementor for tsc::Plus {}
    /// @generated by [parse_gen::generate_parsell]
    impl parse_adt::NamesParseLLFor<tsc::Plus> for Plus {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(plus))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[]);
    }
    /// @generated by [parse_gen::generate_parsell]
    impl parse_adt::LookaheadImplementor for tsc::LeftOperand {}
    /// @generated by [parse_gen::generate_parsell]
    impl parse_adt::ParseLLImplementor for tsc::LeftOperand {}
    /// @generated by [parse_gen::generate_parsell]
    impl parse_adt::NamesParseLLFor<tsc::LeftOperand> for LeftOperand {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(left_operand))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[]);
    }
    /// @generated by [parse_gen::generate_parsell]
    impl parse_adt::LookaheadImplementor for tsc::RightOperand {}
    /// @generated by [parse_gen::generate_parsell]
    impl parse_adt::ParseLLImplementor for tsc::RightOperand {}
    /// @generated by [parse_gen::generate_parsell]
    impl parse_adt::NamesParseLLFor<tsc::RightOperand> for RightOperand {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(right_operand))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[]);
    }
    /// @generated by [parse_gen::generate_parsell]
    impl parse_adt::LookaheadImplementor for tsc::F {}
    /// @generated by [parse_gen::generate_parsell]
    impl parse_adt::ParseLLImplementor for tsc::F {}
    /// @generated by [parse_gen::generate_parsell]
    impl parse_adt::NamesParseLLFor<tsc::F> for F {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(f))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[]);
    }
    /// @generated by [parse_gen::generate_parsell]
    impl parse_adt::LookaheadImplementor for tsc::Sum {}
    /// @generated by [parse_gen::generate_parsell]
    impl parse_adt::ParseLLImplementor for tsc::Sum {}
    /// @generated by [parse_gen::generate_parsell]
    impl parse_adt::NamesParseLLFor<tsc::Sum> for Sum {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(sum))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[]);
    }
    /// @generated by [parse_gen::generate_parsell]
    impl parse_adt::LookaheadImplementor for tsc::Nat {}
    /// @generated by [parse_gen::generate_parsell]
    impl parse_adt::ParseLLImplementor for tsc::Nat {}
    /// @generated by [parse_gen::generate_parsell]
    impl parse_adt::NamesParseLLFor<tsc::Nat> for Nat {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(nat))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[]);
    }
}
pub mod fnlut {
    term::impl_fn_lut!(
        witness_name ParseWitness < 'c >; trait term::co_visit::CoVisitable <
        parse_adt::Parser < 'c, fib::words_mod_fib::L, () >,
        fib::term_pattern_match_strategy_provider_fib::PatternMatchStrategyProvider <
        crate ::term_specialized_cst::Heap >, crate ::term_specialized_cst::Heap,
        typenum::U8, crate ::parse_fib::fnlut::ParseWitness < 'c >, >; fn_name co_visit;
        get for < 'a, 'b > fn (& 'a mut parse_adt::Parser < 'c, () >, & 'b mut crate
        ::term_specialized_cst::Heap, crate ::parse_fib::fnlut::ParseWitness < 'c >) ->
        This; types a0 = tymetafuncspec_core::Either < crate
        ::term_specialized_cst::Heap, tymetafuncspec_core::Pair < crate
        ::term_specialized_cst::Heap, crate ::term_specialized_cst::LeftOperand,
        tymetafuncspec_core::Maybe < crate ::term_specialized_cst::Heap,
        std_parse_metadata::ParseMetadata < crate ::term_specialized_cst::Heap, >, >, >,
        std_parse_error::ParseError < crate ::term_specialized_cst::Heap, >, >, a1 =
        tymetafuncspec_core::Either < crate ::term_specialized_cst::Heap,
        tymetafuncspec_core::Pair < crate ::term_specialized_cst::Heap, crate
        ::term_specialized_cst::RightOperand, tymetafuncspec_core::Maybe < crate
        ::term_specialized_cst::Heap, std_parse_metadata::ParseMetadata < crate
        ::term_specialized_cst::Heap, >, >, >, std_parse_error::ParseError < crate
        ::term_specialized_cst::Heap, >, >, a2 = tymetafuncspec_core::Either < crate
        ::term_specialized_cst::Heap, crate ::term_specialized_cst::Nat,
        std_parse_error::ParseError < crate ::term_specialized_cst::Heap, >, >, a3 =
        tymetafuncspec_core::Either < crate ::term_specialized_cst::Heap,
        tymetafuncspec_core::Pair < crate ::term_specialized_cst::Heap,
        tymetafuncspec_core::Set < crate ::term_specialized_cst::Heap,
        tymetafuncspec_core::Either < crate ::term_specialized_cst::Heap, crate
        ::term_specialized_cst::Nat, std_parse_error::ParseError < crate
        ::term_specialized_cst::Heap, >, >, >, tymetafuncspec_core::Maybe < crate
        ::term_specialized_cst::Heap, std_parse_metadata::ParseMetadata < crate
        ::term_specialized_cst::Heap, >, >, >, std_parse_error::ParseError < crate
        ::term_specialized_cst::Heap, >, >, a4 = tymetafuncspec_core::Either < crate
        ::term_specialized_cst::Heap, tymetafuncspec_core::Pair < crate
        ::term_specialized_cst::Heap, tymetafuncspec_core::BoundedNat < crate
        ::term_specialized_cst::Heap, >, tymetafuncspec_core::Maybe < crate
        ::term_specialized_cst::Heap, std_parse_metadata::ParseMetadata < crate
        ::term_specialized_cst::Heap, >, >, >, std_parse_error::ParseError < crate
        ::term_specialized_cst::Heap, >, >, a5 = tymetafuncspec_core::Either < crate
        ::term_specialized_cst::Heap, tymetafuncspec_core::Pair < crate
        ::term_specialized_cst::Heap, crate ::term_specialized_cst::F,
        tymetafuncspec_core::Maybe < crate ::term_specialized_cst::Heap,
        std_parse_metadata::ParseMetadata < crate ::term_specialized_cst::Heap, >, >, >,
        std_parse_error::ParseError < crate ::term_specialized_cst::Heap, >, >, a6 =
        tymetafuncspec_core::Either < crate ::term_specialized_cst::Heap,
        tymetafuncspec_core::Pair < crate ::term_specialized_cst::Heap, crate
        ::term_specialized_cst::Plus, tymetafuncspec_core::Maybe < crate
        ::term_specialized_cst::Heap, std_parse_metadata::ParseMetadata < crate
        ::term_specialized_cst::Heap, >, >, >, std_parse_error::ParseError < crate
        ::term_specialized_cst::Heap, >, >, a7 = tymetafuncspec_core::Either < crate
        ::term_specialized_cst::Heap, tymetafuncspec_core::Pair < crate
        ::term_specialized_cst::Heap, crate ::term_specialized_cst::Sum,
        tymetafuncspec_core::Maybe < crate ::term_specialized_cst::Heap,
        std_parse_metadata::ParseMetadata < crate ::term_specialized_cst::Heap, >, >, >,
        std_parse_error::ParseError < crate ::term_specialized_cst::Heap, >, >
    );
}
