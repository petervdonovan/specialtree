#![feature(custom_inner_attributes)]
#![rustfmt::skip]
#![allow(warnings)]
#![allow(unknown_lints)]
//! @generated by [parse_gen::generate]
use typenum::U8;
use parse_adt::cstfy::CstfyTransparent;
use parse_adt::cstfy::Cstfy;
use parse_adt::Parser;
use fib::term_pattern_match_strategy_provider_fib::PatternMatchStrategyProvider;
use crate::term_specialized_cst as tsc;
use crate::parse_fib::fnlut as pff;
/// @generated by [parse_gen::generate_parse]
pub fn plus(source: &str) -> (tsc::Heap, Cstfy<tsc::Heap, tsc::Plus>) {
    let mut parser = parse_adt::Parser::new(source);
    let mut heap = crate::term_specialized_cst::Heap::default();
    let ret = <Cstfy<
        tsc::Heap,
        tsc::Plus,
    > as term::co_visit::CoVisitable<
        Parser<'_, ()>,
        PatternMatchStrategyProvider<tsc::Heap>,
        tsc::Heap,
        U8,
        pff::ParseWitness<'_>,
    >>::co_visit(&mut parser, &mut heap, crate::parse_fib::fnlut::ParseWitness::new());
    (heap, ret)
}
/// @generated by [parse_gen::generate_parse]
pub fn left_operand(source: &str) -> (tsc::Heap, Cstfy<tsc::Heap, tsc::LeftOperand>) {
    let mut parser = parse_adt::Parser::new(source);
    let mut heap = crate::term_specialized_cst::Heap::default();
    let ret = <Cstfy<
        tsc::Heap,
        tsc::LeftOperand,
    > as term::co_visit::CoVisitable<
        Parser<'_, ()>,
        PatternMatchStrategyProvider<tsc::Heap>,
        tsc::Heap,
        U8,
        pff::ParseWitness<'_>,
    >>::co_visit(&mut parser, &mut heap, crate::parse_fib::fnlut::ParseWitness::new());
    (heap, ret)
}
/// @generated by [parse_gen::generate_parse]
pub fn right_operand(source: &str) -> (tsc::Heap, Cstfy<tsc::Heap, tsc::RightOperand>) {
    let mut parser = parse_adt::Parser::new(source);
    let mut heap = crate::term_specialized_cst::Heap::default();
    let ret = <Cstfy<
        tsc::Heap,
        tsc::RightOperand,
    > as term::co_visit::CoVisitable<
        Parser<'_, ()>,
        PatternMatchStrategyProvider<tsc::Heap>,
        tsc::Heap,
        U8,
        pff::ParseWitness<'_>,
    >>::co_visit(&mut parser, &mut heap, crate::parse_fib::fnlut::ParseWitness::new());
    (heap, ret)
}
/// @generated by [parse_gen::generate_parse]
pub fn f(source: &str) -> (tsc::Heap, Cstfy<tsc::Heap, tsc::F>) {
    let mut parser = parse_adt::Parser::new(source);
    let mut heap = crate::term_specialized_cst::Heap::default();
    let ret = <Cstfy<
        tsc::Heap,
        tsc::F,
    > as term::co_visit::CoVisitable<
        Parser<'_, ()>,
        PatternMatchStrategyProvider<tsc::Heap>,
        tsc::Heap,
        U8,
        pff::ParseWitness<'_>,
    >>::co_visit(&mut parser, &mut heap, crate::parse_fib::fnlut::ParseWitness::new());
    (heap, ret)
}
/// @generated by [parse_gen::generate_parse]
pub fn sum(source: &str) -> (tsc::Heap, Cstfy<tsc::Heap, tsc::Sum>) {
    let mut parser = parse_adt::Parser::new(source);
    let mut heap = crate::term_specialized_cst::Heap::default();
    let ret = <Cstfy<
        tsc::Heap,
        tsc::Sum,
    > as term::co_visit::CoVisitable<
        Parser<'_, ()>,
        PatternMatchStrategyProvider<tsc::Heap>,
        tsc::Heap,
        U8,
        pff::ParseWitness<'_>,
    >>::co_visit(&mut parser, &mut heap, crate::parse_fib::fnlut::ParseWitness::new());
    (heap, ret)
}
/// @generated by [parse_gen::generate_parse]
pub fn nat(source: &str) -> (tsc::Heap, CstfyTransparent<tsc::Heap, tsc::Nat>) {
    let mut parser = parse_adt::Parser::new(source);
    let mut heap = crate::term_specialized_cst::Heap::default();
    let ret = <CstfyTransparent<
        tsc::Heap,
        tsc::Nat,
    > as term::co_visit::CoVisitable<
        Parser<'_, ()>,
        PatternMatchStrategyProvider<tsc::Heap>,
        tsc::Heap,
        U8,
        pff::ParseWitness<'_>,
    >>::co_visit(&mut parser, &mut heap, crate::parse_fib::fnlut::ParseWitness::new());
    (heap, ret)
}
pub mod parsell {
    use parse::KeywordSequence;
    use crate::term_specialized_cst as tsc;
    impl parse_adt::ParseLL for tsc::Plus {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(plus))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[]);
    }
    impl parse_adt::ParseLL for tsc::LeftOperand {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(left_operand))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[]);
    }
    impl parse_adt::ParseLL for tsc::RightOperand {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(right_operand))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[]);
    }
    impl parse_adt::ParseLL for tsc::F {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(f))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[]);
    }
    impl parse_adt::ParseLL for tsc::Sum {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(sum))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[]);
    }
    impl parse_adt::ParseLL for tsc::Nat {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(nat))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[]);
    }
}
pub mod fnlut {
    term::impl_fn_lut!(
        witness_name ParseWitness < 'c >; trait term::co_visit::CoVisitable <
        parse_adt::Parser < 'c, () >,
        fib::term_pattern_match_strategy_provider_fib::PatternMatchStrategyProvider <
        crate ::term_specialized_cst::Heap >, crate ::term_specialized_cst::Heap,
        typenum::U8, crate ::parse_fib::fnlut::ParseWitness < 'c >, >; fn_name co_visit;
        get for < 'a, 'b > fn (& 'a mut parse_adt::Parser < 'c, () >, & 'b mut crate
        ::term_specialized_cst::Heap, crate ::parse_fib::fnlut::ParseWitness < 'c >) ->
        This; types a0 = tymetafuncspec_core::Either < crate
        ::term_specialized_cst::Heap, tymetafuncspec_core::Pair < crate
        ::term_specialized_cst::Heap, crate ::term_specialized_cst::LeftOperand,
        tymetafuncspec_core::Maybe < crate ::term_specialized_cst::Heap,
        std_parse_metadata::ParseMetadata < crate ::term_specialized_cst::Heap, >, >, >,
        std_parse_error::ParseError < crate ::term_specialized_cst::Heap, >, >, a1 =
        tymetafuncspec_core::Either < crate ::term_specialized_cst::Heap,
        tymetafuncspec_core::Pair < crate ::term_specialized_cst::Heap, crate
        ::term_specialized_cst::RightOperand, tymetafuncspec_core::Maybe < crate
        ::term_specialized_cst::Heap, std_parse_metadata::ParseMetadata < crate
        ::term_specialized_cst::Heap, >, >, >, std_parse_error::ParseError < crate
        ::term_specialized_cst::Heap, >, >, a2 = tymetafuncspec_core::Either < crate
        ::term_specialized_cst::Heap, crate ::term_specialized_cst::Nat,
        std_parse_error::ParseError < crate ::term_specialized_cst::Heap, >, >, a3 =
        tymetafuncspec_core::Either < crate ::term_specialized_cst::Heap,
        tymetafuncspec_core::Pair < crate ::term_specialized_cst::Heap,
        tymetafuncspec_core::Set < crate ::term_specialized_cst::Heap,
        tymetafuncspec_core::Either < crate ::term_specialized_cst::Heap, crate
        ::term_specialized_cst::Nat, std_parse_error::ParseError < crate
        ::term_specialized_cst::Heap, >, >, >, tymetafuncspec_core::Maybe < crate
        ::term_specialized_cst::Heap, std_parse_metadata::ParseMetadata < crate
        ::term_specialized_cst::Heap, >, >, >, std_parse_error::ParseError < crate
        ::term_specialized_cst::Heap, >, >, a4 = tymetafuncspec_core::Either < crate
        ::term_specialized_cst::Heap, tymetafuncspec_core::Pair < crate
        ::term_specialized_cst::Heap, tymetafuncspec_core::BoundedNat < crate
        ::term_specialized_cst::Heap, >, tymetafuncspec_core::Maybe < crate
        ::term_specialized_cst::Heap, std_parse_metadata::ParseMetadata < crate
        ::term_specialized_cst::Heap, >, >, >, std_parse_error::ParseError < crate
        ::term_specialized_cst::Heap, >, >, a5 = tymetafuncspec_core::Either < crate
        ::term_specialized_cst::Heap, tymetafuncspec_core::Pair < crate
        ::term_specialized_cst::Heap, crate ::term_specialized_cst::F,
        tymetafuncspec_core::Maybe < crate ::term_specialized_cst::Heap,
        std_parse_metadata::ParseMetadata < crate ::term_specialized_cst::Heap, >, >, >,
        std_parse_error::ParseError < crate ::term_specialized_cst::Heap, >, >, a6 =
        tymetafuncspec_core::Either < crate ::term_specialized_cst::Heap,
        tymetafuncspec_core::Pair < crate ::term_specialized_cst::Heap, crate
        ::term_specialized_cst::Plus, tymetafuncspec_core::Maybe < crate
        ::term_specialized_cst::Heap, std_parse_metadata::ParseMetadata < crate
        ::term_specialized_cst::Heap, >, >, >, std_parse_error::ParseError < crate
        ::term_specialized_cst::Heap, >, >, a7 = tymetafuncspec_core::Either < crate
        ::term_specialized_cst::Heap, tymetafuncspec_core::Pair < crate
        ::term_specialized_cst::Heap, crate ::term_specialized_cst::Sum,
        tymetafuncspec_core::Maybe < crate ::term_specialized_cst::Heap,
        std_parse_metadata::ParseMetadata < crate ::term_specialized_cst::Heap, >, >, >,
        std_parse_error::ParseError < crate ::term_specialized_cst::Heap, >, >
    );
}
