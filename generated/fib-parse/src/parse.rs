#![feature(custom_inner_attributes)]
#![rustfmt::skip]
#![allow(warnings)]
#![allow(unknown_lints)]
//! @generated by [parse_gen::generate]
use typenum::U8;
use parse_adt::cstfy::CstfyTransparent;
use parse_adt::cstfy::Cstfy;
use parse_adt::Parser;
use fib::pattern_match_strategy::PatternMatchStrategyProvider;
use crate::parse::fnlut as pf;
use crate::data_structure as ds;
/// @generated by [parse_gen::generate_parse]
pub fn plus(source: &str) -> (ds::Heap, Cstfy<ds::Heap, ds::Plus>) {
    let mut parser = parse_adt::Parser::new(source);
    let mut heap = crate::data_structure::Heap::default();
    let ret = <Cstfy<
        ds::Heap,
        ds::Plus,
    > as term::co_visit::CoVisitable<
        Parser<'_, ()>,
        PatternMatchStrategyProvider<ds::Heap>,
        ds::Heap,
        U8,
        pf::ParseWitness<'_>,
    >>::co_visit(&mut parser, &mut heap, crate::parse::fnlut::ParseWitness::new());
    (heap, ret)
}
/// @generated by [parse_gen::generate_parse]
pub fn left_operand(source: &str) -> (ds::Heap, Cstfy<ds::Heap, ds::LeftOperand>) {
    let mut parser = parse_adt::Parser::new(source);
    let mut heap = crate::data_structure::Heap::default();
    let ret = <Cstfy<
        ds::Heap,
        ds::LeftOperand,
    > as term::co_visit::CoVisitable<
        Parser<'_, ()>,
        PatternMatchStrategyProvider<ds::Heap>,
        ds::Heap,
        U8,
        pf::ParseWitness<'_>,
    >>::co_visit(&mut parser, &mut heap, crate::parse::fnlut::ParseWitness::new());
    (heap, ret)
}
/// @generated by [parse_gen::generate_parse]
pub fn right_operand(source: &str) -> (ds::Heap, Cstfy<ds::Heap, ds::RightOperand>) {
    let mut parser = parse_adt::Parser::new(source);
    let mut heap = crate::data_structure::Heap::default();
    let ret = <Cstfy<
        ds::Heap,
        ds::RightOperand,
    > as term::co_visit::CoVisitable<
        Parser<'_, ()>,
        PatternMatchStrategyProvider<ds::Heap>,
        ds::Heap,
        U8,
        pf::ParseWitness<'_>,
    >>::co_visit(&mut parser, &mut heap, crate::parse::fnlut::ParseWitness::new());
    (heap, ret)
}
/// @generated by [parse_gen::generate_parse]
pub fn f(source: &str) -> (ds::Heap, Cstfy<ds::Heap, ds::F>) {
    let mut parser = parse_adt::Parser::new(source);
    let mut heap = crate::data_structure::Heap::default();
    let ret = <Cstfy<
        ds::Heap,
        ds::F,
    > as term::co_visit::CoVisitable<
        Parser<'_, ()>,
        PatternMatchStrategyProvider<ds::Heap>,
        ds::Heap,
        U8,
        pf::ParseWitness<'_>,
    >>::co_visit(&mut parser, &mut heap, crate::parse::fnlut::ParseWitness::new());
    (heap, ret)
}
/// @generated by [parse_gen::generate_parse]
pub fn sum(source: &str) -> (ds::Heap, Cstfy<ds::Heap, ds::Sum>) {
    let mut parser = parse_adt::Parser::new(source);
    let mut heap = crate::data_structure::Heap::default();
    let ret = <Cstfy<
        ds::Heap,
        ds::Sum,
    > as term::co_visit::CoVisitable<
        Parser<'_, ()>,
        PatternMatchStrategyProvider<ds::Heap>,
        ds::Heap,
        U8,
        pf::ParseWitness<'_>,
    >>::co_visit(&mut parser, &mut heap, crate::parse::fnlut::ParseWitness::new());
    (heap, ret)
}
/// @generated by [parse_gen::generate_parse]
pub fn nat(source: &str) -> (ds::Heap, CstfyTransparent<ds::Heap, ds::Nat>) {
    let mut parser = parse_adt::Parser::new(source);
    let mut heap = crate::data_structure::Heap::default();
    let ret = <CstfyTransparent<
        ds::Heap,
        ds::Nat,
    > as term::co_visit::CoVisitable<
        Parser<'_, ()>,
        PatternMatchStrategyProvider<ds::Heap>,
        ds::Heap,
        U8,
        pf::ParseWitness<'_>,
    >>::co_visit(&mut parser, &mut heap, crate::parse::fnlut::ParseWitness::new());
    (heap, ret)
}
pub mod parsell {
    use parse::KeywordSequence;
    use crate::data_structure as ds;
    impl parse_adt::ParseLL for ds::Plus {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(plus))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[]);
    }
    impl parse_adt::ParseLL for ds::LeftOperand {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(left_operand))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[]);
    }
    impl parse_adt::ParseLL for ds::RightOperand {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(right_operand))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[]);
    }
    impl parse_adt::ParseLL for ds::F {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(f))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[]);
    }
    impl parse_adt::ParseLL for ds::Sum {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(sum))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[]);
    }
    impl parse_adt::ParseLL for ds::Nat {
        const START: KeywordSequence = parse::KeywordSequence(
            &[parse::Keyword::new(stringify!(nat))],
        );
        const PROCEED: &'static [KeywordSequence] = &[];
        const END: KeywordSequence = parse::KeywordSequence(&[]);
    }
}
pub mod fnlut {
    term::impl_fn_lut!(
        witness_name ParseWitness < 'c >; trait term::co_visit::CoVisitable <
        parse_adt::Parser < 'c, () >,
        fib::pattern_match_strategy::PatternMatchStrategyProvider < crate
        ::data_structure::Heap >, crate ::data_structure::Heap, typenum::U8, crate
        ::parse::fnlut::ParseWitness < 'c >, >; fn_name co_visit; get for < 'a, 'b > fn
        (& 'a mut parse_adt::Parser < 'c, () >, & 'b mut crate ::data_structure::Heap,
        crate ::parse::fnlut::ParseWitness < 'c >) -> This; types a0 =
        tymetafuncspec_core::Either < crate ::data_structure::Heap,
        tymetafuncspec_core::Pair < crate ::data_structure::Heap, crate
        ::data_structure::LeftOperand, tymetafuncspec_core::Maybe < crate
        ::data_structure::Heap, std_parse_metadata::ParseMetadata < crate
        ::data_structure::Heap, >, >, >, std_parse_error::ParseError < crate
        ::data_structure::Heap, >, >, a1 = tymetafuncspec_core::Either < crate
        ::data_structure::Heap, tymetafuncspec_core::Pair < crate ::data_structure::Heap,
        crate ::data_structure::RightOperand, tymetafuncspec_core::Maybe < crate
        ::data_structure::Heap, std_parse_metadata::ParseMetadata < crate
        ::data_structure::Heap, >, >, >, std_parse_error::ParseError < crate
        ::data_structure::Heap, >, >, a2 = tymetafuncspec_core::Either < crate
        ::data_structure::Heap, crate ::data_structure::Nat, std_parse_error::ParseError
        < crate ::data_structure::Heap, >, >, a3 = tymetafuncspec_core::Either < crate
        ::data_structure::Heap, tymetafuncspec_core::Pair < crate ::data_structure::Heap,
        tymetafuncspec_core::Set < crate ::data_structure::Heap,
        tymetafuncspec_core::Either < crate ::data_structure::Heap, crate
        ::data_structure::Nat, std_parse_error::ParseError < crate
        ::data_structure::Heap, >, >, >, tymetafuncspec_core::Maybe < crate
        ::data_structure::Heap, std_parse_metadata::ParseMetadata < crate
        ::data_structure::Heap, >, >, >, std_parse_error::ParseError < crate
        ::data_structure::Heap, >, >, a4 = tymetafuncspec_core::Either < crate
        ::data_structure::Heap, tymetafuncspec_core::Pair < crate ::data_structure::Heap,
        tymetafuncspec_core::BoundedNat < crate ::data_structure::Heap, >,
        tymetafuncspec_core::Maybe < crate ::data_structure::Heap,
        std_parse_metadata::ParseMetadata < crate ::data_structure::Heap, >, >, >,
        std_parse_error::ParseError < crate ::data_structure::Heap, >, >, a5 =
        tymetafuncspec_core::Either < crate ::data_structure::Heap,
        tymetafuncspec_core::Pair < crate ::data_structure::Heap, crate
        ::data_structure::F, tymetafuncspec_core::Maybe < crate ::data_structure::Heap,
        std_parse_metadata::ParseMetadata < crate ::data_structure::Heap, >, >, >,
        std_parse_error::ParseError < crate ::data_structure::Heap, >, >, a6 =
        tymetafuncspec_core::Either < crate ::data_structure::Heap,
        tymetafuncspec_core::Pair < crate ::data_structure::Heap, crate
        ::data_structure::Plus, tymetafuncspec_core::Maybe < crate
        ::data_structure::Heap, std_parse_metadata::ParseMetadata < crate
        ::data_structure::Heap, >, >, >, std_parse_error::ParseError < crate
        ::data_structure::Heap, >, >, a7 = tymetafuncspec_core::Either < crate
        ::data_structure::Heap, tymetafuncspec_core::Pair < crate ::data_structure::Heap,
        crate ::data_structure::Sum, tymetafuncspec_core::Maybe < crate
        ::data_structure::Heap, std_parse_metadata::ParseMetadata < crate
        ::data_structure::Heap, >, >, >, std_parse_error::ParseError < crate
        ::data_structure::Heap, >, >
    );
}
