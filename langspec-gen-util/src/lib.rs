use langspec::langspec::Name;
use langspec::tymetafunc::{IdentifiedBy, RustTyMap, Transparency, TyMetaFuncSpec};
use langspec::{
    langspec::{AlgebraicSortId, LangSpec, MappedType, SortId, SortIdOf},
    tymetafunc::TyMetaFuncData,
};

pub use proc_macro2;
use term::{CcfRelation, MctRelation, TyFingerprint};

#[macro_export]
macro_rules! byline {
    () => {{
        let ret: $crate::proc_macro2::TokenStream =
            format!("/// generated by [{}]", $crate::function!())
                .parse()
                .unwrap();
        ret
    }};
}
#[macro_export]
macro_rules! function {
    () => {{
        fn f() {}
        fn type_name_of<T>(_: T) -> &'static str {
            std::any::type_name::<T>()
        }
        let name = type_name_of(f);
        name.strip_suffix("::f")
            .unwrap()
            .trim_end_matches("::{{closure}}")
    }};
}
#[macro_export]
macro_rules! transpose {
    ($records:expr, $($field:ident),*) => {
        $(
            let mut $field = vec![];
        )*
        for record67142647 in $records {
            $(
                $field.push(record67142647.$field);
            )*
        }
        $(
            let $field = $field;
        )*
    };
}

pub struct TyGenData<'a, L: LangSpec> {
    pub id: Option<AlgebraicSortId<L::ProductId, L::SumId>>,
    pub fingerprint: TyFingerprint,
    pub snake_ident: syn::Ident,
    pub camel_ident: syn::Ident,
    pub cmt: CanonicallyMaybeToGenData<'a>,
    pub ccf: CanonicallyConstructibleFromGenData<'a>,
    pub transparency: Transparency,
}
pub struct HeapbakGenData<'a> {
    pub identifiers: Vec<syn::Ident>,
    pub ty_func: RustTyMap,
    pub ty_arg_camels: Vec<syn::Ident>,
    pub ty_args: Box<dyn Fn(HeapType, AlgebraicsBasePath) -> Vec<syn::Type> + 'a>,
}
pub struct CanonicallyMaybeToGenData<'a> {
    pub cmt_sort_tys: Box<dyn Fn(HeapType, AlgebraicsBasePath) -> Vec<syn::Type> + 'a>,
    pub algebraic_cmt_sort_tys: Box<dyn Fn(HeapType, AlgebraicsBasePath) -> Vec<syn::Type> + 'a>,
}
#[derive(Clone)]
pub struct AlgebraicsBasePath(proc_macro2::TokenStream); // a prefix of a syn::TypePath
impl AlgebraicsBasePath {
    pub fn new(bp: proc_macro2::TokenStream) -> Self {
        if !(bp.to_string().is_empty() || bp.to_string().ends_with("::")) {
            panic!(
                "AlgebraicsBasePath must end with '::' but instead is \"{}\"",
                bp
            );
        }
        Self(bp)
    }
    pub fn to_token_stream(&self) -> proc_macro2::TokenStream {
        self.0.clone()
    }
}
pub struct HeapType(pub syn::Type);
pub struct CanonicallyConstructibleFromGenData<'a> {
    pub ccf_sort_tys: Box<dyn Fn(HeapType, AlgebraicsBasePath) -> Vec<syn::Type> + 'a>,
    pub heap_sort_tys: Box<dyn Fn(HeapType, AlgebraicsBasePath) -> Vec<HstData> + 'a>,
    pub ccf_sort_tyses: Box<dyn Fn(HeapType, AlgebraicsBasePath) -> Vec<Vec<syn::Type>> + 'a>,
    pub ccf_sort_transparencies: Box<dyn Fn() -> Vec<Vec<Transparency>> + 'a>,
    pub ccf_sort_camel_idents: Box<dyn Fn() -> Vec<Vec<syn::Ident>> + 'a>,
    pub ccf_sort_snake_idents: Box<dyn Fn() -> Vec<Vec<syn::Ident>> + 'a>,
}
pub struct HstData {
    pub heap_sort_ty: syn::Type,
    pub heap_sort_snake_ident: syn::Ident,
    pub heap_sort_camel_ident: syn::Ident,
}
pub struct LsGen<'a, L: LangSpec> {
    bak: &'a L,
    pub direct_ccf_rels: Vec<CcfRelation>,
    pub direct_mc_rels: Vec<MctRelation>,
}
impl<'a, L: LangSpec> From<&'a L> for LsGen<'a, L> {
    fn from(bak: &'a L) -> Self {
        Self {
            bak,
            direct_ccf_rels: get_direct_ccf_rels(bak),
            direct_mc_rels: get_direct_mc_rels(bak),
        }
    }
}
impl<L: LangSpec> LsGen<'_, L> {
    pub fn bak(&self) -> &L {
        self.bak
    }
    pub fn ty_gen_datas(&self) -> impl Iterator<Item = TyGenData<'_, L>> {
        self.bak
            .products()
            .map(move |pid| TyGenData {
                id: Some(AlgebraicSortId::Product(pid.clone())),
                fingerprint: pid_fingerprint(self.bak, &pid),
                snake_ident: syn::Ident::new(
                    &self.bak.product_name(pid.clone()).snake.clone(),
                    proc_macro2::Span::call_site(),
                ),
                camel_ident: syn::Ident::new(
                    &self.bak.product_name(pid.clone()).camel.clone(),
                    proc_macro2::Span::call_site(),
                ),
                cmt: CanonicallyMaybeToGenData {
                    cmt_sort_tys: {
                        let pidc = pid.clone();
                        Box::new(move |ht, abp| {
                            self.bak
                                .product_sorts(pidc.clone())
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp))
                                .collect()
                        })
                    },
                    algebraic_cmt_sort_tys: {
                        let pidc = pid.clone();
                        Box::new(move |ht, abp| {
                            algebraics(self.bak.product_sorts(pidc.clone()))
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp))
                                .collect()
                        })
                    },
                },
                ccf: CanonicallyConstructibleFromGenData {
                    ccf_sort_tys: Box::new({
                        let pid = pid.clone();
                        move |ht, abp| {
                            let fields_tys = self
                                .bak
                                .product_sorts(pid.clone())
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp));
                            vec![syn::parse_quote! {
                                (#( #fields_tys, )*)
                            }]
                        }
                    }),
                    ccf_sort_transparencies: {
                        let pid = pid.clone();
                        Box::new(move || {
                            vec![self
                                .bak
                                .product_sorts(pid.clone())
                                .map(|sort| self.sort2transparency(sort))
                                .collect()]
                        })
                    },
                    heap_sort_tys: Box::new({
                        let pid = pid.clone();
                        move |ht, abp| {
                            self.bak
                                .product_sorts(pid.clone())
                                .zip(
                                    (self.product_heap_sort_camel_idents(&pid).into_iter())
                                        .zip(self.product_heap_sort_snake_idents(&pid)),
                                )
                                .filter_map(|(sort, (camel, snake))| {
                                    self.sort2heap_ty(sort, &ht, &abp)
                                        .map(|heap_sort_ty| HstData {
                                            heap_sort_ty,
                                            heap_sort_snake_ident: snake,
                                            heap_sort_camel_ident: camel,
                                        })
                                })
                                .collect()
                        }
                    }),
                    ccf_sort_tyses: Box::new({
                        let pid = pid.clone();
                        move |ht, abp| {
                            vec![self
                                .bak
                                .product_sorts(pid.clone())
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp))
                                .collect()]
                        }
                    }),
                    ccf_sort_camel_idents: Box::new({
                        let pid = pid.clone();
                        move || vec![self.product_heap_sort_camel_idents(&pid)]
                    }),
                    ccf_sort_snake_idents: Box::new(move || {
                        vec![self.product_heap_sort_snake_idents(&pid)]
                    }),
                },
                transparency: Transparency::Visible,
            })
            .chain(self.bak.sums().map(move |sid| TyGenData {
                id: Some(AlgebraicSortId::Sum(sid.clone())),
                fingerprint: sid_fingerprint(self.bak, &sid),
                snake_ident: syn::Ident::new(
                    &self.bak.sum_name(sid.clone()).snake.clone(),
                    proc_macro2::Span::call_site(),
                ),
                camel_ident: syn::Ident::new(
                    &self.bak.sum_name(sid.clone()).camel.clone(),
                    proc_macro2::Span::call_site(),
                ),
                cmt: CanonicallyMaybeToGenData {
                    cmt_sort_tys: {
                        let sidc = sid.clone();
                        Box::new(move |ht, abp| {
                            self.bak
                                .sum_sorts(sidc.clone())
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp))
                                .collect()
                        })
                    },
                    algebraic_cmt_sort_tys: {
                        let sidc = sid.clone();
                        Box::new(move |ht, abp| {
                            algebraics(self.bak.sum_sorts(sidc.clone()))
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp))
                                .collect()
                        })
                    },
                },
                ccf: CanonicallyConstructibleFromGenData {
                    ccf_sort_tys: Box::new({
                        let sid = sid.clone();
                        move |ht, abp| {
                            self.bak
                                .sum_sorts(sid.clone())
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp))
                                .map(|ty| syn::parse_quote! { (#ty,) })
                                .collect()
                        }
                    }),
                    heap_sort_tys: Box::new({
                        let sid = sid.clone();
                        move |ht, abp| {
                            self.bak
                                .sum_sorts(sid.clone())
                                .zip(
                                    (self.sum_heap_sort_camel_idents(&sid).into_iter())
                                        .zip(self.sum_heap_sort_snake_idents(&sid)),
                                )
                                .filter_map(|(sort, (camel, snake))| {
                                    self.sort2heap_ty(sort, &ht, &abp)
                                        .map(|heap_sort_ty| HstData {
                                            heap_sort_ty,
                                            heap_sort_snake_ident: snake,
                                            heap_sort_camel_ident: camel,
                                        })
                                })
                                .collect()
                        }
                    }),
                    ccf_sort_transparencies: {
                        let sid = sid.clone();
                        Box::new(move || {
                            self.bak
                                .sum_sorts(sid.clone())
                                .map(|it| vec![self.sort2transparency(it)])
                                .collect()
                        })
                    },
                    ccf_sort_tyses: Box::new({
                        let sid = sid.clone();
                        move |ht, abp| {
                            self.bak
                                .sum_sorts(sid.clone())
                                .map(|sort| vec![self.sort2rs_ty(sort.clone(), &ht, &abp)])
                                .collect()
                        }
                    }),
                    ccf_sort_camel_idents: Box::new({
                        let sid = sid.clone();
                        move || {
                            self.sum_heap_sort_camel_idents(&sid)
                                .into_iter()
                                .map(|it| vec![it])
                                .collect()
                        }
                    }),
                    ccf_sort_snake_idents: Box::new(move || {
                        self.sum_heap_sort_snake_idents(&sid)
                            .into_iter()
                            .map(|it| vec![it])
                            .collect()
                    }),
                },
                transparency: Transparency::Transparent,
            }))
    }
    pub fn heapbak_gen_datas(&self) -> Vec<HeapbakGenData> {
        let mut found: std::collections::HashSet<TyFingerprint> = std::collections::HashSet::new();
        let mut ret: Vec<HeapbakGenData> = vec![];
        fn process_tmf<'a: 'b, 'b, L: LangSpec>(
            lg: &'a LsGen<L>,
            ret: &'b mut Vec<HeapbakGenData<'a>>,
            found: &mut std::collections::HashSet<TyFingerprint>,
            sort: SortIdOf<L>,
        ) {
            match sort.clone() {
                SortId::Algebraic(_) => (),
                SortId::TyMetaFunc(MappedType { f, a }) => {
                    let fingerprint = sortid_fingerprint(lg.bak, &sort);
                    if found.contains(&fingerprint) {
                        return;
                    }
                    found.insert(fingerprint);
                    let polish_name = sortid_polish_name(lg.bak, &sort);
                    let ty_arg_camels = polish_name
                        .iter()
                        .map(|name| syn::Ident::new(&name.camel, proc_macro2::Span::call_site()))
                        .collect();
                    let ty_arg_snakes = polish_name
                        .iter()
                        .map(|name| syn::Ident::new(&name.snake, proc_macro2::Span::call_site()));
                    let ty_func = <L::Tmfs as TyMetaFuncSpec>::ty_meta_func_data(&f).heapbak;
                    let snake_ident = syn::Ident::new(
                        &<L::Tmfs as TyMetaFuncSpec>::ty_meta_func_data(&f)
                            .name
                            .snake,
                        proc_macro2::Span::call_site(),
                    );
                    ret.push(HeapbakGenData {
                        identifiers: std::iter::once(snake_ident).chain(ty_arg_snakes).collect(),
                        ty_func,
                        ty_arg_camels,
                        ty_args: Box::new({
                            let a = a.clone();
                            move |ht, abp| {
                                a.iter()
                                    .map(|arg| lg.sort2rs_ty(arg.clone(), &ht, &abp))
                                    .collect()
                            }
                        }),
                    });
                    for arg in a {
                        process_tmf::<L>(lg, ret, found, arg);
                    }
                }
            }
        }
        for sort in self
            .bak
            .products()
            .flat_map(|pid| self.bak.product_sorts(pid))
            .chain(self.bak.sums().flat_map(|sid| self.bak.sum_sorts(sid)))
        {
            process_tmf::<L>(self, &mut ret, &mut found, sort);
        }
        ret
    }
    pub fn sort2rs_ty(
        &self,
        sort: SortIdOf<L>,
        ht: &HeapType,
        abp: &AlgebraicsBasePath,
    ) -> syn::Type {
        match sort {
            SortId::Algebraic(asi) => {
                let name = self.bak.algebraic_sort_name(asi);
                let ident = syn::Ident::new(&name.camel, proc_macro2::Span::call_site());
                let abp = &abp.0;
                syn::parse_quote! { #abp #ident }
            }
            SortId::TyMetaFunc(MappedType { f, a }) => {
                let TyMetaFuncData {
                    imp: RustTyMap { ty_func },
                    ..
                } = L::Tmfs::ty_meta_func_data(&f);
                let args = a.iter().map(|arg| self.sort2rs_ty(arg.clone(), ht, abp));
                let ht = &ht.0;
                syn::parse_quote! { #ty_func<#ht, #( #args, )* > }
            }
        }
    }
    pub fn sort2heap_ty(
        &self,
        sort: SortIdOf<L>,
        ht: &HeapType,
        abp: &AlgebraicsBasePath,
    ) -> Option<syn::Type> {
        match sort {
            SortId::Algebraic(_) => None,
            SortId::TyMetaFunc(MappedType { f, a }) => {
                let TyMetaFuncData {
                    heapbak: RustTyMap { ty_func },
                    ..
                } = L::Tmfs::ty_meta_func_data(&f);
                let args = a.iter().map(|arg| self.sort2rs_ty(arg.clone(), ht, abp));
                let ht = &ht.0;
                Some(syn::parse_quote! { #ty_func<#ht, #( #args, )* > })
            }
        }
    }
    pub fn sort2transparency(&self, sort: SortIdOf<L>) -> Transparency {
        match sort {
            SortId::Algebraic(AlgebraicSortId::Sum(_)) => Transparency::Transparent,
            SortId::Algebraic(AlgebraicSortId::Product(_)) => Transparency::Visible,
            SortId::TyMetaFunc(MappedType { f, a: _ }) => {
                L::Tmfs::ty_meta_func_data(&f).transparency
            }
        }
    }
    fn product_heap_sort_camel_idents(&self, pid: &L::ProductId) -> Vec<syn::Ident> {
        self.bak
            .product_sorts(pid.clone())
            .map(|sort| sort_ident(self, sort, |name| name.camel.clone()))
            .collect()
    }
    fn product_heap_sort_snake_idents(&self, pid: &L::ProductId) -> Vec<syn::Ident> {
        self.bak
            .product_sorts(pid.clone())
            .map(|sort| sort_ident(self, sort, |name| name.snake.clone()))
            .collect()
    }
    fn sum_heap_sort_camel_idents(&self, sid: &L::SumId) -> Vec<syn::Ident> {
        self.bak
            .sum_sorts(sid.clone())
            .map(|sort| sort_ident(self, sort, |name| name.camel.clone()))
            .collect()
    }
    fn sum_heap_sort_snake_idents(&self, sid: &L::SumId) -> Vec<syn::Ident> {
        self.bak
            .sum_sorts(sid.clone())
            .map(|sort| sort_ident(self, sort, |name| name.snake.clone()))
            .collect()
    }
    pub fn find_transitive_mct_rel(&self, target: &MctRelation) -> Option<ConversionPath> {
        // breadth-first search
        // FIXME: handle non-uniqueness
        struct FrontierEntry {
            node: TyFingerprint,
            path: ConversionPath,
        }
        let mut frontier = vec![FrontierEntry {
            node: target.from,
            path: ConversionPath(vec![]),
        }];
        let mut visited = std::collections::HashSet::new();
        visited.insert(target.from);
        while !frontier.is_empty() {
            let mut new_frontier = vec![];
            for FrontierEntry {
                node: frontier,
                path,
            } in frontier.iter()
            {
                if *frontier == target.to {
                    return Some(path.clone());
                }
                for rel in self.direct_mc_rels.iter() {
                    if rel.from == *frontier && !visited.contains(&rel.to) {
                        let mut new_path = path.clone();
                        new_path.0.push(rel.from);
                        new_frontier.push(FrontierEntry {
                            node: rel.to,
                            path: new_path,
                        });
                        visited.insert(rel.to);
                    }
                }
            }
            frontier = new_frontier;
        }
        None
    }
    pub fn find_transitive_ccf_rel(
        &self,
        target: &CcfRelation,
    ) -> Option<TransitiveCcfConversionPaths> {
        // breadth-first search
        struct FrontierEntry {
            node: TyFingerprint,
            path: ConversionPath,
        }
        struct Frontier(Vec<FrontierEntry>);
        struct FrontierSet {
            multiway_rel: CcfRelation,
            paths: Vec<Frontier>,
        }
        let mut frontierses = self
            .direct_ccf_rels
            .iter()
            .filter_map(|rel| {
                if rel.to == target.to && rel.from.len() == target.from.len() {
                    Some(FrontierSet {
                        multiway_rel: rel.clone(),
                        paths: rel
                            .from
                            .iter()
                            .map(|from| {
                                Frontier(vec![FrontierEntry {
                                    node: *from,
                                    path: ConversionPath(vec![]),
                                }])
                            })
                            .collect(),
                    })
                } else {
                    None
                }
            })
            .collect::<Vec<_>>();
        while !frontierses.is_empty() {
            for fs in frontierses.iter_mut() {
                let mut new_frontiers = vec![];
                for (target_from, Frontier(frontier)) in target.from.iter().zip(fs.paths.iter_mut())
                {
                    let mut new_frontier = vec![];
                    for FrontierEntry { node, path } in frontier.iter() {
                        if node == target_from {
                            if frontier.len() > 1 {
                                new_frontier = vec![FrontierEntry {
                                    node: *node,
                                    path: path.clone(),
                                }];
                            }
                            continue;
                        }
                        for rel in self
                            .direct_ccf_rels
                            .iter()
                            .filter(|rel| rel.from.len() == 1)
                        {
                            if rel.to == *node {
                                let mut new_path = path.clone();
                                new_path.0.push(*node);
                                new_frontier.push(FrontierEntry {
                                    node: *rel.from.first().unwrap(),
                                    path: new_path,
                                });
                            }
                        }
                    }
                    new_frontiers.push(Frontier(new_frontier));
                }
                fs.paths = new_frontiers;
            }
        }
        frontierses.iter().find_map(|fs| {
            let successful_paths = fs
                .paths
                .iter()
                .zip(target.from.iter())
                .filter_map(|(frontier, target)| {
                    if frontier.0.len() == 1 && frontier.0.first().unwrap().node == *target {
                        Some(frontier.0.first().unwrap().path.clone())
                    } else {
                        None
                    }
                })
                .collect::<Vec<_>>();
            if successful_paths.len() == target.from.len() {
                Some(TransitiveCcfConversionPaths {
                    multiway_rel: fs.multiway_rel.clone(),
                    paths: successful_paths,
                })
            } else {
                None
            }
        })
    }
}
#[derive(Clone)]
pub struct ConversionPath(pub Vec<TyFingerprint>);
pub struct TransitiveCcfConversionPaths {
    pub multiway_rel: CcfRelation,
    pub paths: Vec<ConversionPath>,
}
fn sort_ident<L: LangSpec>(
    alg: &LsGen<L>,
    sort: SortIdOf<L>,
    get_ident: fn(&Name) -> String,
) -> proc_macro2::Ident {
    // &sortid_name(&self.bak, sort.clone()).camel.clone(),
    match &sort {
        SortId::Algebraic(asi) => syn::Ident::new(
            &get_ident(alg.bak.algebraic_sort_name(asi.clone())),
            proc_macro2::Span::call_site(),
        ),
        SortId::TyMetaFunc(MappedType { f, a }) => {
            let TyMetaFuncData { name, idby, .. } = L::Tmfs::ty_meta_func_data(f);
            syn::Ident::new(
                &match idby {
                    IdentifiedBy::Tmf => get_ident(&name),
                    IdentifiedBy::FirstTmfArg => {
                        let arg = a.first().unwrap();
                        let name = sortid_name(alg.bak, arg);
                        get_ident(&name)
                    }
                },
                proc_macro2::Span::call_site(),
            )
        }
    }
}

pub fn number_range(n: usize) -> impl Iterator<Item = syn::LitInt> {
    (0..n).map(|i| syn::LitInt::new(&i.to_string(), proc_macro2::Span::call_site()))
}

fn algebraics<
    ProductId: Clone + 'static,
    SumId: Clone + 'static,
    TyMetaFuncId: Clone + 'static,
    I: Iterator<Item = SortId<ProductId, SumId, TyMetaFuncId>>,
>(
    it: I,
) -> impl Iterator<Item = SortId<ProductId, SumId, TyMetaFuncId>> {
    it.flat_map(|sort| match &sort {
        SortId::Algebraic(_) => {
            Box::new(std::iter::once(sort.clone())) as Box<dyn Iterator<Item = _>>
        }
        SortId::TyMetaFunc(mapped_type) => Box::new(mapped_type.a.clone().into_iter()),
    })
}

fn pid_fingerprint<L: LangSpec>(ls: &L, pid: &L::ProductId) -> TyFingerprint {
    TyFingerprint::from(ls.product_name(pid.clone()).camel.as_str())
}
fn sid_fingerprint<L: LangSpec>(ls: &L, sid: &L::SumId) -> TyFingerprint {
    TyFingerprint::from(ls.sum_name(sid.clone()).camel.as_str())
}
fn asi_fingerprint<L: LangSpec>(
    ls: &L,
    asi: &AlgebraicSortId<L::ProductId, L::SumId>,
) -> TyFingerprint {
    match asi {
        AlgebraicSortId::Product(pid) => pid_fingerprint(ls, pid),
        AlgebraicSortId::Sum(sid) => sid_fingerprint(ls, sid),
    }
}
fn sortid_fingerprint<L: LangSpec>(ls: &L, sort: &SortIdOf<L>) -> TyFingerprint {
    match sort {
        SortId::Algebraic(asi) => asi_fingerprint(ls, asi),
        SortId::TyMetaFunc(MappedType { f, a }) => {
            let mut fingerprint =
                TyFingerprint::from(L::Tmfs::ty_meta_func_data(f).name.camel.as_str());
            for arg in a {
                fingerprint = fingerprint.combine(&sortid_fingerprint(ls, arg));
            }
            fingerprint
        }
    }
}
fn sortid_name<L: LangSpec>(ls: &L, sort: &SortIdOf<L>) -> Name {
    match sort {
        SortId::Algebraic(asi) => ls.algebraic_sort_name(asi.clone()).clone(),
        SortId::TyMetaFunc(MappedType { f, a, .. }) => {
            let TyMetaFuncData { name, idby, .. } = L::Tmfs::ty_meta_func_data(f);
            match idby {
                IdentifiedBy::Tmf => name,
                IdentifiedBy::FirstTmfArg => sortid_name(ls, a.first().unwrap()),
            }
        }
    }
}
fn sortid_polish_name<L: LangSpec>(ls: &L, sort: &SortIdOf<L>) -> Vec<Name> {
    match sort {
        SortId::Algebraic(asi) => vec![ls.algebraic_sort_name(asi.clone()).clone()],
        SortId::TyMetaFunc(MappedType { f, a, .. }) => {
            let TyMetaFuncData { name, idby: _, .. } = L::Tmfs::ty_meta_func_data(f);
            let mut ret = vec![name.clone()];
            for arg in a {
                ret.extend(sortid_polish_name(ls, arg));
            }
            ret
        }
    }
}

fn get_direct_ccf_rels<L>(ls: &L) -> Vec<CcfRelation>
where
    L: LangSpec,
{
    ls.products()
        .map(|pid| CcfRelation {
            from: ls
                .product_sorts(pid.clone())
                .map(|sort| sortid_fingerprint(ls, &sort))
                .collect(),
            to: TyFingerprint::from(ls.product_name(pid).camel.as_str()),
        })
        .chain(ls.sums().map(|sid| {
            CcfRelation {
                from: ls
                    .sum_sorts(sid.clone())
                    .map(|sort| sortid_fingerprint(ls, &sort))
                    .collect(),
                to: TyFingerprint::from(ls.sum_name(sid).camel.as_str()),
            }
        }))
        .collect()
}

fn get_direct_mc_rels<L>(ls: &L) -> Vec<MctRelation>
where
    L: LangSpec,
{
    ls.products()
        .flat_map(|pid| {
            ls.product_sorts(pid.clone()).map(move |sort| MctRelation {
                from: pid_fingerprint(ls, &pid),
                to: sortid_fingerprint(ls, &sort),
            })
        })
        .chain(
            ls.sums()
                .flat_map(|sid| {
                    ls.sum_sorts(sid.clone()).map(move |sort| MctRelation {
                        from: sid_fingerprint(ls, &sid),
                        to: sortid_fingerprint(ls, &sort),
                    })
                })
                .collect::<Vec<_>>(),
        )
        .collect()
}
