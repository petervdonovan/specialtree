use langspec::langspec::Name;
use langspec::tymetafunc::{IdentifiedBy, RustTyMap, Transparency, TyMetaFuncSpec};
use langspec::{
    langspec::{AlgebraicSortId, LangSpec, MappedType, SortId, SortIdOf},
    tymetafunc::TyMetaFuncData,
};

pub use proc_macro2;
use term::{CcfRelation, TyFingerprint};

#[macro_export]
macro_rules! byline {
    () => {{
        let ret: $crate::proc_macro2::TokenStream = format!(
            "/// generated by [{}]\n#[rustfmt::skip]",
            $crate::function!()
        )
        .parse()
        .unwrap();
        ret
    }};
}
#[macro_export]
macro_rules! function {
    () => {{
        fn f() {}
        fn type_name_of<T>(_: T) -> &'static str {
            std::any::type_name::<T>()
        }
        let name = type_name_of(f);
        name.strip_suffix("::f")
            .unwrap()
            .trim_end_matches("::{{closure}}")
    }};
}
#[macro_export]
macro_rules! transpose {
    ($records:expr, $($field:ident),*) => {
        $(
            let mut $field = vec![];
        )*
        for record67142647 in $records {
            $(
                $field.push(record67142647.$field);
            )*
        }
        $(
            let $field = $field;
        )*
    };
}

pub struct TyGenData<'a, L: LangSpec> {
    pub id: Option<AlgebraicSortId<L::ProductId, L::SumId>>,
    pub fingerprint: TyFingerprint,
    pub snake_ident: syn::Ident,
    pub camel_ident: syn::Ident,
    pub cmt: CanonicallyMaybeToGenData<'a>,
    pub ccf: CanonicallyConstructibleFromGenData<'a>,
    pub transparency: Transparency,
}
pub struct HeapbakGenData<'a> {
    pub identifiers: Vec<syn::Ident>,
    pub ty_func: RustTyMap,
    pub ty_arg_camels: Vec<syn::Ident>,
    pub ty_args: Box<dyn Fn(HeapType, AlgebraicsBasePath) -> Vec<syn::Type> + 'a>,
}
pub struct CanonicallyMaybeToGenData<'a> {
    pub cmt_sort_tys: Box<dyn Fn(HeapType, AlgebraicsBasePath) -> Vec<syn::Type> + 'a>,
    pub algebraic_cmt_sort_tys: Box<dyn Fn(HeapType, AlgebraicsBasePath) -> Vec<syn::Type> + 'a>,
}
#[derive(Clone)]
pub struct AlgebraicsBasePath(proc_macro2::TokenStream); // a prefix of a syn::TypePath
impl AlgebraicsBasePath {
    pub fn new(bp: proc_macro2::TokenStream) -> Self {
        if !(bp.to_string().is_empty() || bp.to_string().ends_with("::")) {
            panic!(
                "AlgebraicsBasePath must end with '::' but instead is \"{}\"",
                bp
            );
        }
        Self(bp)
    }
    pub fn to_token_stream(&self) -> proc_macro2::TokenStream {
        self.0.clone()
    }
}
pub struct HeapType(pub syn::Type);
pub struct CanonicallyConstructibleFromGenData<'a> {
    pub ccf_sort_tys: Box<dyn Fn(HeapType, AlgebraicsBasePath) -> Vec<syn::Type> + 'a>,
    pub heap_sort_tys: Box<dyn Fn(HeapType, AlgebraicsBasePath) -> Vec<HstData> + 'a>,
    pub ccf_sort_tyses: Box<dyn Fn(HeapType, AlgebraicsBasePath) -> Vec<Vec<syn::Type>> + 'a>,
    pub ccf_sort_transparencies: Box<dyn Fn() -> Vec<Vec<Transparency>> + 'a>,
    pub ccf_sort_camel_idents: Box<dyn Fn() -> Vec<Vec<syn::Ident>> + 'a>,
    pub ccf_sort_snake_idents: Box<dyn Fn() -> Vec<Vec<syn::Ident>> + 'a>,
}
pub struct HstData {
    pub heap_sort_ty: syn::Type,
    pub heap_sort_snake_ident: syn::Ident,
    pub heap_sort_camel_ident: syn::Ident,
}
pub struct LsGen<'a, L: LangSpec> {
    bak: &'a L,
    // pub direct_ccf_rels: Vec<CcfRelation<SortIdOf<L>>>,
    // pub direct_mc_rels: Vec<MctRelation>,
}
impl<'a, L: LangSpec> From<&'a L> for LsGen<'a, L> {
    fn from(bak: &'a L) -> Self {
        Self {
            bak,
            // direct_ccf_rels: get_direct_ccf_rels(bak),
            // direct_mc_rels: get_direct_mc_rels(bak),
        }
    }
}
pub fn cons_list<T: quote::ToTokens + syn::parse::Parse>(it: impl Iterator<Item = T>) -> T {
    let mut ret = syn::parse_quote! { () };
    for item in it.collect::<Vec<_>>().into_iter().rev() {
        ret = syn::parse_quote! { (#item, #ret) };
    }
    ret
}
pub struct CcfPaths<SortId> {
    pub units: Vec<TransitiveUnitCcfRelation<SortId>>,
    pub non_units: Vec<TransitiveNonUnitCcfRelation<SortId>>,
}
impl<L: LangSpec> LsGen<'_, L> {
    pub fn bak(&self) -> &L {
        self.bak
    }
    pub fn ccf_paths(&self) -> CcfPaths<SortIdOf<L>> {
        let direct_ccf_rels = get_direct_ccf_rels(self.bak);
        let non_transparent_sorts = self
            .bak
            .products()
            .map(AlgebraicSortId::Product)
            .chain(self.bak.sums().map(AlgebraicSortId::Sum))
            .map(SortId::Algebraic)
            .collect::<Vec<_>>();
        let ucp = unit_ccf_paths_quadratically_large_closure::<L>(
            &direct_ccf_rels,
            &non_transparent_sorts,
        );
        let cebup = ccfs_exploded_by_unit_paths::<SortIdOf<L>>(
            &direct_ccf_rels,
            &ucp,
            &non_transparent_sorts,
        );
        // let cebup = vec![];
        CcfPaths {
            units: ucp,
            // .into_iter()
            // .chain(reflexive_tucrs::<L>(
            //     &direct_ccf_rels,
            //     &non_transparent_sorts,
            // ))
            // .collect(),
            non_units: cebup,
        }
    }
    pub fn tmfs_monomorphizations<
        F: FnMut(&MappedType<L::ProductId, L::SumId, <L::Tmfs as TyMetaFuncSpec>::TyMetaFuncId>),
    >(
        &self,
        f: &mut F,
    ) {
        call_on_all_tmf_monomorphizations(self.bak, f);
    }
    pub fn ty_gen_datas(&self) -> impl Iterator<Item = TyGenData<'_, L>> {
        self.bak
            .products()
            .map(move |pid| TyGenData {
                id: Some(AlgebraicSortId::Product(pid.clone())),
                fingerprint: pid_fingerprint(self.bak, &pid),
                snake_ident: syn::Ident::new(
                    &self.bak.product_name(pid.clone()).snake.clone(),
                    proc_macro2::Span::call_site(),
                ),
                camel_ident: syn::Ident::new(
                    &self.bak.product_name(pid.clone()).camel.clone(),
                    proc_macro2::Span::call_site(),
                ),
                cmt: CanonicallyMaybeToGenData {
                    cmt_sort_tys: {
                        let pidc = pid.clone();
                        Box::new(move |ht, abp| {
                            self.bak
                                .product_sorts(pidc.clone())
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp))
                                .collect()
                        })
                    },
                    algebraic_cmt_sort_tys: {
                        let pidc = pid.clone();
                        Box::new(move |ht, abp| {
                            algebraics(self.bak.product_sorts(pidc.clone()))
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp))
                                .collect()
                        })
                    },
                },
                ccf: CanonicallyConstructibleFromGenData {
                    ccf_sort_tys: Box::new({
                        let pid = pid.clone();
                        move |ht, abp| {
                            let fields_tys = self
                                .bak
                                .product_sorts(pid.clone())
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp));
                            vec![cons_list(fields_tys)]
                        }
                    }),
                    ccf_sort_transparencies: {
                        let pid = pid.clone();
                        Box::new(move || {
                            vec![self
                                .bak
                                .product_sorts(pid.clone())
                                .map(|sort| self.sort2transparency(sort))
                                .collect()]
                        })
                    },
                    heap_sort_tys: Box::new({
                        let pid = pid.clone();
                        move |ht, abp| {
                            self.bak
                                .product_sorts(pid.clone())
                                .zip(
                                    (self.product_heap_sort_camel_idents(&pid).into_iter())
                                        .zip(self.product_heap_sort_snake_idents(&pid)),
                                )
                                .filter_map(|(sort, (camel, snake))| {
                                    self.sort2heap_ty(sort, &ht, &abp)
                                        .map(|heap_sort_ty| HstData {
                                            heap_sort_ty,
                                            heap_sort_snake_ident: snake,
                                            heap_sort_camel_ident: camel,
                                        })
                                })
                                .collect()
                        }
                    }),
                    ccf_sort_tyses: Box::new({
                        let pid = pid.clone();
                        move |ht, abp| {
                            vec![self
                                .bak
                                .product_sorts(pid.clone())
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp))
                                .collect()]
                        }
                    }),
                    ccf_sort_camel_idents: Box::new({
                        let pid = pid.clone();
                        move || vec![self.product_heap_sort_camel_idents(&pid)]
                    }),
                    ccf_sort_snake_idents: Box::new(move || {
                        vec![self.product_heap_sort_snake_idents(&pid)]
                    }),
                },
                transparency: Transparency::Visible,
            })
            .chain(self.bak.sums().map(move |sid| TyGenData {
                id: Some(AlgebraicSortId::Sum(sid.clone())),
                fingerprint: sid_fingerprint(self.bak, &sid),
                snake_ident: syn::Ident::new(
                    &self.bak.sum_name(sid.clone()).snake.clone(),
                    proc_macro2::Span::call_site(),
                ),
                camel_ident: syn::Ident::new(
                    &self.bak.sum_name(sid.clone()).camel.clone(),
                    proc_macro2::Span::call_site(),
                ),
                cmt: CanonicallyMaybeToGenData {
                    cmt_sort_tys: {
                        let sidc = sid.clone();
                        Box::new(move |ht, abp| {
                            self.bak
                                .sum_sorts(sidc.clone())
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp))
                                .collect()
                        })
                    },
                    algebraic_cmt_sort_tys: {
                        let sidc = sid.clone();
                        Box::new(move |ht, abp| {
                            algebraics(self.bak.sum_sorts(sidc.clone()))
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp))
                                .collect()
                        })
                    },
                },
                ccf: CanonicallyConstructibleFromGenData {
                    ccf_sort_tys: Box::new({
                        let sid = sid.clone();
                        move |ht, abp| {
                            self.bak
                                .sum_sorts(sid.clone())
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp))
                                .map(|ty| syn::parse_quote! { (#ty,()) })
                                .collect()
                        }
                    }),
                    heap_sort_tys: Box::new({
                        let sid = sid.clone();
                        move |ht, abp| {
                            self.bak
                                .sum_sorts(sid.clone())
                                .zip(
                                    (self.sum_heap_sort_camel_idents(&sid).into_iter())
                                        .zip(self.sum_heap_sort_snake_idents(&sid)),
                                )
                                .filter_map(|(sort, (camel, snake))| {
                                    self.sort2heap_ty(sort, &ht, &abp)
                                        .map(|heap_sort_ty| HstData {
                                            heap_sort_ty,
                                            heap_sort_snake_ident: snake,
                                            heap_sort_camel_ident: camel,
                                        })
                                })
                                .collect()
                        }
                    }),
                    ccf_sort_transparencies: {
                        let sid = sid.clone();
                        Box::new(move || {
                            self.bak
                                .sum_sorts(sid.clone())
                                .map(|it| vec![self.sort2transparency(it)])
                                .collect()
                        })
                    },
                    ccf_sort_tyses: Box::new({
                        let sid = sid.clone();
                        move |ht, abp| {
                            self.bak
                                .sum_sorts(sid.clone())
                                .map(|sort| vec![self.sort2rs_ty(sort.clone(), &ht, &abp)])
                                .collect()
                        }
                    }),
                    ccf_sort_camel_idents: Box::new({
                        let sid = sid.clone();
                        move || {
                            self.sum_heap_sort_camel_idents(&sid)
                                .into_iter()
                                .map(|it| vec![it])
                                .collect()
                        }
                    }),
                    ccf_sort_snake_idents: Box::new(move || {
                        self.sum_heap_sort_snake_idents(&sid)
                            .into_iter()
                            .map(|it| vec![it])
                            .collect()
                    }),
                },
                transparency: Transparency::Transparent,
            }))
    }
    pub fn heapbak_gen_datas(&self) -> Vec<HeapbakGenData> {
        let mut ret: Vec<HeapbakGenData> = vec![];
        call_on_all_tmf_monomorphizations(self.bak, &mut |mt| {
            let polish_name = sortid_polish_name(self.bak, &SortId::TyMetaFunc(mt.clone()));
            let ty_arg_camels = polish_name
                .iter()
                .map(|name| syn::Ident::new(&name.camel, proc_macro2::Span::call_site()))
                .collect();
            let ty_arg_snakes = polish_name
                .iter()
                .map(|name| syn::Ident::new(&name.snake, proc_macro2::Span::call_site()));
            let ty_func = <L::Tmfs as TyMetaFuncSpec>::ty_meta_func_data(&mt.f).heapbak;
            ret.push(HeapbakGenData {
                identifiers: ty_arg_snakes.collect(),
                ty_func,
                ty_arg_camels,
                ty_args: Box::new({
                    let a = mt.a.clone();
                    move |ht, abp| {
                        a.iter()
                            .map(|arg| self.sort2rs_ty(arg.clone(), &ht, &abp))
                            .collect()
                    }
                }),
            });
        });
        ret
    }
    pub fn sort2rs_ty(
        &self,
        sort: SortIdOf<L>,
        ht: &HeapType,
        abp: &AlgebraicsBasePath,
    ) -> syn::Type {
        match sort {
            SortId::Algebraic(asi) => {
                let name = self.bak.algebraic_sort_name(asi);
                let ident = syn::Ident::new(&name.camel, proc_macro2::Span::call_site());
                let abp = &abp.0;
                syn::parse_quote! { #abp #ident }
            }
            SortId::TyMetaFunc(MappedType { f, a }) => {
                let TyMetaFuncData {
                    imp: RustTyMap { ty_func },
                    ..
                } = L::Tmfs::ty_meta_func_data(&f);
                let args = a.iter().map(|arg| self.sort2rs_ty(arg.clone(), ht, abp));
                let ht = &ht.0;
                syn::parse_quote! { #ty_func<#ht, #( #args, )* > }
            }
        }
    }
    pub fn sort2heap_ty(
        &self,
        sort: SortIdOf<L>,
        ht: &HeapType,
        abp: &AlgebraicsBasePath,
    ) -> Option<syn::Type> {
        match sort {
            SortId::Algebraic(_) => None,
            SortId::TyMetaFunc(MappedType { f, a }) => {
                let TyMetaFuncData {
                    heapbak: RustTyMap { ty_func },
                    ..
                } = L::Tmfs::ty_meta_func_data(&f);
                let args = a.iter().map(|arg| self.sort2rs_ty(arg.clone(), ht, abp));
                let ht = &ht.0;
                Some(syn::parse_quote! { #ty_func<#ht, #( #args, )* > })
            }
        }
    }
    pub fn sort2transparency(&self, sort: SortIdOf<L>) -> Transparency {
        match sort {
            SortId::Algebraic(AlgebraicSortId::Sum(_)) => Transparency::Transparent,
            SortId::Algebraic(AlgebraicSortId::Product(_)) => Transparency::Visible,
            SortId::TyMetaFunc(MappedType { f, a: _ }) => {
                L::Tmfs::ty_meta_func_data(&f).transparency
            }
        }
    }
    fn product_heap_sort_camel_idents(&self, pid: &L::ProductId) -> Vec<syn::Ident> {
        self.bak
            .product_sorts(pid.clone())
            .map(|sort| sort_ident(self, sort, |name| name.camel.clone()))
            .collect()
    }
    fn product_heap_sort_snake_idents(&self, pid: &L::ProductId) -> Vec<syn::Ident> {
        self.bak
            .product_sorts(pid.clone())
            .map(|sort| sort_ident(self, sort, |name| name.snake.clone()))
            .collect()
    }
    fn sum_heap_sort_camel_idents(&self, sid: &L::SumId) -> Vec<syn::Ident> {
        self.bak
            .sum_sorts(sid.clone())
            .map(|sort| sort_ident(self, sort, |name| name.camel.clone()))
            .collect()
    }
    fn sum_heap_sort_snake_idents(&self, sid: &L::SumId) -> Vec<syn::Ident> {
        self.bak
            .sum_sorts(sid.clone())
            .map(|sort| sort_ident(self, sort, |name| name.snake.clone()))
            .collect()
    }
    // pub fn find_transitive_mct_rel(&self, target: &MctRelation) -> Option<ConversionPath> {
    //     // breadth-first search
    //     // FIXME: handle non-uniqueness
    //     struct FrontierEntry {
    //         node: TyFingerprint,
    //         path: ConversionPath,
    //     }
    //     let mut frontier = vec![FrontierEntry {
    //         node: target.from,
    //         path: ConversionPath(vec![]),
    //     }];
    //     let mut visited = std::collections::HashSet::new();
    //     visited.insert(target.from);
    //     while !frontier.is_empty() {
    //         let mut new_frontier = vec![];
    //         for FrontierEntry {
    //             node: frontier,
    //             path,
    //         } in frontier.iter()
    //         {
    //             if *frontier == target.to {
    //                 return Some(path.clone());
    //             }
    //             for rel in self.direct_mc_rels.iter() {
    //                 if rel.from == *frontier && !visited.contains(&rel.to) {
    //                     let mut new_path = path.clone();
    //                     new_path.0.push(rel.from);
    //                     new_frontier.push(FrontierEntry {
    //                         node: rel.to,
    //                         path: new_path,
    //                     });
    //                     visited.insert(rel.to);
    //                 }
    //             }
    //         }
    //         frontier = new_frontier;
    //     }
    //     None
    // }
}
#[derive(Clone, Debug)]
pub struct ConversionPath<SortId>(pub Vec<SortId>);
#[derive(Debug)]
pub struct TransitiveCcfConversionPaths<SortId> {
    pub multiway_rel: CcfRelation<SortId>,
    pub paths: Vec<ConversionPath<SortId>>,
}
fn sort_ident<L: LangSpec>(
    alg: &LsGen<L>,
    sort: SortIdOf<L>,
    get_ident: fn(&Name) -> String,
) -> proc_macro2::Ident {
    // &sortid_name(&self.bak, sort.clone()).camel.clone(),
    match &sort {
        SortId::Algebraic(asi) => syn::Ident::new(
            &get_ident(alg.bak.algebraic_sort_name(asi.clone())),
            proc_macro2::Span::call_site(),
        ),
        SortId::TyMetaFunc(MappedType { f, a }) => {
            let TyMetaFuncData { name, idby, .. } = L::Tmfs::ty_meta_func_data(f);
            syn::Ident::new(
                &match idby {
                    IdentifiedBy::Tmf => get_ident(&name),
                    IdentifiedBy::FirstTmfArg => {
                        let arg = a.first().unwrap();
                        let name = sortid_name(alg.bak, arg);
                        get_ident(&name)
                    }
                },
                proc_macro2::Span::call_site(),
            )
        }
    }
}

fn call_on_all_tmf_monomorphizations<
    L: LangSpec,
    F: FnMut(&MappedType<L::ProductId, L::SumId, <L::Tmfs as TyMetaFuncSpec>::TyMetaFuncId>),
>(
    // &self,
    l: &L,
    f: &mut F,
) {
    let mut found: std::collections::HashSet<TyFingerprint> = std::collections::HashSet::new();
    fn process_tmf<
        L: LangSpec,
        F: FnMut(&MappedType<L::ProductId, L::SumId, <L::Tmfs as TyMetaFuncSpec>::TyMetaFuncId>),
    >(
        l: &L,
        found: &mut std::collections::HashSet<TyFingerprint>,
        sort: SortIdOf<L>,
        f: &mut F,
    ) {
        match sort.clone() {
            SortId::Algebraic(_) => (),
            SortId::TyMetaFunc(mt) => {
                let fingerprint = sortid_fingerprint(l, &sort);
                if found.contains(&fingerprint) {
                    return;
                }
                found.insert(fingerprint);
                f(&mt);
                for arg in mt.a {
                    process_tmf::<L, F>(l, found, arg, f);
                }
            }
        }
    }
    for sort in l
        .products()
        .flat_map(|pid| l.product_sorts(pid))
        .chain(l.sums().flat_map(|sid| l.sum_sorts(sid)))
    {
        process_tmf::<L, F>(l, &mut found, sort, f);
    }
}

pub fn number_range(n: usize) -> impl Iterator<Item = syn::LitInt> {
    (0..n).map(|i| syn::LitInt::new(&i.to_string(), proc_macro2::Span::call_site()))
}
pub fn cons_list_index_range(n: usize, expr: syn::Expr) -> impl Iterator<Item = syn::Expr> {
    (0..n).map(move |i| {
        let ones = (0..i).map(|_| quote::quote! {1});
        syn::parse_quote! {
            #expr #(. #ones)*.0
        }
    })
}

fn algebraics<
    ProductId: Clone + 'static,
    SumId: Clone + 'static,
    TyMetaFuncId: Clone + 'static,
    I: Iterator<Item = SortId<ProductId, SumId, TyMetaFuncId>>,
>(
    it: I,
) -> impl Iterator<Item = SortId<ProductId, SumId, TyMetaFuncId>> {
    it.flat_map(|sort| match &sort {
        SortId::Algebraic(_) => {
            Box::new(std::iter::once(sort.clone())) as Box<dyn Iterator<Item = _>>
        }
        SortId::TyMetaFunc(mapped_type) => Box::new(mapped_type.a.clone().into_iter()),
    })
}

fn pid_fingerprint<L: LangSpec>(ls: &L, pid: &L::ProductId) -> TyFingerprint {
    TyFingerprint::from(ls.product_name(pid.clone()).camel.as_str())
}
fn sid_fingerprint<L: LangSpec>(ls: &L, sid: &L::SumId) -> TyFingerprint {
    TyFingerprint::from(ls.sum_name(sid.clone()).camel.as_str())
}
fn asi_fingerprint<L: LangSpec>(
    ls: &L,
    asi: &AlgebraicSortId<L::ProductId, L::SumId>,
) -> TyFingerprint {
    match asi {
        AlgebraicSortId::Product(pid) => pid_fingerprint(ls, pid),
        AlgebraicSortId::Sum(sid) => sid_fingerprint(ls, sid),
    }
}
fn sortid_fingerprint<L: LangSpec>(ls: &L, sort: &SortIdOf<L>) -> TyFingerprint {
    match sort {
        SortId::Algebraic(asi) => asi_fingerprint(ls, asi),
        SortId::TyMetaFunc(MappedType { f, a }) => {
            let mut fingerprint =
                TyFingerprint::from(L::Tmfs::ty_meta_func_data(f).name.camel.as_str());
            for arg in a {
                fingerprint = fingerprint.combine(&sortid_fingerprint(ls, arg));
            }
            fingerprint
        }
    }
}
fn sortid_name<L: LangSpec>(ls: &L, sort: &SortIdOf<L>) -> Name {
    match sort {
        SortId::Algebraic(asi) => ls.algebraic_sort_name(asi.clone()).clone(),
        SortId::TyMetaFunc(MappedType { f, a, .. }) => {
            let TyMetaFuncData { name, idby, .. } = L::Tmfs::ty_meta_func_data(f);
            match idby {
                IdentifiedBy::Tmf => name,
                IdentifiedBy::FirstTmfArg => sortid_name(ls, a.first().unwrap()),
            }
        }
    }
}
fn sortid_polish_name<L: LangSpec>(ls: &L, sort: &SortIdOf<L>) -> Vec<Name> {
    match sort {
        SortId::Algebraic(asi) => vec![ls.algebraic_sort_name(asi.clone()).clone()],
        SortId::TyMetaFunc(MappedType { f, a, .. }) => {
            let TyMetaFuncData { name, idby: _, .. } = L::Tmfs::ty_meta_func_data(f);
            let mut ret = vec![name.clone()];
            for arg in a {
                ret.extend(sortid_polish_name(ls, arg));
            }
            ret
        }
    }
}

fn get_direct_ccf_rels<L>(ls: &L) -> Vec<CcfRelation<SortIdOf<L>>>
where
    L: LangSpec,
{
    let mut ret: Vec<CcfRelation<SortIdOf<L>>> = ls
        .products()
        .map(|pid| CcfRelation {
            from: ls.product_sorts(pid.clone()).collect(),
            to: SortId::Algebraic(AlgebraicSortId::Product(pid)),
        })
        .chain(ls.sums().flat_map(|sid| {
            ls.sum_sorts(sid.clone()).map(move |argsid| CcfRelation {
                from: vec![argsid.clone()],
                to: SortId::Algebraic(AlgebraicSortId::Sum(sid.clone())),
            })
        }))
        .chain(ls.products().map(|sid| CcfRelation {
            from: vec![SortId::Algebraic(AlgebraicSortId::Product(sid.clone()))],
            to: SortId::Algebraic(AlgebraicSortId::Product(sid)),
        }))
        .chain(ls.sums().map(|sid| CcfRelation {
            from: vec![SortId::Algebraic(AlgebraicSortId::Sum(sid.clone()))],
            to: SortId::Algebraic(AlgebraicSortId::Sum(sid)),
        }))
        .collect();
    call_on_all_tmf_monomorphizations(ls, &mut |mt| {
        for argids in L::Tmfs::ty_meta_func_data(&mt.f).canonical_froms {
            ret.push(CcfRelation {
                from: argids.iter().map(|argid| mt.a[argid.0].clone()).collect(),
                to: SortId::TyMetaFunc(mt.clone()),
            });
        }
        ret.push(CcfRelation {
            from: vec![SortId::TyMetaFunc(mt.clone())],
            to: SortId::TyMetaFunc(mt.clone()),
        });
    });
    ret
}

// pub fn find_transitive_ccf_rel<L: LangSpec>(
//     direct_ccf_rels: &[CcfRelation<SortIdOf<L>>],
//     target: &CcfRelation<SortIdOf<L>>,
// ) -> Option<TransitiveCcfConversionPaths<SortIdOf<L>>> {
//     // breadth-first search
//     struct FrontierEntry<SortId> {
//         node: SortId,
//         path: ConversionPath<SortId>,
//     }
//     struct Frontier<SortId>(Vec<FrontierEntry<SortId>>);
//     struct FrontierSet<SortId> {
//         multiway_rel: CcfRelation<SortId>,
//         paths: Vec<Frontier<SortId>>,
//     }
//     let mut frontierses = direct_ccf_rels
//         .iter()
//         .filter_map(|rel| {
//             if rel.to == target.to && rel.from.len() == target.from.len() {
//                 Some(FrontierSet {
//                     multiway_rel: rel.clone(),
//                     paths: rel
//                         .from
//                         .iter()
//                         .map(|from| {
//                             Frontier(vec![FrontierEntry {
//                                 node: from.clone(),
//                                 path: ConversionPath(vec![]),
//                             }])
//                         })
//                         .collect(),
//                 })
//             } else {
//                 None
//             }
//         })
//         .collect::<Vec<_>>();
//     while !frontierses.is_empty() {
//         for fs in frontierses.iter_mut() {
//             let mut new_frontiers = vec![];
//             for (target_from, Frontier(frontier)) in target.from.iter().zip(fs.paths.iter_mut()) {
//                 let mut new_frontier = vec![];
//                 for FrontierEntry { node, path } in frontier.iter() {
//                     if node == target_from {
//                         if frontier.len() > 1 {
//                             new_frontier = vec![FrontierEntry {
//                                 node: node.clone(),
//                                 path: path.clone(),
//                             }];
//                         }
//                         continue;
//                     }
//                     for rel in direct_ccf_rels.iter().filter(|rel| rel.from.len() == 1) {
//                         if rel.to == *node {
//                             let mut new_path = path.clone();
//                             new_path.0.push(node.clone());
//                             new_frontier.push(FrontierEntry {
//                                 node: rel.from.first().unwrap().clone(),
//                                 path: new_path,
//                             });
//                         }
//                     }
//                 }
//                 new_frontiers.push(Frontier(new_frontier));
//             }
//             fs.paths = new_frontiers;
//         }
//     }
//     frontierses.iter().find_map(|fs| {
//         let successful_paths = fs
//             .paths
//             .iter()
//             .zip(target.from.iter())
//             .filter_map(|(frontier, target)| {
//                 if frontier.0.len() == 1 && frontier.0.first().unwrap().node == *target {
//                     Some(frontier.0.first().unwrap().path.clone())
//                 } else {
//                     None
//                 }
//             })
//             .collect::<Vec<_>>();
//         if successful_paths.len() == target.from.len() {
//             Some(TransitiveCcfConversionPaths {
//                 multiway_rel: fs.multiway_rel.clone(),
//                 paths: successful_paths,
//             })
//         } else {
//             None
//         }
//     })
// }

#[derive(Clone, Debug)]
pub struct TransitiveUnitCcfRelation<SortId> {
    pub to: SortId,
    pub from: SortId,
    pub intermediary: SortId,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
struct UnitCcfRel<SortId> {
    from: SortId,
    to: SortId,
}
fn unit_ccf_paths_quadratically_large_closure<L: LangSpec>(
    direct_ccf_rels: &[CcfRelation<SortIdOf<L>>],
    non_transparent_sorts: &[SortIdOf<L>],
) -> Vec<TransitiveUnitCcfRelation<SortIdOf<L>>> {
    use std::collections::HashMap;
    use std::collections::HashSet;
    #[derive(Clone, Copy)]
    struct Distance(usize);
    #[derive(Clone, Debug, PartialEq, Eq, Hash)]
    struct Pair<SortId> {
        from: SortId,
        to: SortId,
    }
    let unit_ccf_rels: Vec<_> = direct_ccf_rels
        .iter()
        .filter(|rel| rel.from.len() == 1)
        .map(|rel| UnitCcfRel {
            from: rel.from.first().unwrap().clone(),
            to: rel.to.clone(),
        })
        .collect();
    let unit_ccf_tos: HashSet<_> = unit_ccf_rels.iter().map(|rel| rel.to.clone()).collect();
    fn get_tucr_for_to<L: LangSpec>(
        unit_ccf_rels: &[UnitCcfRel<SortIdOf<L>>],
        to: SortIdOf<L>,
        non_transparent_sorts: &[SortIdOf<L>],
    ) -> Vec<TransitiveUnitCcfRelation<SortIdOf<L>>> {
        let intermediaries = unit_ccf_rels
            .iter()
            .filter(|rel| rel.to == to && rel.from != to)
            .map(|rel| rel.from.clone())
            .collect::<HashSet<_>>();
        type CostedTucrs<SortId> =
            HashMap<Pair<SortId>, (TransitiveUnitCcfRelation<SortId>, Distance)>;
        fn get_tucr_for_to_and_intermediary<L: LangSpec>(
            unit_ccf_rels: &[UnitCcfRel<SortIdOf<L>>],
            to: SortIdOf<L>,
            intermediary: SortIdOf<L>,
            non_transparent_sorts: &[SortIdOf<L>],
        ) -> CostedTucrs<SortIdOf<L>> {
            fn find_all_reachable_from_intermediary<L: LangSpec>(
                unit_ccf_rels: &[UnitCcfRel<SortIdOf<L>>],
                intermediary: SortIdOf<L>,
                forbidden_node: SortIdOf<L>,
                non_transparent_sorts: &[SortIdOf<L>],
            ) -> HashMap<SortIdOf<L>, Distance> {
                let mut reachable = HashMap::new();
                let mut distance = Distance(0);
                let mut frontier = vec![(
                    intermediary.clone(),
                    non_transparent_sorts.contains(&intermediary),
                )];
                while !frontier.is_empty() {
                    distance.0 += 1;
                    let mut new_frontier = vec![];
                    for sid in frontier.iter() {
                        if reachable.contains_key(&sid.0) || sid.0 == forbidden_node {
                            continue;
                        }
                        reachable.insert(sid.0.clone(), distance);
                        for ucr in unit_ccf_rels.iter() {
                            if ucr.to == sid.0 {
                                let nt = non_transparent_sorts.contains(&ucr.from);
                                if sid.1 && nt {
                                    reachable.insert(ucr.from.clone(), Distance(distance.0 + 1));
                                } else {
                                    new_frontier.push((ucr.from.clone(), sid.1 || nt));
                                }
                            }
                        }
                        // let frontier_from_current = unit_ccf_rels
                        //     .iter()
                        //     .filter(|rel| {
                        //         rel.to == sid.0
                        //             && (sid.1 || !non_transparent_sorts.contains(&rel.from))
                        //     })
                        //     .map(|rel| (rel.from.clone(), sid.1));
                        // // if non_transparent_sorts.iter().any(|sort| sort == sid) {
                        // //     // Go one level past non_transparent_sorts, but no further
                        // //     reachable.extend(
                        // //         frontier_from_current
                        // //             .map(|sort| (sort.clone(), Distance(distance.0 + 1))),
                        // //     );
                        // // } else {
                        // new_frontier.extend(frontier_from_current);
                        // // }
                    }
                    frontier = new_frontier;
                }
                reachable
            }
            let reachable = find_all_reachable_from_intermediary::<L>(
                unit_ccf_rels,
                intermediary.clone(),
                to.clone(),
                non_transparent_sorts,
            );
            reachable
                .into_iter()
                .map(move |(from, distance)| {
                    (
                        Pair {
                            from: from.clone(),
                            to: to.clone(),
                        },
                        (
                            TransitiveUnitCcfRelation {
                                from: from.clone(),
                                to: to.clone(),
                                intermediary: intermediary.clone(),
                            },
                            distance,
                        ),
                    )
                })
                .collect()
        }
        let mut tucrs: CostedTucrs<SortIdOf<L>> = HashMap::new();
        for intermediary in intermediaries.iter() {
            let tucrs_intermediary = get_tucr_for_to_and_intermediary::<L>(
                unit_ccf_rels,
                to.clone(),
                intermediary.clone(),
                non_transparent_sorts,
            );
            for (pair, (tucr, distance)) in tucrs_intermediary.iter() {
                if let Some(existing) = tucrs.get(pair) {
                    if existing.1 .0 > distance.0 {
                        tucrs.insert(pair.clone(), (tucr.clone(), *distance));
                    }
                } else {
                    tucrs.insert(pair.clone(), (tucr.clone(), *distance));
                }
            }
        }
        tucrs.into_values().map(|v| v.0).collect()
    }
    unit_ccf_tos
        .iter()
        .flat_map(|to| get_tucr_for_to::<L>(&unit_ccf_rels, to.clone(), non_transparent_sorts))
        .collect()
}

fn reflexive_tucrs<'a, L: LangSpec>(
    direct_ccf_rels: &'a [CcfRelation<SortIdOf<L>>],
    non_transparent_sorts: &'a [SortIdOf<L>],
) -> impl Iterator<Item = TransitiveUnitCcfRelation<SortIdOf<L>>> + use<'a, L> {
    direct_ccf_rels
        .iter()
        .filter_map(|rel| {
            if let Some(from) = rel.from.first() {
                if rel.from.len() == 1 && from != &rel.to && non_transparent_sorts.contains(from) {
                    Some(UnitCcfRel {
                        from: from.clone(),
                        to: rel.to.clone(),
                    })
                } else {
                    None
                }
            } else {
                None
            }
        })
        .map(|rel| TransitiveUnitCcfRelation {
            from: rel.from.clone(),
            to: rel.to.clone(),
            intermediary: rel.from,
        })
}

fn combinations<I: Clone + IntoIterator<Item: Clone>>(
    seqs: Vec<I>,
) -> impl Iterator<Item = Vec<I::Item>> {
    let mut iterators = vec![];
    for seq in seqs.iter() {
        iterators.push(seq.clone().into_iter());
    }
    let mut previous: Option<Vec<I::Item>> = None;
    std::iter::from_fn(move || match &mut previous {
        Some(ref mut value) => {
            for currently_incrementing_iterator in 0..iterators.len() {
                if let Some(next_value) = iterators[currently_incrementing_iterator].next() {
                    value[currently_incrementing_iterator] = next_value;
                    return Some(value.clone());
                } else {
                    iterators[currently_incrementing_iterator] =
                        seqs[currently_incrementing_iterator].clone().into_iter();
                    if let Some(next_value) = iterators[currently_incrementing_iterator].next() {
                        value[currently_incrementing_iterator] = next_value;
                    } else {
                        return None;
                    }
                }
            }
            None // All iterators are exhausted
        }
        None => {
            let mut new_value = vec![];
            for i in 0..seqs.len() {
                if let Some(next_value) = iterators[i].next() {
                    new_value.push(next_value);
                } else {
                    return None;
                }
            }
            previous = Some(new_value.clone());
            Some(new_value)
        }
    })
}
#[derive(Clone, Debug)]
pub struct TransitiveNonUnitCcfRelation<SortId> {
    pub from: Vec<SortId>,
    pub to: SortId,
    pub intermediary: CcfRelation<SortId>,
}
fn ccfs_exploded_by_unit_paths<SortId: Clone + Eq>(
    direct_ccf_rels: &[CcfRelation<SortId>],
    unit_ccf_rels: &[TransitiveUnitCcfRelation<SortId>],
    non_transparent_sorts: &[SortId],
) -> Vec<TransitiveNonUnitCcfRelation<SortId>> {
    fn from_sets<SortId: Eq + Clone>(
        froms: Vec<SortId>,
        unit_ccf_rels: &[TransitiveUnitCcfRelation<SortId>],
    ) -> Vec<Vec<SortId>> {
        froms
            .iter()
            .map(|from| {
                unit_ccf_rels
                    .iter()
                    .filter_map(|it| {
                        if &it.to == from {
                            Some(it.from.clone())
                        } else {
                            None
                        }
                    })
                    .chain(std::iter::once(from.clone())) // also allow no intermediaries
                    .collect()
            })
            .collect()
    }
    direct_ccf_rels
        .iter()
        .filter(|direct| direct.from.len() != 1) // we only want non-units
        .flat_map(|direct| {
            unit_ccf_rels
                .iter()
                .filter_map(|it| {
                    if it.from == direct.to && !non_transparent_sorts.contains(&it.to) {
                        Some(it.to.clone())
                    } else {
                        None
                    }
                })
                .chain(std::iter::once(direct.to.clone())) // also allow no intermediaries
                .flat_map(move |to| {
                    combinations(from_sets(direct.from.clone(), unit_ccf_rels))
                        .filter({
                            let to = to.clone();
                            move |from| !from.contains(&to)
                        }) // we don't want cycles
                        .map(move |from| TransitiveNonUnitCcfRelation {
                            from: from.clone(),
                            to: to.clone(),
                            intermediary: direct.clone(),
                        })
                })
        })
        // .filter(|rel| {
        //     !direct_ccf_rels.contains(&CcfRelation {
        //         from: rel.from.clone(),
        //         to: rel.to.clone(),
        //     })
        // })
        .collect()
}

// fn get_direct_mc_rels<L>(ls: &L) -> Vec<MctRelation>
// where
//     L: LangSpec,
// {
//     ls.products()
//         .flat_map(|pid| {
//             ls.product_sorts(pid.clone()).map(move |sort| MctRelation {
//                 from: pid_fingerprint(ls, &pid),
//                 to: sortid_fingerprint(ls, &sort),
//             })
//         })
//         .chain(
//             ls.sums()
//                 .flat_map(|sid| {
//                     ls.sum_sorts(sid.clone()).map(move |sort| MctRelation {
//                         from: sid_fingerprint(ls, &sid),
//                         to: sortid_fingerprint(ls, &sort),
//                     })
//                 })
//                 .collect::<Vec<_>>(),
//         )
//         .collect()
// }
#[cfg(test)]
mod tests {
    use langspec::humanreadable::LangSpecHuman;
    use term::CcfRelation;

    use crate::{
        ccfs_exploded_by_unit_paths, get_direct_ccf_rels,
        unit_ccf_paths_quadratically_large_closure,
    };

    #[test]
    fn test_gdcr() {
        let ls = langspec_examples::fib();
        type L = LangSpecHuman<tymetafuncspec_core::Core>;
        let dcr = get_direct_ccf_rels(&ls);
        for rel in &dcr {
            println!("{:?}\n", rel);
        }
        let non_transparent_sorts = &[
            langspec::humanreadable::SortId::<tymetafuncspec_core::Core>::Algebraic(
                langspec::langspec::AlgebraicSortId::Sum("â„•".into()),
            ),
        ];
        let ucr = unit_ccf_paths_quadratically_large_closure::<L>(&dcr, non_transparent_sorts);
        for rel in &ucr {
            println!("{:?}\n", rel);
        }
        let cebup = ccfs_exploded_by_unit_paths(&dcr, &ucr, non_transparent_sorts);
        for rel in &cebup {
            println!("{:?}\n", rel);
        }
        println!("Direct CCF relations: {}", dcr.len());
        println!("Unit CCF relations: {}", ucr.len());
        println!("Exploded CCF relations: {}", cebup.len());
        // >>> len(["f", "nat", "leftoperand", "rightoperand", "boxf", "boxplus", "plus"]) * (len(["boundednat", "f", "plus", "boxf", "boxplus", "nat", "current"]) ** 2)
        // 343
    }

    #[test]
    fn test_combinations() {
        let a = vec![2, 4, 6];
        let b = vec![3, 6, 9];
        let c = vec![5, 10, 15];
        let all: std::collections::HashSet<_> = crate::combinations(vec![a, b, c]).collect();
        assert!(all.len() == 27);
    }
}
