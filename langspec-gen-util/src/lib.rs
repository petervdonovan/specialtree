use langspec::langspec::Name;
use langspec::tymetafunc::{IdentifiedBy, RustTyMap, Transparency, TyMetaFuncSpec};
use langspec::{
    langspec::{AlgebraicSortId, LangSpec, MappedType, SortId, SortIdOf},
    tymetafunc::TyMetaFuncData,
};

pub use proc_macro2;
use term::{CcfRelation, TyFingerprint};

#[macro_export]
macro_rules! byline {
    () => {{
        let ret: $crate::proc_macro2::TokenStream =
            format!("/// generated by [{}]", $crate::function!())
                .parse()
                .unwrap();
        ret
    }};
}
#[macro_export]
macro_rules! function {
    () => {{
        fn f() {}
        fn type_name_of<T>(_: T) -> &'static str {
            std::any::type_name::<T>()
        }
        let name = type_name_of(f);
        name.strip_suffix("::f")
            .unwrap()
            .trim_end_matches("::{{closure}}")
    }};
}
#[macro_export]
macro_rules! transpose {
    ($records:expr, $($field:ident),*) => {
        $(
            let mut $field = vec![];
        )*
        for record67142647 in $records {
            $(
                $field.push(record67142647.$field);
            )*
        }
        $(
            let $field = $field;
        )*
    };
}

pub struct TyGenData<'a, L: LangSpec> {
    pub id: Option<AlgebraicSortId<L::ProductId, L::SumId>>,
    pub fingerprint: TyFingerprint,
    pub snake_ident: syn::Ident,
    pub camel_ident: syn::Ident,
    pub cmt: CanonicallyMaybeToGenData<'a>,
    pub ccf: CanonicallyConstructibleFromGenData<'a>,
    pub transparency: Transparency,
}
pub struct HeapbakGenData<'a> {
    pub identifiers: Vec<syn::Ident>,
    pub ty_func: RustTyMap,
    pub ty_arg_camels: Vec<syn::Ident>,
    pub ty_args: Box<dyn Fn(HeapType, AlgebraicsBasePath) -> Vec<syn::Type> + 'a>,
}
pub struct CanonicallyMaybeToGenData<'a> {
    pub cmt_sort_tys: Box<dyn Fn(HeapType, AlgebraicsBasePath) -> Vec<syn::Type> + 'a>,
    pub algebraic_cmt_sort_tys: Box<dyn Fn(HeapType, AlgebraicsBasePath) -> Vec<syn::Type> + 'a>,
}
#[derive(Clone)]
pub struct AlgebraicsBasePath(proc_macro2::TokenStream); // a prefix of a syn::TypePath
impl AlgebraicsBasePath {
    pub fn new(bp: proc_macro2::TokenStream) -> Self {
        if !(bp.to_string().is_empty() || bp.to_string().ends_with("::")) {
            panic!(
                "AlgebraicsBasePath must end with '::' but instead is \"{}\"",
                bp
            );
        }
        Self(bp)
    }
    pub fn to_token_stream(&self) -> proc_macro2::TokenStream {
        self.0.clone()
    }
}
pub struct HeapType(pub syn::Type);
pub struct CanonicallyConstructibleFromGenData<'a> {
    pub ccf_sort_tys: Box<dyn Fn(HeapType, AlgebraicsBasePath) -> Vec<syn::Type> + 'a>,
    pub heap_sort_tys: Box<dyn Fn(HeapType, AlgebraicsBasePath) -> Vec<HstData> + 'a>,
    pub ccf_sort_tyses: Box<dyn Fn(HeapType, AlgebraicsBasePath) -> Vec<Vec<syn::Type>> + 'a>,
    pub ccf_sort_transparencies: Box<dyn Fn() -> Vec<Vec<Transparency>> + 'a>,
    pub ccf_sort_camel_idents: Box<dyn Fn() -> Vec<Vec<syn::Ident>> + 'a>,
    pub ccf_sort_snake_idents: Box<dyn Fn() -> Vec<Vec<syn::Ident>> + 'a>,
}
pub struct HstData {
    pub heap_sort_ty: syn::Type,
    pub heap_sort_snake_ident: syn::Ident,
    pub heap_sort_camel_ident: syn::Ident,
}
pub struct LsGen<'a, L: LangSpec> {
    bak: &'a L,
    pub direct_ccf_rels: Vec<CcfRelation<SortIdOf<L>>>,
    // pub direct_mc_rels: Vec<MctRelation>,
}
impl<'a, L: LangSpec> From<&'a L> for LsGen<'a, L> {
    fn from(bak: &'a L) -> Self {
        Self {
            bak,
            direct_ccf_rels: get_direct_ccf_rels(bak),
            // direct_mc_rels: get_direct_mc_rels(bak),
        }
    }
}
pub fn cons_list<T: quote::ToTokens + syn::parse::Parse>(it: impl Iterator<Item = T>) -> T {
    let mut ret = syn::parse_quote! { () };
    for item in it.collect::<Vec<_>>().into_iter().rev() {
        ret = syn::parse_quote! { (#item, #ret) };
    }
    ret
}
impl<L: LangSpec> LsGen<'_, L> {
    pub fn bak(&self) -> &L {
        self.bak
    }
    pub fn unit_ccf_paths(&self) -> Vec<TransitivelyUnitCcfRelation<SortIdOf<L>>> {
        unit_ccf_paths_quadratically_large_closure::<L>(&self.direct_ccf_rels)
    }
    pub fn ty_gen_datas(&self) -> impl Iterator<Item = TyGenData<'_, L>> {
        self.bak
            .products()
            .map(move |pid| TyGenData {
                id: Some(AlgebraicSortId::Product(pid.clone())),
                fingerprint: pid_fingerprint(self.bak, &pid),
                snake_ident: syn::Ident::new(
                    &self.bak.product_name(pid.clone()).snake.clone(),
                    proc_macro2::Span::call_site(),
                ),
                camel_ident: syn::Ident::new(
                    &self.bak.product_name(pid.clone()).camel.clone(),
                    proc_macro2::Span::call_site(),
                ),
                cmt: CanonicallyMaybeToGenData {
                    cmt_sort_tys: {
                        let pidc = pid.clone();
                        Box::new(move |ht, abp| {
                            self.bak
                                .product_sorts(pidc.clone())
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp))
                                .collect()
                        })
                    },
                    algebraic_cmt_sort_tys: {
                        let pidc = pid.clone();
                        Box::new(move |ht, abp| {
                            algebraics(self.bak.product_sorts(pidc.clone()))
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp))
                                .collect()
                        })
                    },
                },
                ccf: CanonicallyConstructibleFromGenData {
                    ccf_sort_tys: Box::new({
                        let pid = pid.clone();
                        move |ht, abp| {
                            let fields_tys = self
                                .bak
                                .product_sorts(pid.clone())
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp));
                            vec![cons_list(fields_tys)]
                        }
                    }),
                    ccf_sort_transparencies: {
                        let pid = pid.clone();
                        Box::new(move || {
                            vec![self
                                .bak
                                .product_sorts(pid.clone())
                                .map(|sort| self.sort2transparency(sort))
                                .collect()]
                        })
                    },
                    heap_sort_tys: Box::new({
                        let pid = pid.clone();
                        move |ht, abp| {
                            self.bak
                                .product_sorts(pid.clone())
                                .zip(
                                    (self.product_heap_sort_camel_idents(&pid).into_iter())
                                        .zip(self.product_heap_sort_snake_idents(&pid)),
                                )
                                .filter_map(|(sort, (camel, snake))| {
                                    self.sort2heap_ty(sort, &ht, &abp)
                                        .map(|heap_sort_ty| HstData {
                                            heap_sort_ty,
                                            heap_sort_snake_ident: snake,
                                            heap_sort_camel_ident: camel,
                                        })
                                })
                                .collect()
                        }
                    }),
                    ccf_sort_tyses: Box::new({
                        let pid = pid.clone();
                        move |ht, abp| {
                            vec![self
                                .bak
                                .product_sorts(pid.clone())
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp))
                                .collect()]
                        }
                    }),
                    ccf_sort_camel_idents: Box::new({
                        let pid = pid.clone();
                        move || vec![self.product_heap_sort_camel_idents(&pid)]
                    }),
                    ccf_sort_snake_idents: Box::new(move || {
                        vec![self.product_heap_sort_snake_idents(&pid)]
                    }),
                },
                transparency: Transparency::Visible,
            })
            .chain(self.bak.sums().map(move |sid| TyGenData {
                id: Some(AlgebraicSortId::Sum(sid.clone())),
                fingerprint: sid_fingerprint(self.bak, &sid),
                snake_ident: syn::Ident::new(
                    &self.bak.sum_name(sid.clone()).snake.clone(),
                    proc_macro2::Span::call_site(),
                ),
                camel_ident: syn::Ident::new(
                    &self.bak.sum_name(sid.clone()).camel.clone(),
                    proc_macro2::Span::call_site(),
                ),
                cmt: CanonicallyMaybeToGenData {
                    cmt_sort_tys: {
                        let sidc = sid.clone();
                        Box::new(move |ht, abp| {
                            self.bak
                                .sum_sorts(sidc.clone())
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp))
                                .collect()
                        })
                    },
                    algebraic_cmt_sort_tys: {
                        let sidc = sid.clone();
                        Box::new(move |ht, abp| {
                            algebraics(self.bak.sum_sorts(sidc.clone()))
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp))
                                .collect()
                        })
                    },
                },
                ccf: CanonicallyConstructibleFromGenData {
                    ccf_sort_tys: Box::new({
                        let sid = sid.clone();
                        move |ht, abp| {
                            self.bak
                                .sum_sorts(sid.clone())
                                .map(|sort| self.sort2rs_ty(sort.clone(), &ht, &abp))
                                .map(|ty| syn::parse_quote! { (#ty,()) })
                                .collect()
                        }
                    }),
                    heap_sort_tys: Box::new({
                        let sid = sid.clone();
                        move |ht, abp| {
                            self.bak
                                .sum_sorts(sid.clone())
                                .zip(
                                    (self.sum_heap_sort_camel_idents(&sid).into_iter())
                                        .zip(self.sum_heap_sort_snake_idents(&sid)),
                                )
                                .filter_map(|(sort, (camel, snake))| {
                                    self.sort2heap_ty(sort, &ht, &abp)
                                        .map(|heap_sort_ty| HstData {
                                            heap_sort_ty,
                                            heap_sort_snake_ident: snake,
                                            heap_sort_camel_ident: camel,
                                        })
                                })
                                .collect()
                        }
                    }),
                    ccf_sort_transparencies: {
                        let sid = sid.clone();
                        Box::new(move || {
                            self.bak
                                .sum_sorts(sid.clone())
                                .map(|it| vec![self.sort2transparency(it)])
                                .collect()
                        })
                    },
                    ccf_sort_tyses: Box::new({
                        let sid = sid.clone();
                        move |ht, abp| {
                            self.bak
                                .sum_sorts(sid.clone())
                                .map(|sort| vec![self.sort2rs_ty(sort.clone(), &ht, &abp)])
                                .collect()
                        }
                    }),
                    ccf_sort_camel_idents: Box::new({
                        let sid = sid.clone();
                        move || {
                            self.sum_heap_sort_camel_idents(&sid)
                                .into_iter()
                                .map(|it| vec![it])
                                .collect()
                        }
                    }),
                    ccf_sort_snake_idents: Box::new(move || {
                        self.sum_heap_sort_snake_idents(&sid)
                            .into_iter()
                            .map(|it| vec![it])
                            .collect()
                    }),
                },
                transparency: Transparency::Transparent,
            }))
    }
    pub fn heapbak_gen_datas(&self) -> Vec<HeapbakGenData> {
        let mut ret: Vec<HeapbakGenData> = vec![];
        call_on_all_tmf_monomorphizations(self.bak, &mut |mt| {
            let polish_name = sortid_polish_name(self.bak, &SortId::TyMetaFunc(mt.clone()));
            let ty_arg_camels = polish_name
                .iter()
                .map(|name| syn::Ident::new(&name.camel, proc_macro2::Span::call_site()))
                .collect();
            let ty_arg_snakes = polish_name
                .iter()
                .map(|name| syn::Ident::new(&name.snake, proc_macro2::Span::call_site()));
            let ty_func = <L::Tmfs as TyMetaFuncSpec>::ty_meta_func_data(&mt.f).heapbak;
            ret.push(HeapbakGenData {
                identifiers: ty_arg_snakes.collect(),
                ty_func,
                ty_arg_camels,
                ty_args: Box::new({
                    let a = mt.a.clone();
                    move |ht, abp| {
                        a.iter()
                            .map(|arg| self.sort2rs_ty(arg.clone(), &ht, &abp))
                            .collect()
                    }
                }),
            });
        });
        ret
    }
    pub fn sort2rs_ty(
        &self,
        sort: SortIdOf<L>,
        ht: &HeapType,
        abp: &AlgebraicsBasePath,
    ) -> syn::Type {
        match sort {
            SortId::Algebraic(asi) => {
                let name = self.bak.algebraic_sort_name(asi);
                let ident = syn::Ident::new(&name.camel, proc_macro2::Span::call_site());
                let abp = &abp.0;
                syn::parse_quote! { #abp #ident }
            }
            SortId::TyMetaFunc(MappedType { f, a }) => {
                let TyMetaFuncData {
                    imp: RustTyMap { ty_func },
                    ..
                } = L::Tmfs::ty_meta_func_data(&f);
                let args = a.iter().map(|arg| self.sort2rs_ty(arg.clone(), ht, abp));
                let ht = &ht.0;
                syn::parse_quote! { #ty_func<#ht, #( #args, )* > }
            }
        }
    }
    pub fn sort2heap_ty(
        &self,
        sort: SortIdOf<L>,
        ht: &HeapType,
        abp: &AlgebraicsBasePath,
    ) -> Option<syn::Type> {
        match sort {
            SortId::Algebraic(_) => None,
            SortId::TyMetaFunc(MappedType { f, a }) => {
                let TyMetaFuncData {
                    heapbak: RustTyMap { ty_func },
                    ..
                } = L::Tmfs::ty_meta_func_data(&f);
                let args = a.iter().map(|arg| self.sort2rs_ty(arg.clone(), ht, abp));
                let ht = &ht.0;
                Some(syn::parse_quote! { #ty_func<#ht, #( #args, )* > })
            }
        }
    }
    pub fn sort2transparency(&self, sort: SortIdOf<L>) -> Transparency {
        match sort {
            SortId::Algebraic(AlgebraicSortId::Sum(_)) => Transparency::Transparent,
            SortId::Algebraic(AlgebraicSortId::Product(_)) => Transparency::Visible,
            SortId::TyMetaFunc(MappedType { f, a: _ }) => {
                L::Tmfs::ty_meta_func_data(&f).transparency
            }
        }
    }
    fn product_heap_sort_camel_idents(&self, pid: &L::ProductId) -> Vec<syn::Ident> {
        self.bak
            .product_sorts(pid.clone())
            .map(|sort| sort_ident(self, sort, |name| name.camel.clone()))
            .collect()
    }
    fn product_heap_sort_snake_idents(&self, pid: &L::ProductId) -> Vec<syn::Ident> {
        self.bak
            .product_sorts(pid.clone())
            .map(|sort| sort_ident(self, sort, |name| name.snake.clone()))
            .collect()
    }
    fn sum_heap_sort_camel_idents(&self, sid: &L::SumId) -> Vec<syn::Ident> {
        self.bak
            .sum_sorts(sid.clone())
            .map(|sort| sort_ident(self, sort, |name| name.camel.clone()))
            .collect()
    }
    fn sum_heap_sort_snake_idents(&self, sid: &L::SumId) -> Vec<syn::Ident> {
        self.bak
            .sum_sorts(sid.clone())
            .map(|sort| sort_ident(self, sort, |name| name.snake.clone()))
            .collect()
    }
    // pub fn find_transitive_mct_rel(&self, target: &MctRelation) -> Option<ConversionPath> {
    //     // breadth-first search
    //     // FIXME: handle non-uniqueness
    //     struct FrontierEntry {
    //         node: TyFingerprint,
    //         path: ConversionPath,
    //     }
    //     let mut frontier = vec![FrontierEntry {
    //         node: target.from,
    //         path: ConversionPath(vec![]),
    //     }];
    //     let mut visited = std::collections::HashSet::new();
    //     visited.insert(target.from);
    //     while !frontier.is_empty() {
    //         let mut new_frontier = vec![];
    //         for FrontierEntry {
    //             node: frontier,
    //             path,
    //         } in frontier.iter()
    //         {
    //             if *frontier == target.to {
    //                 return Some(path.clone());
    //             }
    //             for rel in self.direct_mc_rels.iter() {
    //                 if rel.from == *frontier && !visited.contains(&rel.to) {
    //                     let mut new_path = path.clone();
    //                     new_path.0.push(rel.from);
    //                     new_frontier.push(FrontierEntry {
    //                         node: rel.to,
    //                         path: new_path,
    //                     });
    //                     visited.insert(rel.to);
    //                 }
    //             }
    //         }
    //         frontier = new_frontier;
    //     }
    //     None
    // }
}
#[derive(Clone, Debug)]
pub struct ConversionPath<SortId>(pub Vec<SortId>);
#[derive(Debug)]
pub struct TransitiveCcfConversionPaths<SortId> {
    pub multiway_rel: CcfRelation<SortId>,
    pub paths: Vec<ConversionPath<SortId>>,
}
fn sort_ident<L: LangSpec>(
    alg: &LsGen<L>,
    sort: SortIdOf<L>,
    get_ident: fn(&Name) -> String,
) -> proc_macro2::Ident {
    // &sortid_name(&self.bak, sort.clone()).camel.clone(),
    match &sort {
        SortId::Algebraic(asi) => syn::Ident::new(
            &get_ident(alg.bak.algebraic_sort_name(asi.clone())),
            proc_macro2::Span::call_site(),
        ),
        SortId::TyMetaFunc(MappedType { f, a }) => {
            let TyMetaFuncData { name, idby, .. } = L::Tmfs::ty_meta_func_data(f);
            syn::Ident::new(
                &match idby {
                    IdentifiedBy::Tmf => get_ident(&name),
                    IdentifiedBy::FirstTmfArg => {
                        let arg = a.first().unwrap();
                        let name = sortid_name(alg.bak, arg);
                        get_ident(&name)
                    }
                },
                proc_macro2::Span::call_site(),
            )
        }
    }
}

fn call_on_all_tmf_monomorphizations<
    L: LangSpec,
    F: FnMut(&MappedType<L::ProductId, L::SumId, <L::Tmfs as TyMetaFuncSpec>::TyMetaFuncId>),
>(
    // &self,
    l: &L,
    f: &mut F,
) {
    let mut found: std::collections::HashSet<TyFingerprint> = std::collections::HashSet::new();
    fn process_tmf<
        L: LangSpec,
        F: FnMut(&MappedType<L::ProductId, L::SumId, <L::Tmfs as TyMetaFuncSpec>::TyMetaFuncId>),
    >(
        l: &L,
        found: &mut std::collections::HashSet<TyFingerprint>,
        sort: SortIdOf<L>,
        f: &mut F,
    ) {
        match sort.clone() {
            SortId::Algebraic(_) => (),
            SortId::TyMetaFunc(mt) => {
                let fingerprint = sortid_fingerprint(l, &sort);
                if found.contains(&fingerprint) {
                    return;
                }
                dbg!(&sort);
                found.insert(fingerprint);
                f(&mt);
                for arg in mt.a {
                    process_tmf::<L, F>(l, found, arg, f);
                }
            }
        }
    }
    for sort in l
        .products()
        .flat_map(|pid| l.product_sorts(pid))
        .chain(l.sums().flat_map(|sid| l.sum_sorts(sid)))
    {
        process_tmf::<L, F>(l, &mut found, sort, f);
    }
}

pub fn number_range(n: usize) -> impl Iterator<Item = syn::LitInt> {
    (0..n).map(|i| syn::LitInt::new(&i.to_string(), proc_macro2::Span::call_site()))
}
pub fn cons_list_index_range(n: usize, expr: syn::Expr) -> impl Iterator<Item = syn::Expr> {
    (0..n).map(move |i| {
        let ones = (0..i).map(|_| quote::quote! {1});
        syn::parse_quote! {
            #expr #(. #ones)*.0
        }
    })
}

fn algebraics<
    ProductId: Clone + 'static,
    SumId: Clone + 'static,
    TyMetaFuncId: Clone + 'static,
    I: Iterator<Item = SortId<ProductId, SumId, TyMetaFuncId>>,
>(
    it: I,
) -> impl Iterator<Item = SortId<ProductId, SumId, TyMetaFuncId>> {
    it.flat_map(|sort| match &sort {
        SortId::Algebraic(_) => {
            Box::new(std::iter::once(sort.clone())) as Box<dyn Iterator<Item = _>>
        }
        SortId::TyMetaFunc(mapped_type) => Box::new(mapped_type.a.clone().into_iter()),
    })
}

fn pid_fingerprint<L: LangSpec>(ls: &L, pid: &L::ProductId) -> TyFingerprint {
    TyFingerprint::from(ls.product_name(pid.clone()).camel.as_str())
}
fn sid_fingerprint<L: LangSpec>(ls: &L, sid: &L::SumId) -> TyFingerprint {
    TyFingerprint::from(ls.sum_name(sid.clone()).camel.as_str())
}
fn asi_fingerprint<L: LangSpec>(
    ls: &L,
    asi: &AlgebraicSortId<L::ProductId, L::SumId>,
) -> TyFingerprint {
    match asi {
        AlgebraicSortId::Product(pid) => pid_fingerprint(ls, pid),
        AlgebraicSortId::Sum(sid) => sid_fingerprint(ls, sid),
    }
}
fn sortid_fingerprint<L: LangSpec>(ls: &L, sort: &SortIdOf<L>) -> TyFingerprint {
    match sort {
        SortId::Algebraic(asi) => asi_fingerprint(ls, asi),
        SortId::TyMetaFunc(MappedType { f, a }) => {
            let mut fingerprint =
                TyFingerprint::from(L::Tmfs::ty_meta_func_data(f).name.camel.as_str());
            for arg in a {
                fingerprint = fingerprint.combine(&sortid_fingerprint(ls, arg));
            }
            fingerprint
        }
    }
}
fn sortid_name<L: LangSpec>(ls: &L, sort: &SortIdOf<L>) -> Name {
    match sort {
        SortId::Algebraic(asi) => ls.algebraic_sort_name(asi.clone()).clone(),
        SortId::TyMetaFunc(MappedType { f, a, .. }) => {
            let TyMetaFuncData { name, idby, .. } = L::Tmfs::ty_meta_func_data(f);
            match idby {
                IdentifiedBy::Tmf => name,
                IdentifiedBy::FirstTmfArg => sortid_name(ls, a.first().unwrap()),
            }
        }
    }
}
fn sortid_polish_name<L: LangSpec>(ls: &L, sort: &SortIdOf<L>) -> Vec<Name> {
    match sort {
        SortId::Algebraic(asi) => vec![ls.algebraic_sort_name(asi.clone()).clone()],
        SortId::TyMetaFunc(MappedType { f, a, .. }) => {
            let TyMetaFuncData { name, idby: _, .. } = L::Tmfs::ty_meta_func_data(f);
            let mut ret = vec![name.clone()];
            for arg in a {
                ret.extend(sortid_polish_name(ls, arg));
            }
            ret
        }
    }
}

fn get_direct_ccf_rels<L>(ls: &L) -> Vec<CcfRelation<SortIdOf<L>>>
where
    L: LangSpec,
{
    let mut ret: Vec<CcfRelation<SortIdOf<L>>> = ls
        .products()
        .map(|pid| CcfRelation {
            from: ls.product_sorts(pid.clone()).collect(),
            to: SortId::Algebraic(AlgebraicSortId::Product(pid)),
        })
        .chain(ls.sums().flat_map(|sid| {
            ls.sum_sorts(sid.clone()).map(move |argsid| CcfRelation {
                from: vec![argsid.clone()],
                to: SortId::Algebraic(AlgebraicSortId::Sum(sid.clone())),
            })
        }))
        .chain(ls.products().map(|sid| CcfRelation {
            from: vec![SortId::Algebraic(AlgebraicSortId::Product(sid.clone()))],
            to: SortId::Algebraic(AlgebraicSortId::Product(sid)),
        }))
        .chain(ls.sums().map(|sid| CcfRelation {
            from: vec![SortId::Algebraic(AlgebraicSortId::Sum(sid.clone()))],
            to: SortId::Algebraic(AlgebraicSortId::Sum(sid)),
        }))
        .collect();
    call_on_all_tmf_monomorphizations(ls, &mut |mt| {
        for argids in L::Tmfs::ty_meta_func_data(&mt.f).canonical_froms {
            ret.push(CcfRelation {
                from: argids.iter().map(|argid| mt.a[argid.0].clone()).collect(),
                to: SortId::TyMetaFunc(mt.clone()),
            });
        }
        ret.push(CcfRelation {
            from: vec![SortId::TyMetaFunc(mt.clone())],
            to: SortId::TyMetaFunc(mt.clone()),
        });
    });
    ret
}

// pub fn find_transitive_ccf_rel<L: LangSpec>(
//     direct_ccf_rels: &[CcfRelation<SortIdOf<L>>],
//     target: &CcfRelation<SortIdOf<L>>,
// ) -> Option<TransitiveCcfConversionPaths<SortIdOf<L>>> {
//     // breadth-first search
//     struct FrontierEntry<SortId> {
//         node: SortId,
//         path: ConversionPath<SortId>,
//     }
//     struct Frontier<SortId>(Vec<FrontierEntry<SortId>>);
//     struct FrontierSet<SortId> {
//         multiway_rel: CcfRelation<SortId>,
//         paths: Vec<Frontier<SortId>>,
//     }
//     let mut frontierses = direct_ccf_rels
//         .iter()
//         .filter_map(|rel| {
//             if rel.to == target.to && rel.from.len() == target.from.len() {
//                 Some(FrontierSet {
//                     multiway_rel: rel.clone(),
//                     paths: rel
//                         .from
//                         .iter()
//                         .map(|from| {
//                             Frontier(vec![FrontierEntry {
//                                 node: from.clone(),
//                                 path: ConversionPath(vec![]),
//                             }])
//                         })
//                         .collect(),
//                 })
//             } else {
//                 None
//             }
//         })
//         .collect::<Vec<_>>();
//     while !frontierses.is_empty() {
//         for fs in frontierses.iter_mut() {
//             let mut new_frontiers = vec![];
//             for (target_from, Frontier(frontier)) in target.from.iter().zip(fs.paths.iter_mut()) {
//                 let mut new_frontier = vec![];
//                 for FrontierEntry { node, path } in frontier.iter() {
//                     if node == target_from {
//                         if frontier.len() > 1 {
//                             new_frontier = vec![FrontierEntry {
//                                 node: node.clone(),
//                                 path: path.clone(),
//                             }];
//                         }
//                         continue;
//                     }
//                     for rel in direct_ccf_rels.iter().filter(|rel| rel.from.len() == 1) {
//                         if rel.to == *node {
//                             let mut new_path = path.clone();
//                             new_path.0.push(node.clone());
//                             new_frontier.push(FrontierEntry {
//                                 node: rel.from.first().unwrap().clone(),
//                                 path: new_path,
//                             });
//                         }
//                     }
//                 }
//                 new_frontiers.push(Frontier(new_frontier));
//             }
//             fs.paths = new_frontiers;
//         }
//     }
//     frontierses.iter().find_map(|fs| {
//         let successful_paths = fs
//             .paths
//             .iter()
//             .zip(target.from.iter())
//             .filter_map(|(frontier, target)| {
//                 if frontier.0.len() == 1 && frontier.0.first().unwrap().node == *target {
//                     Some(frontier.0.first().unwrap().path.clone())
//                 } else {
//                     None
//                 }
//             })
//             .collect::<Vec<_>>();
//         if successful_paths.len() == target.from.len() {
//             Some(TransitiveCcfConversionPaths {
//                 multiway_rel: fs.multiway_rel.clone(),
//                 paths: successful_paths,
//             })
//         } else {
//             None
//         }
//     })
// }

#[derive(Clone, Debug)]
pub struct TransitivelyUnitCcfRelation<SortId> {
    pub to: SortId,
    pub from: SortId,
    pub intermediary: SortId,
}

fn unit_ccf_paths_quadratically_large_closure<L: LangSpec>(
    direct_ccf_rels: &[CcfRelation<SortIdOf<L>>],
) -> Vec<TransitivelyUnitCcfRelation<SortIdOf<L>>> {
    use std::collections::HashSet;
    #[derive(Clone, Debug, PartialEq, Eq, Hash)]
    struct UnitCcfRel<SortId> {
        from: SortId,
        to: SortId,
    }
    let unit_ccf_rels: Vec<_> = direct_ccf_rels
        .iter()
        .filter(|rel| rel.from.len() == 1)
        .map(|rel| UnitCcfRel {
            from: rel.from.first().unwrap().clone(),
            to: rel.to.clone(),
        })
        .collect();
    let unit_ccf_tos: HashSet<_> = unit_ccf_rels.iter().map(|rel| rel.to.clone()).collect();
    fn get_tucr_for_to<L: LangSpec>(
        unit_ccf_rels: &[UnitCcfRel<SortIdOf<L>>],
        to: SortIdOf<L>,
    ) -> Vec<TransitivelyUnitCcfRelation<SortIdOf<L>>> {
        let intermediaries = unit_ccf_rels
            .iter()
            .filter(|rel| rel.to == to && rel.from != to)
            .map(|rel| rel.from.clone())
            .collect::<HashSet<_>>();
        fn get_tucr_for_to_and_intermediary<L: LangSpec>(
            unit_ccf_rels: &[UnitCcfRel<SortIdOf<L>>],
            to: SortIdOf<L>,
            intermediary: SortIdOf<L>,
        ) -> Vec<TransitivelyUnitCcfRelation<SortIdOf<L>>> {
            fn find_all_reachable_from_intermediary<L: LangSpec>(
                unit_ccf_rels: &[UnitCcfRel<SortIdOf<L>>],
                intermediary: SortIdOf<L>,
                forbidden_node: SortIdOf<L>,
            ) -> HashSet<SortIdOf<L>> {
                let mut reachable = HashSet::new();
                let mut deltadb = unit_ccf_rels
                    .iter()
                    .filter(|rel| rel.to == intermediary)
                    .map(|rel| rel.from.clone())
                    .collect::<Vec<_>>();
                while !deltadb.is_empty() {
                    let mut new_deltadb = vec![];
                    for sid in deltadb.iter() {
                        if reachable.contains(sid) || sid == &forbidden_node {
                            continue;
                        }
                        reachable.insert(sid.clone());
                        new_deltadb.extend(
                            unit_ccf_rels
                                .iter()
                                .filter(|rel| rel.to == *sid)
                                .map(|rel| rel.from.clone()),
                        );
                    }
                    deltadb = new_deltadb;
                }
                reachable
            }
            let reachable = find_all_reachable_from_intermediary::<L>(
                unit_ccf_rels,
                intermediary.clone(),
                to.clone(),
            );
            reachable
                .iter()
                .map(move |from| TransitivelyUnitCcfRelation {
                    from: from.clone(),
                    to: to.clone(),
                    intermediary: intermediary.clone(),
                })
                .collect()
        }
        intermediaries
            .iter()
            .flat_map(|intermediary| {
                get_tucr_for_to_and_intermediary::<L>(
                    unit_ccf_rels,
                    to.clone(),
                    intermediary.clone(),
                )
            })
            .collect()
    }
    unit_ccf_tos
        .iter()
        .flat_map(|to| get_tucr_for_to::<L>(&unit_ccf_rels, to.clone()))
        .collect()
}

// fn get_direct_mc_rels<L>(ls: &L) -> Vec<MctRelation>
// where
//     L: LangSpec,
// {
//     ls.products()
//         .flat_map(|pid| {
//             ls.product_sorts(pid.clone()).map(move |sort| MctRelation {
//                 from: pid_fingerprint(ls, &pid),
//                 to: sortid_fingerprint(ls, &sort),
//             })
//         })
//         .chain(
//             ls.sums()
//                 .flat_map(|sid| {
//                     ls.sum_sorts(sid.clone()).map(move |sort| MctRelation {
//                         from: sid_fingerprint(ls, &sid),
//                         to: sortid_fingerprint(ls, &sort),
//                     })
//                 })
//                 .collect::<Vec<_>>(),
//         )
//         .collect()
// }
#[cfg(test)]
mod tests {
    use langspec::humanreadable::LangSpecHuman;
    use term::CcfRelation;

    use crate::{get_direct_ccf_rels, unit_ccf_paths_quadratically_large_closure};

    #[test]
    fn test_gdcr() {
        let ls = langspec_examples::fib();
        type L = LangSpecHuman<tymetafuncspec_core::Core>;
        let dcr = get_direct_ccf_rels(&ls);
        for rel in dcr.iter() {
            println!("{:?}\n", rel);
        }
        let n: langspec::langspec::SortIdOf<L> =
            langspec::langspec::SortId::Algebraic(langspec::langspec::AlgebraicSortId::Sum(
                langspec::langspec::LangSpec::sums(&ls).next().unwrap(),
            ));
        // let rel = find_transitive_ccf_rel::<L>(
        //     &dcr,
        //     &CcfRelation {
        //         from: vec![n.clone()],
        //         to: langspec::langspec::SortId::Algebraic(
        //             langspec::langspec::AlgebraicSortId::Product(
        //                 langspec::langspec::LangSpec::products(&ls).next().unwrap(),
        //             ),
        //         ),
        //     },
        // );
        // dbg!(&rel);
        for rel in unit_ccf_paths_quadratically_large_closure::<L>(&dcr) {
            println!("{:?}\n", rel);
        }
    }
}
