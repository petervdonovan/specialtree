use langspec::langspec::{AlgebraicSortId, LangSpec, Name, SortId, SortIdOf, SortShape};
use syn::parse_quote;

pub use proc_macro2;

#[macro_export]
macro_rules! byline {
    () => {{
        let ret: $crate::proc_macro2::TokenStream =
            format!("/// generated by [{}]", $crate::function!())
                .parse()
                .unwrap();
        ret
    }};
}
#[macro_export]
macro_rules! function {
    () => {{
        fn f() {}
        fn type_name_of<T>(_: T) -> &'static str {
            std::any::type_name::<T>()
        }
        let name = type_name_of(f);
        name.strip_suffix("::f")
            .unwrap()
            .trim_end_matches("::{{closure}}")
    }};
}

pub fn name_as_snake_ident(name: &Name) -> syn::Ident {
    syn::Ident::new(&name.snake, proc_macro2::Span::call_site())
}
pub fn name_as_camel_ident(name: &Name) -> syn::Ident {
    syn::Ident::new(&name.camel, proc_macro2::Span::call_site())
}

pub struct ProdGenData<
    I0: Iterator<Item = syn::Ident>,
    I1: Iterator<Item = syn::Ident>,
    I2: Iterator<Item = syn::Type>,
    I3: Iterator<Item = SortShape>,
    I4: Iterator<Item = syn::LitInt>,
    I5: Iterator<Item = syn::Ident>,
> {
    pub snake_ident: syn::Ident,
    pub camel_ident: syn::Ident,
    pub rs_ty: syn::Type,
    pub n_sorts: usize,
    pub sort_rs_camel_idents: I0,
    pub sort_rs_snake_idents: I1,
    pub sort_rs_types: I2,
    pub sort_shapes: I3,
    pub idx: I4,
    pub ty_idx: I5,
}

pub struct SumGenData<
    I0: Iterator<Item = syn::Ident>,
    I1: Iterator<Item = syn::Ident>,
    I2: Iterator<Item = syn::Type>,
    I3: Iterator<Item = SortShape>,
> {
    pub snake_ident: syn::Ident,
    pub camel_ident: syn::Ident,
    pub rs_ty: syn::Type,
    pub n_sorts: usize,
    pub sort_rs_camel_idents: I0,
    pub sort_rs_snake_idents: I1,
    pub sort_rs_types: I2,
    pub sort_shapes: I3,
}

pub struct CommonGenData<I0: Iterator<Item = syn::Ident>, I1: Iterator<Item = syn::Ident>> {
    pub snake_ident: I0,
    pub camel_ident: I1,
}

#[macro_export]
macro_rules! transpose {
    ($records:expr, $($field:ident),*) => {
        $(
            let mut $field = vec![];
        )*
        for record67142647 in $records {
            $(
                $field.push(record67142647.$field);
            )*
        }
        $(
            let $field = $field;
        )*
    };
}

#[macro_export]
macro_rules! collect {
    ($($field:ident),*) => {
        $(
            let $field = $field.collect::<Vec<_>>();
        )*
    };
}

pub struct LangSpecGen<'a, L: LangSpec> {
    pub bak: &'a L,
    pub sort2rs_type: for<'b> fn(&'b syn::Path, SortId<syn::Type>) -> syn::Type,
    pub type_base_path: syn::Path,
}

impl<'a, L: LangSpec> LangSpecGen<'a, L> {
    pub fn camel_ident(&self) -> syn::Ident {
        name_as_camel_ident(self.bak.name())
    }
    pub fn asi2rs_type(&self, asi: AlgebraicSortId<L::ProductId, L::SumId>) -> syn::Type {
        let name = self.bak.algebraic_sort_name(asi);
        let ty_name = name_as_camel_ident(name);
        let tbp = &self.type_base_path;
        parse_quote!(#tbp::#ty_name)
    }
    pub fn sort2rs_type(&self, sort: SortIdOf<L>) -> syn::Type {
        (self.sort2rs_type)(&self.type_base_path, sort)
    }
    pub fn asi2rs_ident(&self, asi: AlgebraicSortId<L::ProductId, L::SumId>) -> syn::Ident {
        let name = self.bak.algebraic_sort_name(asi);
        name_as_camel_ident(name)
    }
    pub fn sort2rs_ident(&self, sort: SortIdOf<L>) -> syn::Ident {
        match sort {
            SortId::NatLiteral => syn::Ident::new("NatLit", proc_macro2::Span::call_site()),
            SortId::Algebraic(asi) => self.asi2rs_ident(asi),
            SortId::Set(asi) => syn::Ident::new(
                &format!("SetOf{}", self.asi2rs_ident(asi)),
                proc_macro2::Span::call_site(),
            ),
            SortId::Sequence(asi) => syn::Ident::new(
                &format!("SeqOf{}", self.asi2rs_ident(asi)),
                proc_macro2::Span::call_site(),
            ),
        }
    }
    // pub fn sort2rs_ty_relpath(
    //     &self,
    //     sort: SortId<AlgebraicSortId<L::ProductId, L::SumId>>,
    // ) -> syn::Type {
    //     match sort {
    //         SortId::NatLiteral => syn::parse_quote! { NatLit },
    //         SortId::Algebraic(asi) => {
    //             let ident = self.asi2rs_ident(asi);
    //             syn::parse_quote! { #ident }
    //         }
    //         SortId::Set(asi) => {
    //             let ident = self.asi2rs_ident(asi);
    //             syn::parse_quote! { SetOf<#ident> }
    //         }
    //         SortId::Sequence(asi) => {
    //             let ident = self.asi2rs_ident(asi);
    //             syn::parse_quote! { SeqOf<#ident> }
    //         }
    //     }
    // }
    pub fn sort2rs_snake_ident(
        &self,
        sort: SortId<AlgebraicSortId<L::ProductId, L::SumId>>,
    ) -> syn::Ident {
        match sort {
            SortId::NatLiteral => syn::Ident::new("nat_lit", proc_macro2::Span::call_site()),
            SortId::Algebraic(asi) => {
                let name = self.bak.algebraic_sort_name(asi);
                name_as_snake_ident(name)
            }
            SortId::Set(asi) => syn::Ident::new(
                &format!("nat_set_of_{}", self.asi2rs_ident(asi)),
                proc_macro2::Span::call_site(),
            ),
            SortId::Sequence(asi) => syn::Ident::new(
                &format!("nat_seq_of_{}", self.asi2rs_ident(asi)),
                proc_macro2::Span::call_site(),
            ),
        }
    }
    pub fn common_gen_datas(
        &self,
    ) -> CommonGenData<impl Iterator<Item = syn::Ident> + '_, impl Iterator<Item = syn::Ident> + '_>
    {
        let snake_ident = self.bak.products().map(|id| {
            syn::Ident::new(
                &self.bak.product_name(id.clone()).snake.clone(),
                proc_macro2::Span::call_site(),
            )
        });
        let camel_ident = self.bak.products().map(|id| {
            syn::Ident::new(
                &self.bak.product_name(id.clone()).camel.clone(),
                proc_macro2::Span::call_site(),
            )
        });
        CommonGenData {
            snake_ident,
            camel_ident,
        }
    }
    pub fn prod_gen_datas<'b>(
        &'b self,
    ) -> impl Iterator<
        Item = ProdGenData<
            impl Iterator<Item = syn::Ident> + 'b,
            impl Iterator<Item = syn::Ident> + 'b,
            impl Iterator<Item = syn::Type> + 'b,
            impl Iterator<Item = SortId<AlgebraicSortId<(), ()>>> + 'b,
            impl Iterator<Item = syn::LitInt> + 'b,
            impl Iterator<Item = syn::Ident> + 'b,
        >,
    > + 'b
    where
        'a: 'b,
    {
        self.bak.products().map(move |id| {
            let snake_ident = syn::Ident::new(
                &self.bak.product_name(id.clone()).snake.clone(),
                proc_macro2::Span::call_site(),
            );
            let camel_ident = syn::Ident::new(
                &self.bak.product_name(id.clone()).camel.clone(),
                proc_macro2::Span::call_site(),
            );
            let rs_ty = parse_quote!(#camel_ident);
            let sort_rs_camel_idents = self
                .bak
                .product_sorts(id.clone())
                .map(|sort| self.sort2rs_ident(self.bak.sid_convert(sort)));
            let sort_rs_snake_idents = self
                .bak
                .product_sorts(id.clone())
                .map(|sort| self.sort2rs_snake_ident(self.bak.sid_convert(sort)));
            let sort_rs_types = self
                .bak
                .product_sorts(id.clone())
                .map(|sort| self.sort2rs_type(sort));
            let sort_shapes = self
                .bak
                .product_sorts(id.clone())
                .map(|it| SortShape::project(self.bak, it));
            let n_sorts = self.bak.product_sorts(id).count();
            let idx = (0..n_sorts)
                .map(|i| syn::LitInt::new(&i.to_string(), proc_macro2::Span::call_site()));
            let ty_idx = (0..n_sorts)
                .map(|it| format!("T{}", it)) // This is a hack: name generation. Move it to gen utils at least
                .map(|it| syn::Ident::new(&it, proc_macro2::Span::call_site()));
            ProdGenData {
                snake_ident,
                camel_ident,
                rs_ty,
                n_sorts,
                sort_rs_camel_idents,
                sort_rs_snake_idents,
                sort_rs_types,
                sort_shapes,
                idx,
                ty_idx,
            }
        })
    }
    pub fn sum_gen_datas<'b>(
        &'b self,
    ) -> impl Iterator<
        Item = SumGenData<
            impl Iterator<Item = syn::Ident> + 'b,
            impl Iterator<Item = syn::Ident> + 'b,
            impl Iterator<Item = syn::Type> + 'b,
            impl Iterator<Item = SortShape> + 'b,
        >,
    > + 'b
    where
        'a: 'b,
    {
        self.bak.sums().map(move |id| {
            let snake_ident = syn::Ident::new(
                &self.bak.sum_name(id.clone()).snake.clone(),
                proc_macro2::Span::call_site(),
            );
            let camel_ident = syn::Ident::new(
                &self.bak.sum_name(id.clone()).camel.clone(),
                proc_macro2::Span::call_site(),
            );
            let rs_ty = parse_quote!(#camel_ident);
            let sort_rs_camel_idents = self
                .bak
                .sum_sorts(id.clone())
                .map(|sort| self.sort2rs_ident(self.bak.sid_convert(sort)));
            let sort_rs_snake_idents = self
                .bak
                .sum_sorts(id.clone())
                .map(|sort| self.sort2rs_snake_ident(self.bak.sid_convert(sort)));
            let sort_rs_types = self
                .bak
                .sum_sorts(id.clone())
                .map(|sort| self.sort2rs_type(sort));
            let sort_shapes = self
                .bak
                .sum_sorts(id.clone())
                .map(|it| it.fmap(|it| self.bak.asi_convert(it).fmap_p(|_| ()).fmap_s(|_| ())));
            let n_sorts = self.bak.sum_sorts(id).count();
            SumGenData {
                snake_ident,
                camel_ident,
                rs_ty,
                n_sorts,
                sort_rs_camel_idents,
                sort_rs_snake_idents,
                sort_rs_types,
                sort_shapes,
            }
        })
    }
}
