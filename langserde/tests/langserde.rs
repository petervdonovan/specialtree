/// generated by [langserde::generate]
fn parse<LImpl: crate::extension_of::LImpl, Nat: crate::extension_of::owned::Nat<LImpl = LImpl>>(
    input: &str,
) -> Result<(LImpl, Nat), ()> {
    let refbased: crate::data_structure::refbased::Nat =
        serde_json::from_str(input).map_err(|e| println!("Parse error: {e}"))?;
    use crate::extension_of::reference::Nat;
    let l = core::default::Default::default();
    let mut lo = core::default::Default::default();
    let ret = refbased.convert(&l, &mut lo);
    Ok((lo, ret))
}
/// generated by [langserde::generate]
fn unparse<
    LImpl: crate::extension_of::LImpl,
    Nat: crate::extension_of::owned::Nat<LImpl = LImpl>,
>(
    lo: &LImpl,
    own: Nat,
) -> Result<String, ()> {
    use crate::extension_of::reference::Nat;
    let mut l = core::default::Default::default();
    let refbased: crate::data_structure::refbased::Nat = own.get_ref(lo).convert(lo, &mut l);
    serde_json::to_string_pretty(&refbased).map_err(|_| ())
}
/// generated by [refbased_related_gen::generate]
pub mod refbased_extension_of {
    /// generated by [refbased_related_gen::limpl]
    impl crate::extension_of::LImpl for crate::data_structure::refbased::Fib {
        type NatLit = crate::data_structure::refbased::NatLit;
        type Plus = crate::data_structure::refbased::Plus;
        type F = crate::data_structure::refbased::F;
        type Nat = crate::data_structure::refbased::Nat;
    }
    /// generated by [refbased_related_gen::owned::generate]
    pub mod owned {
        /// generated by [refbased_related_gen::owned::gen_nat_lit]
        impl crate::extension_of::owned::NatLit for crate::data_structure::refbased::NatLit {
            type LImpl = crate::data_structure::refbased::Fib;
            fn get_ref<'a, 'b: 'a>(
                &'a self,
                _l: &'b Self::LImpl,
            ) -> impl crate::extension_of::reference::NatLit<'a, LImpl = Self::LImpl> {
                *self
            }
            fn get_mut<'a, 'b: 'a>(
                &'a mut self,
                _l: &'b mut Self::LImpl,
            ) -> impl crate::extension_of::mut_reference::NatLit<'a, LImpl = Self::LImpl>
            {
                self
            }
        }
        /// generated by [refbased_related_gen::owned::gen_prods]
        impl crate::extension_of::owned::Plus for crate::data_structure::refbased::Plus {
            type LImpl = crate::data_structure::refbased::Fib;
            fn new(
                _l: &mut Self::LImpl,
                args: (
                    <Self::LImpl as crate::extension_of::LImpl>::Nat,
                    <Self::LImpl as crate::extension_of::LImpl>::Nat,
                ),
            ) -> Self {
                Self(args.0, args.1)
            }
            fn get_ref<'a, 'b: 'a>(
                &'a self,
                _l: &'b Self::LImpl,
            ) -> impl crate::extension_of::reference::Plus<'a, LImpl = Self::LImpl> {
                self
            }
            fn get_mut<'a, 'b: 'a>(
                &'a mut self,
                _l: &'b mut Self::LImpl,
            ) -> impl crate::extension_of::mut_reference::Plus<'a, LImpl = Self::LImpl>
            {
                self
            }
        }
        /// generated by [refbased_related_gen::owned::gen_prods]
        impl crate::extension_of::owned::F for crate::data_structure::refbased::F {
            type LImpl = crate::data_structure::refbased::Fib;
            fn new(
                _l: &mut Self::LImpl,
                args: (<Self::LImpl as crate::extension_of::LImpl>::Nat,),
            ) -> Self {
                Self(args.0)
            }
            fn get_ref<'a, 'b: 'a>(
                &'a self,
                _l: &'b Self::LImpl,
            ) -> impl crate::extension_of::reference::F<'a, LImpl = Self::LImpl> {
                self
            }
            fn get_mut<'a, 'b: 'a>(
                &'a mut self,
                _l: &'b mut Self::LImpl,
            ) -> impl crate::extension_of::mut_reference::F<'a, LImpl = Self::LImpl> {
                self
            }
        }
        /// generated by [refbased_related_gen::owned::gen_sums]
        impl crate::extension_of::owned::Nat for crate::data_structure::refbased::Nat {
            type LImpl = crate::data_structure::refbased::Fib;
            fn nat_lit(
                _l: &mut Self::LImpl,
                from: <Self::LImpl as crate::extension_of::LImpl>::NatLit,
            ) -> Self {
                Self::NatLit((|a| a)(from))
            }
            fn f(
                _l: &mut Self::LImpl,
                from: <Self::LImpl as crate::extension_of::LImpl>::F,
            ) -> Self {
                Self::F((Box::new)(from))
            }
            fn plus(
                _l: &mut Self::LImpl,
                from: <Self::LImpl as crate::extension_of::LImpl>::Plus,
            ) -> Self {
                Self::Plus((Box::new)(from))
            }
            fn get_ref(
                &self,
                _l: &Self::LImpl,
            ) -> impl crate::extension_of::reference::Nat<'_, LImpl = Self::LImpl> {
                self
            }
            fn get_mut(
                &mut self,
                _l: &mut Self::LImpl,
            ) -> impl crate::extension_of::mut_reference::Nat<'_, LImpl = Self::LImpl> {
                self
            }
        }
    }
    /// generated by [refbased_related_gen::reference::generate]
    pub mod reference {
        impl<'a> crate::extension_of::reference::NatLit<'a> for crate::data_structure::refbased::NatLit {
            type LImpl = crate::data_structure::refbased::Fib;
            fn is_eq<'b: 'a>(self, _l: &'b Self::LImpl, other: Self) -> bool {
                self == other
            }
        }
        /// generated by [refbased_related_gen::reference::gen_prods]
        impl<'a> crate::extension_of::reference::Plus<'a> for &'a crate::data_structure::refbased::Plus {
            type LImpl = crate::data_structure::refbased::Fib;
            type T0 = &'a crate::data_structure::refbased::Nat;
            type T1 = &'a crate::data_structure::refbased::Nat;
            fn is_eq<'b: 'a>(self, l: &'b Self::LImpl, other: Self) -> bool {
                use crate::extension_of::reference::Nat;
                let mut ret = true;
                {
                    let mine =
                        <Self as crate::extension_of::Projection<Self::LImpl, 0>>::project(self, l);
                    let their_data =
                        <Self as crate::extension_of::Projection<Self::LImpl, 0>>::project(
                            other, l,
                        );
                    ret = ret && mine.is_eq(l, their_data);
                }
                {
                    let mine =
                        <Self as crate::extension_of::Projection<Self::LImpl, 1>>::project(self, l);
                    let their_data =
                        <Self as crate::extension_of::Projection<Self::LImpl, 1>>::project(
                            other, l,
                        );
                    ret = ret && mine.is_eq(l, their_data);
                }
                ret
            }
        }
        /// generated by [refbased_related_gen::reference::gen_prods]
        impl<'a> crate::extension_of::reference::F<'a> for &'a crate::data_structure::refbased::F {
            type LImpl = crate::data_structure::refbased::Fib;
            type T0 = &'a crate::data_structure::refbased::Nat;
            fn is_eq<'b: 'a>(self, l: &'b Self::LImpl, other: Self) -> bool {
                use crate::extension_of::reference::Nat;
                let mut ret = true;
                {
                    let mine =
                        <Self as crate::extension_of::Projection<Self::LImpl, 0>>::project(self, l);
                    let their_data =
                        <Self as crate::extension_of::Projection<Self::LImpl, 0>>::project(
                            other, l,
                        );
                    ret = ret && mine.is_eq(l, their_data);
                }
                ret
            }
        }
        impl<'a> crate::extension_of::Projection<crate::data_structure::refbased::Fib, 0>
            for &'a crate::data_structure::refbased::Plus
        {
            type To = &'a crate::data_structure::refbased::Nat;
            fn project(self, _l: &crate::data_structure::refbased::Fib) -> Self::To {
                &self.0
            }
        }
        impl<'a> crate::extension_of::Projection<crate::data_structure::refbased::Fib, 1>
            for &'a crate::data_structure::refbased::Plus
        {
            type To = &'a crate::data_structure::refbased::Nat;
            fn project(self, _l: &crate::data_structure::refbased::Fib) -> Self::To {
                &self.1
            }
        }
        impl<'a> crate::extension_of::Projection<crate::data_structure::refbased::Fib, 0>
            for &'a crate::data_structure::refbased::F
        {
            type To = &'a crate::data_structure::refbased::Nat;
            fn project(self, _l: &crate::data_structure::refbased::Fib) -> Self::To {
                &self.0
            }
        }
        /// generated by [refbased_related_gen::reference::gen_sums]
        impl<'a> crate::extension_of::reference::Nat<'a> for &'a crate::data_structure::refbased::Nat {
            type LImpl = crate::data_structure::refbased::Fib;
            type NatLit = crate::data_structure::refbased::NatLit;
            type F = &'a crate::data_structure::refbased::F;
            type Plus = &'a crate::data_structure::refbased::Plus;
            fn nat_lit<'b: 'a>(self, _l: &'b Self::LImpl) -> Option<Self::NatLit> {
                match self {
                    crate::data_structure::refbased::Nat::NatLit(a) => Some(*a),
                    _ => None,
                }
            }
            fn f<'b: 'a>(self, _l: &'b Self::LImpl) -> Option<Self::F> {
                match self {
                    crate::data_structure::refbased::Nat::F(a) => Some(a),
                    _ => None,
                }
            }
            fn plus<'b: 'a>(self, _l: &'b Self::LImpl) -> Option<Self::Plus> {
                match self {
                    crate::data_structure::refbased::Nat::Plus(a) => Some(a),
                    _ => None,
                }
            }
            fn is_eq<'b: 'a>(self, l: &'b Self::LImpl, other: Self) -> bool {
                use crate::extension_of::reference::NatLit;
                use crate::extension_of::reference::Plus;
                use crate::extension_of::reference::F;
                match (self, other) {
                    (
                        crate::data_structure::refbased::Nat::NatLit(b),
                        crate::data_structure::refbased::Nat::NatLit(a),
                    ) => b.is_eq(l, *a),
                    (
                        crate::data_structure::refbased::Nat::F(b),
                        crate::data_structure::refbased::Nat::F(a),
                    ) => b.is_eq(l, a),
                    (
                        crate::data_structure::refbased::Nat::Plus(b),
                        crate::data_structure::refbased::Nat::Plus(a),
                    ) => b.is_eq(l, a),
                    _ => false,
                }
            }
        }
    }
    /// generated by [refbased_related_gen::mut_reference::generate]
    pub mod mut_reference {
        /// generated by [refbased_related_gen::mut_reference::gen_nat_lit]
        impl<'a> crate::extension_of::mut_reference::NatLit<'a>
            for &'a mut crate::data_structure::refbased::NatLit
        {
            type LImpl = crate::data_structure::refbased::Fib;
        }
        /// generated by [refbased_related_gen::mut_reference::gen_prods]
        impl<'a> crate::extension_of::mut_reference::Plus<'a>
            for &'a mut crate::data_structure::refbased::Plus
        {
            type LImpl = crate::data_structure::refbased::Fib;
            type T0 = &'a mut crate::data_structure::refbased::Nat;
            type T1 = &'a mut crate::data_structure::refbased::Nat;
        }
        /// generated by [refbased_related_gen::mut_reference::gen_prods]
        impl<'a> crate::extension_of::mut_reference::F<'a> for &'a mut crate::data_structure::refbased::F {
            type LImpl = crate::data_structure::refbased::Fib;
            type T0 = &'a mut crate::data_structure::refbased::Nat;
        }
        impl<'a> crate::extension_of::Projection<crate::data_structure::refbased::Fib, 0>
            for &'a mut crate::data_structure::refbased::Plus
        {
            type To = &'a mut crate::data_structure::refbased::Nat;
            fn project(self, _l: &crate::data_structure::refbased::Fib) -> Self::To {
                &mut self.0
            }
        }
        impl<'a> crate::extension_of::Projection<crate::data_structure::refbased::Fib, 1>
            for &'a mut crate::data_structure::refbased::Plus
        {
            type To = &'a mut crate::data_structure::refbased::Nat;
            fn project(self, _l: &crate::data_structure::refbased::Fib) -> Self::To {
                &mut self.1
            }
        }
        impl<'a> crate::extension_of::Projection<crate::data_structure::refbased::Fib, 0>
            for &'a mut crate::data_structure::refbased::F
        {
            type To = &'a mut crate::data_structure::refbased::Nat;
            fn project(self, _l: &crate::data_structure::refbased::Fib) -> Self::To {
                &mut self.0
            }
        }
        /// generated by [refbased_related_gen::mut_reference::gen_sums]
        impl<'a> crate::extension_of::mut_reference::Nat<'a>
            for &'a mut crate::data_structure::refbased::Nat
        {
            type LImpl = crate::data_structure::refbased::Fib;
            type Owned = crate::data_structure::refbased::Nat;
            type NatLit = &'a mut crate::data_structure::refbased::NatLit;
            type F = &'a mut crate::data_structure::refbased::F;
            type Plus = &'a mut crate::data_structure::refbased::Plus;
            fn nat_lit<'b: 'a>(self, _l: &'b Self::LImpl) -> Option<Self::NatLit> {
                match self {
                    crate::data_structure::refbased::Nat::NatLit(a) => Some(a),
                    _ => None,
                }
            }
            fn f<'b: 'a>(self, _l: &'b Self::LImpl) -> Option<Self::F> {
                match self {
                    crate::data_structure::refbased::Nat::F(a) => Some(a),
                    _ => None,
                }
            }
            fn plus<'b: 'a>(self, _l: &'b Self::LImpl) -> Option<Self::Plus> {
                match self {
                    crate::data_structure::refbased::Nat::Plus(a) => Some(a),
                    _ => None,
                }
            }
            fn set<'b: 'a>(self, _l: &'b mut Self::LImpl, value: Self::Owned) {
                *self = value;
            }
        }
    }
}
/// generated by [idxbased_related_gen::generate]
pub mod idxbased_extension_of {
    /// generated by [idxbased_related_gen::limpl]
    impl crate::extension_of::LImpl for crate::data_structure::idxbased::Fib {
        type NatLit = crate::data_structure::idxbased::NatLit;
        type Plus = crate::data_structure::idxbased::Plus;
        type F = crate::data_structure::idxbased::F;
        type Nat = crate::data_structure::idxbased::Nat;
    }
    /// generated by [idxbased_related_gen::limpl]
    impl core::default::Default for crate::data_structure::idxbased::Fib {
        fn default() -> Self {
            Self {
                plus: core::default::Default::default(),
                f: core::default::Default::default(),
                nat: core::default::Default::default(),
            }
        }
    }
    /// generated by [idxbased_related_gen::owned::generate]
    pub mod owned {
        /// generated by [idxbased_related_gen::owned::nat_lit]
        impl crate::extension_of::owned::NatLit for crate::data_structure::idxbased::NatLit {
            type LImpl = crate::data_structure::idxbased::Fib;
            fn get_ref<'a, 'b: 'a>(
                &'a self,
                _l: &'b Self::LImpl,
            ) -> impl crate::extension_of::reference::NatLit<'a, LImpl = Self::LImpl> {
                *self
            }
            fn get_mut<'a, 'b: 'a>(
                &'a mut self,
                _l: &'b mut Self::LImpl,
            ) -> impl crate::extension_of::mut_reference::NatLit<'a, LImpl = Self::LImpl>
            {
                *self
            }
        }
        /// generated by [idxbased_related_gen::owned::nat_lit]
        impl std::convert::From<u64> for crate::data_structure::idxbased::NatLit {
            fn from(x: u64) -> Self {
                Self(x)
            }
        }
        /// generated by [idxbased_related_gen::owned::nat_lit]
        impl std::convert::From<crate::data_structure::idxbased::NatLit> for u64 {
            fn from(x: crate::data_structure::idxbased::NatLit) -> Self {
                x.0
            }
        }
        /// generated by [idxbased_related_gen::owned::gen_prods]
        impl crate::extension_of::owned::Plus for crate::data_structure::idxbased::Plus {
            type LImpl = crate::data_structure::idxbased::Fib;
            fn new(
                l: &mut Self::LImpl,
                args: (
                    <Self::LImpl as crate::extension_of::LImpl>::Nat,
                    <Self::LImpl as crate::extension_of::LImpl>::Nat,
                ),
            ) -> Self {
                let data = crate::data_structure::idxbased::data::Plus(args.0, args.1);
                let ret = l.plus.len();
                l.plus.push(data);
                Self(ret)
            }
            fn get_ref<'a, 'b: 'a>(
                &'a self,
                _l: &'b Self::LImpl,
            ) -> impl crate::extension_of::reference::Plus<'a, LImpl = Self::LImpl> {
                *self
            }
            fn get_mut<'a, 'b: 'a>(
                &'a mut self,
                _l: &'b mut Self::LImpl,
            ) -> impl crate::extension_of::mut_reference::Plus<'a, LImpl = Self::LImpl>
            {
                *self
            }
        }
        /// generated by [idxbased_related_gen::owned::gen_prods]
        impl crate::extension_of::owned::F for crate::data_structure::idxbased::F {
            type LImpl = crate::data_structure::idxbased::Fib;
            fn new(
                l: &mut Self::LImpl,
                args: (<Self::LImpl as crate::extension_of::LImpl>::Nat,),
            ) -> Self {
                let data = crate::data_structure::idxbased::data::F(args.0);
                let ret = l.f.len();
                l.f.push(data);
                Self(ret)
            }
            fn get_ref<'a, 'b: 'a>(
                &'a self,
                _l: &'b Self::LImpl,
            ) -> impl crate::extension_of::reference::F<'a, LImpl = Self::LImpl> {
                *self
            }
            fn get_mut<'a, 'b: 'a>(
                &'a mut self,
                _l: &'b mut Self::LImpl,
            ) -> impl crate::extension_of::mut_reference::F<'a, LImpl = Self::LImpl> {
                *self
            }
        }
        /// generated by [idxbased_related_gen::owned::gen_sums]
        impl crate::extension_of::owned::Nat for crate::data_structure::idxbased::Nat {
            type LImpl = crate::data_structure::idxbased::Fib;
            fn nat_lit(
                l: &mut Self::LImpl,
                from: <Self::LImpl as crate::extension_of::LImpl>::NatLit,
            ) -> Self {
                let data = crate::data_structure::idxbased::data::Nat::NatLit(from);
                let ret = l.nat.len();
                l.nat.push(data);
                Self(ret)
            }
            fn f(
                l: &mut Self::LImpl,
                from: <Self::LImpl as crate::extension_of::LImpl>::F,
            ) -> Self {
                let data = crate::data_structure::idxbased::data::Nat::F(from);
                let ret = l.nat.len();
                l.nat.push(data);
                Self(ret)
            }
            fn plus(
                l: &mut Self::LImpl,
                from: <Self::LImpl as crate::extension_of::LImpl>::Plus,
            ) -> Self {
                let data = crate::data_structure::idxbased::data::Nat::Plus(from);
                let ret = l.nat.len();
                l.nat.push(data);
                Self(ret)
            }
            fn get_ref(
                &self,
                _l: &Self::LImpl,
            ) -> impl crate::extension_of::reference::Nat<'_, LImpl = Self::LImpl> {
                *self
            }
            fn get_mut(
                &mut self,
                _l: &mut Self::LImpl,
            ) -> impl crate::extension_of::mut_reference::Nat<'_, LImpl = Self::LImpl> {
                *self
            }
        }
    }
    /// generated by [idxbased_related_gen::reference::generate]
    pub mod reference {
        impl<'a> crate::extension_of::reference::NatLit<'a> for crate::data_structure::idxbased::NatLit {
            type LImpl = crate::data_structure::idxbased::Fib;
            fn is_eq<'b: 'a>(self, _l: &'b Self::LImpl, other: Self) -> bool {
                self.0 == other.0
            }
        }
        /// generated by [idxbased_related_gen::reference::gen_prods]
        impl<'a> crate::extension_of::reference::Plus<'a> for crate::data_structure::idxbased::Plus {
            type LImpl = crate::data_structure::idxbased::Fib;
            type T0 = crate::data_structure::idxbased::Nat;
            type T1 = crate::data_structure::idxbased::Nat;
            fn is_eq<'b: 'a>(self, l: &'b Self::LImpl, other: Self) -> bool {
                use crate::extension_of::reference::Nat;
                let mut ret = true;
                {
                    let mine =
                        <Self as crate::extension_of::Projection<Self::LImpl, 0>>::project(self, l);
                    let their_data =
                        <Self as crate::extension_of::Projection<Self::LImpl, 0>>::project(
                            other, l,
                        );
                    ret = ret && mine.is_eq(l, their_data);
                }
                {
                    let mine =
                        <Self as crate::extension_of::Projection<Self::LImpl, 1>>::project(self, l);
                    let their_data =
                        <Self as crate::extension_of::Projection<Self::LImpl, 1>>::project(
                            other, l,
                        );
                    ret = ret && mine.is_eq(l, their_data);
                }
                ret
            }
        }
        /// generated by [idxbased_related_gen::reference::gen_prods]
        impl<'a> crate::extension_of::reference::F<'a> for crate::data_structure::idxbased::F {
            type LImpl = crate::data_structure::idxbased::Fib;
            type T0 = crate::data_structure::idxbased::Nat;
            fn is_eq<'b: 'a>(self, l: &'b Self::LImpl, other: Self) -> bool {
                use crate::extension_of::reference::Nat;
                let mut ret = true;
                {
                    let mine =
                        <Self as crate::extension_of::Projection<Self::LImpl, 0>>::project(self, l);
                    let their_data =
                        <Self as crate::extension_of::Projection<Self::LImpl, 0>>::project(
                            other, l,
                        );
                    ret = ret && mine.is_eq(l, their_data);
                }
                ret
            }
        }
        impl crate::extension_of::Projection<crate::data_structure::idxbased::Fib, 0>
            for crate::data_structure::idxbased::Plus
        {
            type To = crate::data_structure::idxbased::Nat;
            fn project(self, l: &crate::data_structure::idxbased::Fib) -> Self::To {
                let my_data = &l.plus[self.0];
                my_data.0
            }
        }
        impl crate::extension_of::Projection<crate::data_structure::idxbased::Fib, 1>
            for crate::data_structure::idxbased::Plus
        {
            type To = crate::data_structure::idxbased::Nat;
            fn project(self, l: &crate::data_structure::idxbased::Fib) -> Self::To {
                let my_data = &l.plus[self.0];
                my_data.1
            }
        }
        impl crate::extension_of::Projection<crate::data_structure::idxbased::Fib, 0>
            for crate::data_structure::idxbased::F
        {
            type To = crate::data_structure::idxbased::Nat;
            fn project(self, l: &crate::data_structure::idxbased::Fib) -> Self::To {
                let my_data = &l.f[self.0];
                my_data.0
            }
        }
        /// generated by [idxbased_related_gen::reference::gen_sums]
        impl<'a> crate::extension_of::reference::Nat<'a> for crate::data_structure::idxbased::Nat {
            type LImpl = crate::data_structure::idxbased::Fib;
            type NatLit = crate::data_structure::idxbased::NatLit;
            type F = crate::data_structure::idxbased::F;
            type Plus = crate::data_structure::idxbased::Plus;
            fn nat_lit<'b: 'a>(self, l: &'b Self::LImpl) -> Option<Self::NatLit> {
                let my_data = &l.nat[self.0];
                match my_data {
                    crate::data_structure::idxbased::data::Nat::NatLit(a) => Some(*a),
                    _ => None,
                }
            }
            fn f<'b: 'a>(self, l: &'b Self::LImpl) -> Option<Self::F> {
                let my_data = &l.nat[self.0];
                match my_data {
                    crate::data_structure::idxbased::data::Nat::F(a) => Some(*a),
                    _ => None,
                }
            }
            fn plus<'b: 'a>(self, l: &'b Self::LImpl) -> Option<Self::Plus> {
                let my_data = &l.nat[self.0];
                match my_data {
                    crate::data_structure::idxbased::data::Nat::Plus(a) => Some(*a),
                    _ => None,
                }
            }
            fn is_eq<'b: 'a>(self, l: &'b Self::LImpl, other: Self) -> bool {
                use crate::extension_of::reference::NatLit;
                use crate::extension_of::reference::Plus;
                use crate::extension_of::reference::F;
                match (&l.nat[self.0], &l.nat[other.0]) {
                    (
                        crate::data_structure::idxbased::data::Nat::NatLit(a),
                        crate::data_structure::idxbased::data::Nat::NatLit(b),
                    ) => a.is_eq(l, *b),
                    (
                        crate::data_structure::idxbased::data::Nat::F(a),
                        crate::data_structure::idxbased::data::Nat::F(b),
                    ) => a.is_eq(l, *b),
                    (
                        crate::data_structure::idxbased::data::Nat::Plus(a),
                        crate::data_structure::idxbased::data::Nat::Plus(b),
                    ) => a.is_eq(l, *b),
                    _ => false,
                }
            }
        }
    }
    /// generated by [idxbased_related_gen::mut_reference::generate]
    pub mod mut_reference {
        /// generated by [idxbased_related_gen::mut_reference::gen_nat_lit]
        impl<'a> crate::extension_of::mut_reference::NatLit<'a>
            for crate::data_structure::idxbased::NatLit
        {
            type LImpl = crate::data_structure::idxbased::Fib;
        }
        /// generated by [idxbased_related_gen::mut_reference::gen_prods]
        impl<'a> crate::extension_of::mut_reference::Plus<'a> for crate::data_structure::idxbased::Plus {
            type LImpl = crate::data_structure::idxbased::Fib;
            type T0 = crate::data_structure::idxbased::Nat;
            type T1 = crate::data_structure::idxbased::Nat;
        }
        /// generated by [idxbased_related_gen::mut_reference::gen_prods]
        impl<'a> crate::extension_of::mut_reference::F<'a> for crate::data_structure::idxbased::F {
            type LImpl = crate::data_structure::idxbased::Fib;
            type T0 = crate::data_structure::idxbased::Nat;
        }
        /// generated by [idxbased_related_gen::mut_reference::gen_sums]
        impl<'a> crate::extension_of::mut_reference::Nat<'a> for crate::data_structure::idxbased::Nat {
            type LImpl = crate::data_structure::idxbased::Fib;
            type Owned = crate::data_structure::idxbased::Nat;
            type NatLit = crate::data_structure::idxbased::NatLit;
            type F = crate::data_structure::idxbased::F;
            type Plus = crate::data_structure::idxbased::Plus;
            fn nat_lit<'b: 'a>(self, l: &'b Self::LImpl) -> Option<Self::NatLit> {
                let my_data = &l.nat[self.0];
                match my_data {
                    crate::data_structure::idxbased::data::Nat::NatLit(a) => Some(*a),
                    _ => None,
                }
            }
            fn f<'b: 'a>(self, l: &'b Self::LImpl) -> Option<Self::F> {
                let my_data = &l.nat[self.0];
                match my_data {
                    crate::data_structure::idxbased::data::Nat::F(a) => Some(*a),
                    _ => None,
                }
            }
            fn plus<'b: 'a>(self, l: &'b Self::LImpl) -> Option<Self::Plus> {
                let my_data = &l.nat[self.0];
                match my_data {
                    crate::data_structure::idxbased::data::Nat::Plus(a) => Some(*a),
                    _ => None,
                }
            }
            fn set<'b: 'a>(self, l: &'b mut Self::LImpl, value: Self::Owned) {
                let their_data = l.nat[value.0];
                let my_data = &mut l.nat[self.0];
                *my_data = their_data;
            }
        }
    }
}
/// generated by [related_gen::generate]
pub mod extension_of {
    /// generated by [related_gen::limpl_trait]
    pub trait LImpl: core::default::Default {
        type NatLit: crate::extension_of::owned::NatLit<LImpl = Self>;
        type Plus: crate::extension_of::owned::Plus<LImpl = Self>;
        type F: crate::extension_of::owned::F<LImpl = Self>;
        type Nat: crate::extension_of::owned::Nat<LImpl = Self>;
    }
    pub trait Projection<LImpl, const N: u8> {
        type To;
        fn project(self, l: &LImpl) -> Self::To;
    }
    /// generated by [related_gen::owned::generate]
    pub mod owned {
        /// generated by [related_gen::owned::nat_lit]
        pub trait NatLit: From<u64> {
            type LImpl: crate::extension_of::LImpl;
            fn get_ref<'a, 'b: 'a>(
                &'a self,
                l: &'b Self::LImpl,
            ) -> impl crate::extension_of::reference::NatLit<'a, LImpl = Self::LImpl>;
            fn get_mut<'a, 'b: 'a>(
                &'a mut self,
                l: &'b mut Self::LImpl,
            ) -> impl crate::extension_of::mut_reference::NatLit<'a, LImpl = Self::LImpl>;
        }
        /// generated by [related_gen::owned::prods]
        pub trait Plus {
            type LImpl: crate::extension_of::LImpl;
            fn new(
                l: &mut Self::LImpl,
                args: (
                    <Self::LImpl as crate::extension_of::LImpl>::Nat,
                    <Self::LImpl as crate::extension_of::LImpl>::Nat,
                ),
            ) -> Self;
            fn get_ref<'a, 'b: 'a>(
                &'a self,
                l: &'b Self::LImpl,
            ) -> impl crate::extension_of::reference::Plus<'a, LImpl = Self::LImpl>;
            fn get_mut<'a, 'b: 'a>(
                &'a mut self,
                l: &'b mut Self::LImpl,
            ) -> impl crate::extension_of::mut_reference::Plus<'a, LImpl = Self::LImpl>;
        }
        /// generated by [related_gen::owned::prods]
        pub trait F {
            type LImpl: crate::extension_of::LImpl;
            fn new(
                l: &mut Self::LImpl,
                args: (<Self::LImpl as crate::extension_of::LImpl>::Nat,),
            ) -> Self;
            fn get_ref<'a, 'b: 'a>(
                &'a self,
                l: &'b Self::LImpl,
            ) -> impl crate::extension_of::reference::F<'a, LImpl = Self::LImpl>;
            fn get_mut<'a, 'b: 'a>(
                &'a mut self,
                l: &'b mut Self::LImpl,
            ) -> impl crate::extension_of::mut_reference::F<'a, LImpl = Self::LImpl>;
        }
        /// generated by [related_gen::owned::sums]
        pub trait Nat {
            type LImpl: crate::extension_of::LImpl;
            fn nat_lit(
                l: &mut Self::LImpl,
                from: <Self::LImpl as crate::extension_of::LImpl>::NatLit,
            ) -> Self;
            fn f(l: &mut Self::LImpl, from: <Self::LImpl as crate::extension_of::LImpl>::F)
                -> Self;
            fn plus(
                l: &mut Self::LImpl,
                from: <Self::LImpl as crate::extension_of::LImpl>::Plus,
            ) -> Self;
            fn get_ref(
                &self,
                l: &Self::LImpl,
            ) -> impl crate::extension_of::reference::Nat<'_, LImpl = Self::LImpl>;
            fn get_mut(
                &mut self,
                l: &mut Self::LImpl,
            ) -> impl crate::extension_of::mut_reference::Nat<'_, LImpl = Self::LImpl>;
        }
    }
    /// generated by [related_gen::reference::generate]
    pub mod reference {
        pub trait NatLit<'a>: Into<u64> {
            type LImpl: crate::extension_of::LImpl;
            fn is_eq<'b: 'a>(self, l: &'b Self::LImpl, other: Self) -> bool;
            fn convert<'b: 'a, 'c, O: crate::extension_of::owned::NatLit>(
                self,
                _l: &'b Self::LImpl,
                _lo: &'c mut O::LImpl,
            ) -> O {
                let intermediate: u64 = self.into();
                O::from(intermediate)
            }
        }
        /// generated by [related_gen::reference::prods]
        pub trait Plus<'a>:
            Copy
            + 'a
            + crate::extension_of::Projection<Self::LImpl, 0, To = Self::T0>
            + crate::extension_of::Projection<Self::LImpl, 1, To = Self::T1>
        where
            <Self::LImpl as crate::extension_of::LImpl>::Nat: 'a,
            <Self::LImpl as crate::extension_of::LImpl>::Nat: 'a,
        {
            type LImpl: crate::extension_of::LImpl;
            type T0: crate::extension_of::reference::Nat<'a, LImpl = Self::LImpl>;
            type T1: crate::extension_of::reference::Nat<'a, LImpl = Self::LImpl>;
            fn is_eq<'b: 'a>(self, l: &'b Self::LImpl, other: Self) -> bool;
            fn convert<'b: 'a, 'c, O: crate::extension_of::owned::Plus>(
                self,
                l: &'b Self::LImpl,
                lo: &'c mut O::LImpl,
            ) -> O {
                let args = (
                    <Self as crate::extension_of::Projection<Self::LImpl, 0>>::project(self, l)
                        .convert(l, lo),
                    <Self as crate::extension_of::Projection<Self::LImpl, 1>>::project(self, l)
                        .convert(l, lo),
                );
                O::new(lo, args)
            }
        }
        /// generated by [related_gen::reference::prods]
        pub trait F<'a>:
            Copy + 'a + crate::extension_of::Projection<Self::LImpl, 0, To = Self::T0>
        where
            <Self::LImpl as crate::extension_of::LImpl>::Nat: 'a,
        {
            type LImpl: crate::extension_of::LImpl;
            type T0: crate::extension_of::reference::Nat<'a, LImpl = Self::LImpl>;
            fn is_eq<'b: 'a>(self, l: &'b Self::LImpl, other: Self) -> bool;
            fn convert<'b: 'a, 'c, O: crate::extension_of::owned::F>(
                self,
                l: &'b Self::LImpl,
                lo: &'c mut O::LImpl,
            ) -> O {
                let args = (
                    <Self as crate::extension_of::Projection<Self::LImpl, 0>>::project(self, l)
                        .convert(l, lo),
                );
                O::new(lo, args)
            }
        }
        /// generated by [related_gen::reference::sums]
        pub trait Nat<'a>: Copy + 'a {
            type LImpl: crate::extension_of::LImpl;
            type NatLit: crate::extension_of::reference::NatLit<'a, LImpl = Self::LImpl>;
            type F: crate::extension_of::reference::F<'a, LImpl = Self::LImpl>;
            type Plus: crate::extension_of::reference::Plus<'a, LImpl = Self::LImpl>;
            fn nat_lit<'b: 'a>(self, l: &'b Self::LImpl) -> Option<Self::NatLit>;
            fn f<'b: 'a>(self, l: &'b Self::LImpl) -> Option<Self::F>;
            fn plus<'b: 'a>(self, l: &'b Self::LImpl) -> Option<Self::Plus>;
            fn is_eq<'b: 'a>(self, l: &'b Self::LImpl, other: Self) -> bool;
            fn convert<'b: 'a, 'c, O: crate::extension_of::owned::Nat>(
                self,
                l: &'b Self::LImpl,
                lo: &'c mut O::LImpl,
            ) -> O {
                if let Some(x) = self.nat_lit(l) {
                    let arg = x.convert(l, lo);
                    return O::nat_lit(lo, arg);
                }
                if let Some(x) = self.f(l) {
                    let arg = x.convert(l, lo);
                    return O::f(lo, arg);
                }
                if let Some(x) = self.plus(l) {
                    let arg = x.convert(l, lo);
                    return O::plus(lo, arg);
                }
                panic!("unreachable");
            }
        }
    }
    pub mod mut_reference {
        pub trait NatLit<'a> {
            type LImpl: crate::extension_of::LImpl;
        }
        /// generated by [related_gen::mut_reference::prods]
        pub trait Plus<'a>:
            crate::extension_of::Projection<Self::LImpl, 0, To = Self::T0>
            + crate::extension_of::Projection<Self::LImpl, 1, To = Self::T1>
        where
            <Self::LImpl as crate::extension_of::LImpl>::Nat: 'a,
            <Self::LImpl as crate::extension_of::LImpl>::Nat: 'a,
        {
            type LImpl: crate::extension_of::LImpl;
            type T0: crate::extension_of::mut_reference::Nat<'a>;
            type T1: crate::extension_of::mut_reference::Nat<'a>;
        }
        /// generated by [related_gen::mut_reference::prods]
        pub trait F<'a>: crate::extension_of::Projection<Self::LImpl, 0, To = Self::T0>
        where
            <Self::LImpl as crate::extension_of::LImpl>::Nat: 'a,
        {
            type LImpl: crate::extension_of::LImpl;
            type T0: crate::extension_of::mut_reference::Nat<'a>;
        }
        /// generated by [related_gen::mut_reference::sums]
        pub trait Nat<'a>: 'a {
            type LImpl: crate::extension_of::LImpl;
            type Owned: crate::extension_of::owned::Nat;
            type NatLit: crate::extension_of::mut_reference::NatLit<'a>;
            type F: crate::extension_of::mut_reference::F<'a>;
            type Plus: crate::extension_of::mut_reference::Plus<'a>;
            fn nat_lit<'b: 'a>(self, l: &'b Self::LImpl) -> Option<Self::NatLit>;
            fn f<'b: 'a>(self, l: &'b Self::LImpl) -> Option<Self::F>;
            fn plus<'b: 'a>(self, l: &'b Self::LImpl) -> Option<Self::Plus>;
            fn set<'b: 'a>(self, l: &'b mut Self::LImpl, value: Self::Owned);
        }
    }
}
pub mod data_structure {
    /// generated by [langdatastructure_gen::refbased::generate]
    pub mod refbased {
        /// generated by [langdatastructure_gen::refbased::gen_limpl]
        #[derive(Default)]
        pub struct Fib;
        pub type NatLit = u64;
        #[derive(serde::Serialize, serde::Deserialize)]
        pub struct Plus(
            pub crate::data_structure::refbased::Nat,
            pub crate::data_structure::refbased::Nat,
        );
        #[derive(serde::Serialize, serde::Deserialize)]
        pub struct F(pub crate::data_structure::refbased::Nat);
        #[derive(serde::Serialize, serde::Deserialize)]
        pub enum Nat {
            NatLit(u64),
            F(Box<crate::data_structure::refbased::F>),
            Plus(Box<crate::data_structure::refbased::Plus>),
        }
    }
    /// generated by [langdatastructure_gen::idxbased::generate]
    pub mod idxbased {
        /// generated by [langdatastructure_gen::idxbased::gen_db]
        pub struct Fib {
            pub plus: Vec<crate::data_structure::idxbased::data::Plus>,
            pub f: Vec<crate::data_structure::idxbased::data::F>,
            pub nat: Vec<crate::data_structure::idxbased::data::Nat>,
        }
        pub(crate) mod data {
            #[derive(Clone, Copy)]
            pub struct Plus(
                pub crate::data_structure::idxbased::Nat,
                pub crate::data_structure::idxbased::Nat,
            );
            #[derive(Clone, Copy)]
            pub struct F(pub crate::data_structure::idxbased::Nat);
            #[derive(Clone, Copy)]
            pub enum Nat {
                NatLit(crate::data_structure::idxbased::NatLit),
                F(crate::data_structure::idxbased::F),
                Plus(crate::data_structure::idxbased::Plus),
            }
        }
        #[derive(Clone, Copy)]
        pub struct NatLit(pub u64);
        #[derive(Clone, Copy)]
        pub struct Plus(pub usize);
        #[derive(Clone, Copy)]
        pub struct F(pub usize);
        #[derive(Clone, Copy)]
        pub struct Nat(pub usize);
    }
}
#[test]
fn round_trip() {
    let input = std::fs::read_to_string("tests/fib.json").unwrap();
    let (lo, nat) =
        parse::<crate::data_structure::idxbased::Fib, crate::data_structure::idxbased::Nat>(&input)
            .unwrap();
    let unparsed = unparse(&lo, nat).unwrap();
    let expected = expect_test::expect![[r#"
{
  "Plus": [
    {
      "F": {
        "NatLit": 50
      }
    },
    {
      "F": {
        "NatLit": 51
      }
    }
  ]
}"#]];
    expected.assert_eq(&unparsed);
}
