use langspec::{
    flat::LangSpecFlat,
    humanreadable::LangSpecHuman,
    langspec::{LangSpec, SortId, TerminalLangSpec},
};
use syn::{parse_quote, ItemStruct};

use langspec_gen_util::{name_as_camel_ident, SumGenData};
use langspec_gen_util::{LangSpecGen, ProdGenData};

pub fn sort2rs_idx_type(base_path: &syn::Path, sort: SortId<syn::Type>) -> syn::Type {
    match sort {
        SortId::NatLiteral => parse_quote!(#base_path::NatLit),
        SortId::Algebraic(ty) => ty,
        SortId::Set(ty) | SortId::Sequence(ty) => {
            parse_quote!(Vec<#ty>)
        }
    }
}

pub fn gen<L: LangSpec>(base_path: &syn::Path, l: &L) -> syn::ItemMod {
    let lg = LangSpecGen {
        bak: l,
        sort2rs_type: sort2rs_idx_type,
        type_base_path: parse_quote!(#base_path::idxbased),
    };
    let db = gen_db(base_path, &lg);
    let prod_datas = lg.prod_gen_datas().map(
        |ProdGenData {
             camel_ident: camel_name,
             sort_rs_types,
             ..
         }|
         -> syn::ItemStruct {
            parse_quote!(
                #[derive(Clone, Copy)]
                pub struct #camel_name (
                    #(pub #sort_rs_types,)*
                );
            )
        },
    );
    let sum_datas = lg.sum_gen_datas().map(
        |SumGenData {
             camel_ident: camel_name,
             sort_rs_camel_idents: sort_rs_idents,
             sort_rs_types,
             sort_shapes,
             ..
         }|
         -> syn::ItemEnum {
            let variant_tys = sort_rs_types
                .zip(sort_shapes)
                .map(|(ty, shape)| -> syn::Type {
                    if let SortId::Algebraic(_) = shape {
                        ty
                    } else {
                        ty
                    }
                });
            parse_quote!(
                #[derive(Clone, Copy)]
                pub enum #camel_name {
                    #(#sort_rs_idents(#variant_tys)),*
                }
            )
        },
    );
    let prods = lg
        .prod_gen_datas()
        .map(|ProdGenData { camel_ident, .. }| -> syn::ItemStruct {
            parse_quote! {
                #[derive(Clone, Copy)]
                pub struct #camel_ident(pub usize);
            }
        });
    let sums = lg
        .sum_gen_datas()
        .map(|SumGenData { camel_ident, .. }| -> syn::ItemStruct {
            parse_quote! {
                #[derive(Clone, Copy)]
                pub struct #camel_ident(pub usize);
            }
        });
    let byline = langspec_gen_util::byline!();
    syn::parse_quote! {
        #byline
        pub mod idxbased {
            #db
            pub(crate) mod data {
                #(#prod_datas)*
                #(#sum_datas)*
            }
            #[derive(Clone, Copy)]
            pub struct NatLit(pub u64);
            #(#prods)*
            #(#sums)*
        }
    }
}

pub(crate) fn gen_db<L: LangSpec>(base_path: &syn::Path, l: &LangSpecGen<L>) -> ItemStruct {
    langspec_gen_util::transpose!(l.prod_gen_datas(), snake_ident, rs_ty);
    let prod_fields = quote::quote! {
        #(pub #snake_ident: Vec<#base_path::idxbased::data::#rs_ty>,)*
    };
    langspec_gen_util::transpose!(l.sum_gen_datas(), snake_ident, rs_ty);
    let sum_fields = quote::quote! {
        #(pub #snake_ident: Vec<#base_path::idxbased::data::#rs_ty>,)*
    };
    let name = name_as_camel_ident(l.bak.name());
    let byline = langspec_gen_util::byline!();
    parse_quote!(
        #byline
        pub struct #name {
            #prod_fields
            #sum_fields
        }
    )
}

pub fn formatted(lsh: &LangSpecHuman) -> String {
    let lsf: LangSpecFlat = LangSpecFlat::canonical_from(lsh);
    let gen_result = gen(&parse_quote!(crate), &lsf);
    prettyplease::unparse(&syn::parse_quote! {
        #gen_result
    })
}

#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn test_data_structure() {
        let formatted = formatted(&langspec_examples::fib());
        let expected = expect_test::expect![[r#"
            /// generated by [langdatastructure_gen::idxbased::gen]
            pub mod idxbased {
                /// generated by [langdatastructure_gen::idxbased::gen_db]
                pub struct Fib {
                    pub plus: Vec<crate::idxbased::data::Plus>,
                    pub f: Vec<crate::idxbased::data::F>,
                    pub nat: Vec<crate::idxbased::data::Nat>,
                }
                pub(crate) mod data {
                    #[derive(Clone, Copy)]
                    pub struct Plus(pub crate::idxbased::Nat, pub crate::idxbased::Nat);
                    #[derive(Clone, Copy)]
                    pub struct F(pub crate::idxbased::Nat);
                    #[derive(Clone, Copy)]
                    pub enum Nat {
                        NatLit(crate::idxbased::NatLit),
                        F(crate::idxbased::F),
                        Plus(crate::idxbased::Plus),
                    }
                }
                #[derive(Clone, Copy)]
                pub struct NatLit(pub u64);
                #[derive(Clone, Copy)]
                pub struct Plus(pub usize);
                #[derive(Clone, Copy)]
                pub struct F(pub usize);
                #[derive(Clone, Copy)]
                pub struct Nat(pub usize);
            }
        "#]];
        expected.assert_eq(&formatted);
    }
}
