//! @generated
#![feature(custom_inner_attributes)]
#![rustfmt::skip]
#![allow(warnings)]
#![allow(unknown_lints)]
/// generated by [term_specialized_impl_gen::generate]
pub mod term_impls {
    use crate::data_structure as ds;
    /// generated by [term_specialized_impl_gen::gen_heap_impl]
    impl crate::term_trait::Heap for ds::Heap {
        type Plus = ds::Plus;
        type LeftOperand = ds::LeftOperand;
        type RightOperand = ds::RightOperand;
        type F = ds::F;
        type Sum = ds::Sum;
        type Nat = ds::Nat;
    }
    /// generated by [term_specialized_impl_gen::gen_owned_mod]
    pub mod owned_impls {
        use crate::data_structure as ds;
        impl crate::term_trait::owned::Plus for ds::Plus {}
        impl crate::term_trait::owned::LeftOperand for ds::LeftOperand {}
        impl crate::term_trait::owned::RightOperand for ds::RightOperand {}
        impl crate::term_trait::owned::F for ds::F {}
        impl crate::term_trait::owned::Sum for ds::Sum {}
        impl crate::term_trait::owned::Nat for ds::Nat {}
    }
    /// generated by [term_specialized_impl_gen::gen_ccf_mod]
    pub mod ccf_impls {
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        pub mod plus {
            use term::Heaped;
            use crate::data_structure as ds;
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (ds::LeftOperand, (ds::RightOperand, ())),
            > for ds::Plus {
                fn construct(
                    heap: &mut <Self as Heaped>::Heap,
                    t: (ds::LeftOperand, (ds::RightOperand, ())),
                ) -> Self {
                    crate::data_structure::Plus {
                        left_operand: t.0,
                        right_operand: t.1.0,
                    }
                }
                fn deconstruct_succeeds(&self, heap: &<Self as Heaped>::Heap) -> bool {
                    true
                }
                fn deconstruct(
                    self,
                    heap: &<Self as Heaped>::Heap,
                ) -> (ds::LeftOperand, (ds::RightOperand, ())) {
                    (self.left_operand, (self.right_operand, ()))
                }
            }
        }
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        pub mod left_operand {
            use term::Heaped;
            use crate::data_structure as ds;
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (ds::Nat, ()),
            > for ds::LeftOperand {
                fn construct(
                    heap: &mut <Self as Heaped>::Heap,
                    t: (ds::Nat, ()),
                ) -> Self {
                    crate::data_structure::LeftOperand {
                        nat: t.0,
                    }
                }
                fn deconstruct_succeeds(&self, heap: &<Self as Heaped>::Heap) -> bool {
                    true
                }
                fn deconstruct(self, heap: &<Self as Heaped>::Heap) -> (ds::Nat, ()) {
                    (self.nat, ())
                }
            }
        }
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        pub mod right_operand {
            use term::Heaped;
            use crate::data_structure as ds;
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (ds::Nat, ()),
            > for ds::RightOperand {
                fn construct(
                    heap: &mut <Self as Heaped>::Heap,
                    t: (ds::Nat, ()),
                ) -> Self {
                    crate::data_structure::RightOperand {
                        nat: t.0,
                    }
                }
                fn deconstruct_succeeds(&self, heap: &<Self as Heaped>::Heap) -> bool {
                    true
                }
                fn deconstruct(self, heap: &<Self as Heaped>::Heap) -> (ds::Nat, ()) {
                    (self.nat, ())
                }
            }
        }
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        pub mod f {
            use term::Heaped;
            use crate::data_structure as ds;
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (ds::Nat, ()),
            > for ds::F {
                fn construct(
                    heap: &mut <Self as Heaped>::Heap,
                    t: (ds::Nat, ()),
                ) -> Self {
                    crate::data_structure::F {
                        nat: t.0,
                    }
                }
                fn deconstruct_succeeds(&self, heap: &<Self as Heaped>::Heap) -> bool {
                    true
                }
                fn deconstruct(self, heap: &<Self as Heaped>::Heap) -> (ds::Nat, ()) {
                    (self.nat, ())
                }
            }
        }
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        pub mod sum {
            use tymetafuncspec_core::Set;
            use term::MapsTmf;
            use term::Heaped;
            use crate::term_trait::words as ttw;
            use crate::data_structure as ds;
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_prod]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        Set<<Self as Heaped>::Heap, ds::Nat>,
                    >>::Tmf,
                    (),
                ),
            > for ds::Sum {
                fn construct(
                    heap: &mut <Self as Heaped>::Heap,
                    t: (
                        <<Self as Heaped>::Heap as MapsTmf<
                            ttw::L,
                            Set<<Self as Heaped>::Heap, ds::Nat>,
                        >>::Tmf,
                        (),
                    ),
                ) -> Self {
                    crate::data_structure::Sum {
                        set: t.0,
                    }
                }
                fn deconstruct_succeeds(&self, heap: &<Self as Heaped>::Heap) -> bool {
                    true
                }
                fn deconstruct(
                    self,
                    heap: &<Self as Heaped>::Heap,
                ) -> (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        Set<<Self as Heaped>::Heap, ds::Nat>,
                    >>::Tmf,
                    (),
                ) {
                    (self.set, ())
                }
            }
        }
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        pub mod nat {
            use tymetafuncspec_core::IdxBox;
            use tymetafuncspec_core::BoundedNat;
            use term::MapsTmf;
            use term::Heaped;
            use crate::term_trait::words as ttw;
            use crate::data_structure as ds;
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        BoundedNat<<Self as Heaped>::Heap>,
                    >>::Tmf,
                    (),
                ),
            > for ds::Nat {
                fn construct(
                    heap: &mut <Self as Heaped>::Heap,
                    t: (
                        <<Self as Heaped>::Heap as MapsTmf<
                            ttw::L,
                            BoundedNat<<Self as Heaped>::Heap>,
                        >>::Tmf,
                        (),
                    ),
                ) -> Self {
                    crate::data_structure::Nat::NatLit(t.0)
                }
                fn deconstruct_succeeds(&self, heap: &<Self as Heaped>::Heap) -> bool {
                    match self {
                        crate::data_structure::Nat::NatLit(_) => true,
                        _ => false,
                    }
                }
                fn deconstruct(
                    self,
                    heap: &<Self as Heaped>::Heap,
                ) -> (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        BoundedNat<<Self as Heaped>::Heap>,
                    >>::Tmf,
                    (),
                ) {
                    match self {
                        crate::data_structure::Nat::NatLit(t) => (t, ()),
                        _ => panic!("conversion failure"),
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        IdxBox<<Self as Heaped>::Heap, ds::F>,
                    >>::Tmf,
                    (),
                ),
            > for ds::Nat {
                fn construct(
                    heap: &mut <Self as Heaped>::Heap,
                    t: (
                        <<Self as Heaped>::Heap as MapsTmf<
                            ttw::L,
                            IdxBox<<Self as Heaped>::Heap, ds::F>,
                        >>::Tmf,
                        (),
                    ),
                ) -> Self {
                    crate::data_structure::Nat::F(t.0)
                }
                fn deconstruct_succeeds(&self, heap: &<Self as Heaped>::Heap) -> bool {
                    match self {
                        crate::data_structure::Nat::F(_) => true,
                        _ => false,
                    }
                }
                fn deconstruct(
                    self,
                    heap: &<Self as Heaped>::Heap,
                ) -> (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        IdxBox<<Self as Heaped>::Heap, ds::F>,
                    >>::Tmf,
                    (),
                ) {
                    match self {
                        crate::data_structure::Nat::F(t) => (t, ()),
                        _ => panic!("conversion failure"),
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        IdxBox<<Self as Heaped>::Heap, ds::Plus>,
                    >>::Tmf,
                    (),
                ),
            > for ds::Nat {
                fn construct(
                    heap: &mut <Self as Heaped>::Heap,
                    t: (
                        <<Self as Heaped>::Heap as MapsTmf<
                            ttw::L,
                            IdxBox<<Self as Heaped>::Heap, ds::Plus>,
                        >>::Tmf,
                        (),
                    ),
                ) -> Self {
                    crate::data_structure::Nat::Plus(t.0)
                }
                fn deconstruct_succeeds(&self, heap: &<Self as Heaped>::Heap) -> bool {
                    match self {
                        crate::data_structure::Nat::Plus(_) => true,
                        _ => false,
                    }
                }
                fn deconstruct(
                    self,
                    heap: &<Self as Heaped>::Heap,
                ) -> (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        IdxBox<<Self as Heaped>::Heap, ds::Plus>,
                    >>::Tmf,
                    (),
                ) {
                    match self {
                        crate::data_structure::Nat::Plus(t) => (t, ()),
                        _ => panic!("conversion failure"),
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
            impl term::DirectlyCanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (ds::Sum, ()),
            > for ds::Nat {
                fn construct(
                    heap: &mut <Self as Heaped>::Heap,
                    t: (ds::Sum, ()),
                ) -> Self {
                    crate::data_structure::Nat::Sum(t.0)
                }
                fn deconstruct_succeeds(&self, heap: &<Self as Heaped>::Heap) -> bool {
                    match self {
                        crate::data_structure::Nat::Sum(_) => true,
                        _ => false,
                    }
                }
                fn deconstruct(self, heap: &<Self as Heaped>::Heap) -> (ds::Sum, ()) {
                    match self {
                        crate::data_structure::Nat::Sum(t) => (t, ()),
                        _ => panic!("conversion failure"),
                    }
                }
            }
        }
    }
    /// generated by [term_specialized_impl_gen::gen_transitive_ccf_mod]
    pub mod transitive_ccf {
        use tymetafuncspec_core::Set;
        use tymetafuncspec_core::IdxBox;
        use tymetafuncspec_core::BoundedNat;
        use crate::data_structure as ds;
        /// generated by [term_specialized_impl_gen::tuc_impls]
        impl term::TransitivelyUnitCcf<ds::Heap, ds::Nat> for ds::LeftOperand {
            type Intermediary = ds::Nat;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        impl term::TransitivelyUnitCcf<ds::Heap, ds::Nat> for ds::RightOperand {
            type Intermediary = ds::Nat;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        impl term::TransitivelyUnitCcf<ds::Heap, ds::Nat> for ds::F {
            type Intermediary = ds::Nat;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        impl term::TransitivelyUnitCcf<ds::Heap, Set<ds::Heap, ds::Nat>> for ds::Sum {
            type Intermediary = Set<ds::Heap, ds::Nat>;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        impl term::TransitivelyUnitCcf<ds::Heap, ds::Plus> for ds::Nat {
            type Intermediary = IdxBox<ds::Heap, ds::Plus>;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        impl term::TransitivelyUnitCcf<ds::Heap, ds::F> for ds::Nat {
            type Intermediary = IdxBox<ds::Heap, ds::F>;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        impl term::TransitivelyUnitCcf<ds::Heap, ds::Sum> for ds::Nat {
            type Intermediary = ds::Sum;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        impl term::TransitivelyUnitCcf<ds::Heap, BoundedNat<ds::Heap>> for ds::Nat {
            type Intermediary = BoundedNat<ds::Heap>;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        impl term::TransitivelyUnitCcf<ds::Heap, ds::Plus>
        for IdxBox<ds::Heap, ds::Plus> {
            type Intermediary = ds::Plus;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        impl term::TransitivelyUnitCcf<ds::Heap, ds::F> for IdxBox<ds::Heap, ds::F> {
            type Intermediary = ds::F;
        }
        /// generated by [term_specialized_impl_gen::tuc_impls]
        impl term::TransitivelyUnitCcf<ds::Heap, ds::Nat> for IdxBox<ds::Heap, ds::F> {
            type Intermediary = ds::F;
        }
        /// generated by [term_specialized_impl_gen::tac_impls]
        impl term::TransitivelyAllCcf<
            ds::Heap,
            (ds::LeftOperand, (ds::RightOperand, ())),
        > for ds::Plus {
            type Intermediary = ds::Plus;
            type Intermediaries = (ds::LeftOperand, (ds::RightOperand, ()));
        }
        /// generated by [term_specialized_impl_gen::tac_impls]
        impl term::TransitivelyAllCcf<
            ds::Heap,
            (ds::LeftOperand, (ds::RightOperand, ())),
        > for ds::Nat {
            type Intermediary = ds::Plus;
            type Intermediaries = (ds::LeftOperand, (ds::RightOperand, ()));
        }
        /// generated by [term_specialized_impl_gen::tac_impls]
        impl term::TransitivelyAllCcf<ds::Heap, (ds::LeftOperand, (ds::Nat, ()))>
        for ds::Plus {
            type Intermediary = ds::Plus;
            type Intermediaries = (ds::LeftOperand, (ds::RightOperand, ()));
        }
        /// generated by [term_specialized_impl_gen::tac_impls]
        impl term::TransitivelyAllCcf<ds::Heap, (ds::Nat, (ds::RightOperand, ()))>
        for ds::Plus {
            type Intermediary = ds::Plus;
            type Intermediaries = (ds::LeftOperand, (ds::RightOperand, ()));
        }
        /// generated by [term_specialized_impl_gen::tac_impls]
        impl term::TransitivelyAllCcf<ds::Heap, (ds::Nat, (ds::Nat, ()))> for ds::Plus {
            type Intermediary = ds::Plus;
            type Intermediaries = (ds::LeftOperand, (ds::RightOperand, ()));
        }
    }
    /// generated by [term_specialized_impl_gen::gen_ccf_auto_impls]
    pub mod ccf_auto_impls {
        term::auto_impl_ccf!(crate ::data_structure::Heap, crate ::data_structure::Plus);
        term::auto_impl_ccf!(
            crate ::data_structure::Heap, crate ::data_structure::LeftOperand
        );
        term::auto_impl_ccf!(
            crate ::data_structure::Heap, crate ::data_structure::RightOperand
        );
        term::auto_impl_ccf!(crate ::data_structure::Heap, crate ::data_structure::F);
        term::auto_impl_ccf!(crate ::data_structure::Heap, crate ::data_structure::Sum);
        term::auto_impl_ccf!(crate ::data_structure::Heap, crate ::data_structure::Nat);
        term::auto_impl_ccf!(
            crate ::data_structure::Heap, tymetafuncspec_core::Set < crate
            ::data_structure::Heap, crate ::data_structure::Nat, >
        );
        term::auto_impl_ccf!(
            crate ::data_structure::Heap, tymetafuncspec_core::BoundedNat < crate
            ::data_structure::Heap, >
        );
        term::auto_impl_ccf!(
            crate ::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
            ::data_structure::Heap, crate ::data_structure::F, >
        );
        term::auto_impl_ccf!(
            crate ::data_structure::Heap, tymetafuncspec_core::IdxBox < crate
            ::data_structure::Heap, crate ::data_structure::Plus, >
        );
    }
    /// generated by [term_specialized_impl_gen::gen_maps_tmf]
    pub mod maps_tmf_impls {
        use term::CanonicallyConstructibleFrom;
        use crate::term_trait::words as ttw;
        use crate::data_structure as ds;
        impl<TmfMonomorphization> term::MapsTmf<ttw::L, TmfMonomorphization> for ds::Heap
        where
            TmfMonomorphization: CanonicallyConstructibleFrom<
                Self,
                (TmfMonomorphization, ()),
            >,
        {
            type Tmf = TmfMonomorphization;
        }
    }
}
/// generated by [term_specialized_gen::generate]
pub mod data_structure {
    use tymetafuncspec_core::Set;
    use tymetafuncspec_core::IdxBox;
    use tymetafuncspec_core::BoundedNat;
    use crate::data_structure as ds;
    use crate::data_structure::heap::set as dshs;
    use crate::data_structure::heap::nat_lit as dshnl;
    use crate::data_structure::heap::idx_box as dshib;
    /// generated by [term_specialized_gen::gen_heap]
    #[derive(Default)]
    pub struct Heap {
        set: dshs::Bak,
        nat_lit: dshnl::Bak,
        idx_box: dshib::Bak,
    }
    /// generated by [term_specialized_gen::gen_heap]
    pub mod heap {
        use crate::data_structure::heap::set as dshs;
        use crate::data_structure::heap::nat_lit as dshnl;
        use crate::data_structure::heap::idx_box as dshib;
        /// generated by [term_specialized_gen::gen_modules_with_prefix]
        #[derive(Default)]
        pub struct Bak {
            pub set: dshs::Bak,
            pub nat_lit: dshnl::Bak,
            pub idx_box: dshib::Bak,
        }
        /// generated by [term_specialized_gen::gen_modules_with_prefix]
        pub mod set {
            use crate::data_structure::heap::set::nat as dshsn;
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[derive(Default)]
            pub struct Bak {
                pub nat: dshsn::Bak,
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod nat {
                use tymetafuncspec_core::SetHeapBak;
                use crate::data_structure as ds;
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[derive(Default)]
                pub struct Bak(pub SetHeapBak<ds::Heap, ds::Nat>);
            }
        }
        /// generated by [term_specialized_gen::gen_modules_with_prefix]
        pub mod nat_lit {
            use tymetafuncspec_core::BoundedNatHeapBak;
            use crate::data_structure as ds;
            /// generated by [term_specialized_gen::gen_heapbak_module]
            #[derive(Default)]
            pub struct Bak(pub BoundedNatHeapBak<ds::Heap>);
        }
        /// generated by [term_specialized_gen::gen_modules_with_prefix]
        pub mod idx_box {
            use crate::data_structure::heap::idx_box::plus as dshibp;
            use crate::data_structure::heap::idx_box::f as dshibf;
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[derive(Default)]
            pub struct Bak {
                pub f: dshibf::Bak,
                pub plus: dshibp::Bak,
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod f {
                use tymetafuncspec_core::IdxBoxHeapBak;
                use crate::data_structure as ds;
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[derive(Default)]
                pub struct Bak(pub IdxBoxHeapBak<ds::Heap, ds::F>);
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod plus {
                use tymetafuncspec_core::IdxBoxHeapBak;
                use crate::data_structure as ds;
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[derive(Default)]
                pub struct Bak(pub IdxBoxHeapBak<ds::Heap, ds::Plus>);
            }
        }
    }
    /// generated by [term_specialized_gen::gen_heap]
    pub mod superheap {
        term::impl_superheap!(
            crate ::data_structure::Heap; tymetafuncspec_core::SetHeapBak < crate
            ::data_structure::Heap, crate ::data_structure::Nat >; set nat
        );
        term::impl_superheap!(
            crate ::data_structure::Heap; tymetafuncspec_core::BoundedNatHeapBak < crate
            ::data_structure::Heap, >; nat_lit
        );
        term::impl_superheap!(
            crate ::data_structure::Heap; tymetafuncspec_core::IdxBoxHeapBak < crate
            ::data_structure::Heap, crate ::data_structure::F >; idx_box f
        );
        term::impl_superheap!(
            crate ::data_structure::Heap; tymetafuncspec_core::IdxBoxHeapBak < crate
            ::data_structure::Heap, crate ::data_structure::Plus >; idx_box plus
        );
    }
    #[derive(Clone, Copy)]
    pub struct Plus {
        pub left_operand: ds::LeftOperand,
        pub right_operand: ds::RightOperand,
    }
    #[derive(Clone, Copy)]
    pub struct LeftOperand {
        pub nat: ds::Nat,
    }
    #[derive(Clone, Copy)]
    pub struct RightOperand {
        pub nat: ds::Nat,
    }
    #[derive(Clone, Copy)]
    pub struct F {
        pub nat: ds::Nat,
    }
    #[derive(Clone, Copy)]
    pub struct Sum {
        pub set: Set<ds::Heap, ds::Nat>,
    }
    #[derive(Clone, Copy)]
    pub enum Nat {
        NatLit(BoundedNat<ds::Heap>),
        F(IdxBox<ds::Heap, ds::F>),
        Plus(IdxBox<ds::Heap, ds::Plus>),
        Sum(ds::Sum),
    }
    /// generated by [term_specialized_gen::gen_heaped_impls]
    pub mod heaped {
        use crate::data_structure as ds;
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        impl term::Heaped for ds::Plus {
            type Heap = ds::Heap;
        }
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        impl term::Heaped for ds::LeftOperand {
            type Heap = ds::Heap;
        }
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        impl term::Heaped for ds::RightOperand {
            type Heap = ds::Heap;
        }
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        impl term::Heaped for ds::F {
            type Heap = ds::Heap;
        }
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        impl term::Heaped for ds::Sum {
            type Heap = ds::Heap;
        }
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        impl term::Heaped for ds::Nat {
            type Heap = ds::Heap;
        }
    }
}
/// generated by [term_trait_gen::generate]
pub mod term_trait {
    use tymetafuncspec_core::SetHeapBak;
    use tymetafuncspec_core::Set;
    use tymetafuncspec_core::BoundedNatHeapBak;
    use tymetafuncspec_core::BoundedNat;
    use term::SuperHeap;
    use term::MapsTmf;
    use crate::term_trait::words as ttw;
    use crate::term_trait::owned as tto;
    /// generated by [term_trait_gen::heap_trait]
    pub trait Heap: Sized + MapsTmf<
            ttw::L,
            Set<Self, Self::Nat>,
        > + MapsTmf<
            ttw::L,
            BoundedNat<Self>,
        > + SuperHeap<SetHeapBak<Self, Self::Nat>> + SuperHeap<BoundedNatHeapBak<Self>> {
        type Plus: tto::Plus<Heap = Self>;
        type LeftOperand: tto::LeftOperand<Heap = Self>;
        type RightOperand: tto::RightOperand<Heap = Self>;
        type F: tto::F<Heap = Self>;
        type Sum: tto::Sum<Heap = Self>;
        type Nat: tto::Nat<Heap = Self>;
    }
    /// generated by [term_trait_gen::owned::generate]
    pub mod owned {
        use tymetafuncspec_core::Set;
        use tymetafuncspec_core::BoundedNat;
        use term::MapsTmf;
        use term::Heaped;
        use term::CanonicallyConstructibleFrom;
        use crate::term_trait as tt;
        use crate::term_trait::words as ttw;
        pub trait Plus: Heaped + CanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (
                    <<Self as Heaped>::Heap as tt::Heap>::LeftOperand,
                    (<<Self as Heaped>::Heap as tt::Heap>::RightOperand, ()),
                ),
            >
        where
            <Self as Heaped>::Heap: tt::Heap,
        {}
        pub trait LeftOperand: Heaped + CanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (<<Self as Heaped>::Heap as tt::Heap>::Nat, ()),
            >
        where
            <Self as Heaped>::Heap: tt::Heap,
        {}
        pub trait RightOperand: Heaped + CanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (<<Self as Heaped>::Heap as tt::Heap>::Nat, ()),
            >
        where
            <Self as Heaped>::Heap: tt::Heap,
        {}
        pub trait F: Heaped + CanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (<<Self as Heaped>::Heap as tt::Heap>::Nat, ()),
            >
        where
            <Self as Heaped>::Heap: tt::Heap,
        {}
        pub trait Sum: Heaped + CanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        Set<
                            <Self as Heaped>::Heap,
                            <<Self as Heaped>::Heap as tt::Heap>::Nat,
                        >,
                    >>::Tmf,
                    (),
                ),
            >
        where
            <Self as Heaped>::Heap: tt::Heap,
        {}
        pub trait Nat: Heaped + CanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (
                    <<Self as Heaped>::Heap as MapsTmf<
                        ttw::L,
                        BoundedNat<<Self as Heaped>::Heap>,
                    >>::Tmf,
                    (),
                ),
            > + CanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (<<Self as Heaped>::Heap as tt::Heap>::F, ()),
            > + CanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (<<Self as Heaped>::Heap as tt::Heap>::Plus, ()),
            > + CanonicallyConstructibleFrom<
                <Self as Heaped>::Heap,
                (<<Self as Heaped>::Heap as tt::Heap>::Sum, ()),
            >
        where
            <Self as Heaped>::Heap: tt::Heap,
        {}
    }
    /// generated by [words::words_mod]
    pub mod words {
        pub struct L;
        pub mod sorts {
            pub struct Plus;
            pub struct LeftOperand;
            pub struct RightOperand;
            pub struct F;
            pub struct Sum;
            pub struct Nat;
        }
    }
}
/// generated by [words::words_impls]
pub mod words_impls {
    use crate::term_trait::words as ttw;
    use crate::term_trait::words::sorts as ttws;
    use crate::data_structure as ds;
    impl words::Implements<ttw::L> for ds::Plus {
        type LWord = ttws::Plus;
    }
    impl words::Implements<ttw::L> for ds::LeftOperand {
        type LWord = ttws::LeftOperand;
    }
    impl words::Implements<ttw::L> for ds::RightOperand {
        type LWord = ttws::RightOperand;
    }
    impl words::Implements<ttw::L> for ds::F {
        type LWord = ttws::F;
    }
    impl words::Implements<ttw::L> for ds::Sum {
        type LWord = ttws::Sum;
    }
    impl words::Implements<ttw::L> for ds::Nat {
        type LWord = ttws::Nat;
    }
}
