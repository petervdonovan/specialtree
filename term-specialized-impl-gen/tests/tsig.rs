/// generated by [term_specialized_impl_gen::generate]
pub mod term_impls {
    /// generated by [term_specialized_impl_gen::gen_heap_impl]
    impl crate::extension_of::Heap for crate::data_structure::Heap {
        type Plus = crate::data_structure::Plus;
        type LeftOperand = crate::data_structure::LeftOperand;
        type RightOperand = crate::data_structure::RightOperand;
        type F = crate::data_structure::F;
        type Sum = crate::data_structure::Sum;
        type Nat = crate::data_structure::Nat;
    }
    /// generated by [term_specialized_impl_gen::gen_owned_mod]
    pub mod owned_impls {
        impl crate::extension_of::owned::Plus for crate::data_structure::Plus {}
        impl crate::extension_of::owned::LeftOperand
        for crate::data_structure::LeftOperand {}
        impl crate::extension_of::owned::RightOperand
        for crate::data_structure::RightOperand {}
        impl crate::extension_of::owned::F for crate::data_structure::F {}
        impl crate::extension_of::owned::Sum for crate::data_structure::Sum {}
        impl crate::extension_of::owned::Nat for crate::data_structure::Nat {}
    }
    /// generated by [term_specialized_impl_gen::gen_ccf_mod]
    pub mod ccf_impls {
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        pub mod plus {}
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        pub mod left_operand {}
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        pub mod right_operand {}
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        pub mod f {}
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        pub mod sum {}
        /// generated by [term_specialized_impl_gen::gen_ccf_impls]
        pub mod nat {
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
            impl term::CanonicallyConstructibleFrom<
                (tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>, ()),
            > for crate::data_structure::Nat {
                fn construct(
                    heap: &mut Self::Heap,
                    t: (
                        tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>,
                        (),
                    ),
                ) -> Self {
                    crate::data_structure::Nat::NatLit(t.0)
                }
                fn deconstruct_succeeds(&self, heap: &Self::Heap) -> bool {
                    match self {
                        crate::data_structure::Nat::NatLit(_) => true,
                        _ => false,
                    }
                }
                fn deconstruct(
                    self,
                    heap: &Self::Heap,
                ) -> (
                    tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>,
                    (),
                ) {
                    match self {
                        crate::data_structure::Nat::NatLit(t) => (t, ()),
                        _ => panic!("conversion failure"),
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
            impl term::CanonicallyConstructibleFrom<
                (
                    tymetafuncspec_core::IdxBox<
                        <Self as term::Heaped>::Heap,
                        crate::data_structure::F,
                    >,
                    (),
                ),
            > for crate::data_structure::Nat {
                fn construct(
                    heap: &mut Self::Heap,
                    t: (
                        tymetafuncspec_core::IdxBox<
                            <Self as term::Heaped>::Heap,
                            crate::data_structure::F,
                        >,
                        (),
                    ),
                ) -> Self {
                    crate::data_structure::Nat::F(t.0)
                }
                fn deconstruct_succeeds(&self, heap: &Self::Heap) -> bool {
                    match self {
                        crate::data_structure::Nat::F(_) => true,
                        _ => false,
                    }
                }
                fn deconstruct(
                    self,
                    heap: &Self::Heap,
                ) -> (
                    tymetafuncspec_core::IdxBox<
                        <Self as term::Heaped>::Heap,
                        crate::data_structure::F,
                    >,
                    (),
                ) {
                    match self {
                        crate::data_structure::Nat::F(t) => (t, ()),
                        _ => panic!("conversion failure"),
                    }
                }
            }
            /// generated by [term_specialized_impl_gen::gen_ccf_impl_sum]
            impl term::CanonicallyConstructibleFrom<
                (
                    tymetafuncspec_core::IdxBox<
                        <Self as term::Heaped>::Heap,
                        crate::data_structure::Plus,
                    >,
                    (),
                ),
            > for crate::data_structure::Nat {
                fn construct(
                    heap: &mut Self::Heap,
                    t: (
                        tymetafuncspec_core::IdxBox<
                            <Self as term::Heaped>::Heap,
                            crate::data_structure::Plus,
                        >,
                        (),
                    ),
                ) -> Self {
                    crate::data_structure::Nat::Plus(t.0)
                }
                fn deconstruct_succeeds(&self, heap: &Self::Heap) -> bool {
                    match self {
                        crate::data_structure::Nat::Plus(_) => true,
                        _ => false,
                    }
                }
                fn deconstruct(
                    self,
                    heap: &Self::Heap,
                ) -> (
                    tymetafuncspec_core::IdxBox<
                        <Self as term::Heaped>::Heap,
                        crate::data_structure::Plus,
                    >,
                    (),
                ) {
                    match self {
                        crate::data_structure::Nat::Plus(t) => (t, ()),
                        _ => panic!("conversion failure"),
                    }
                }
            }
        }
    }
    /// generated by [term_specialized_impl_gen::gen_transitive_ccf_mod]
    pub mod transitive_ccf {}
    /// generated by [term_specialized_impl_gen::gen_mct_mod]
    pub mod mct_impls {}
}
/// generated by [term_specialized_gen::generate]
pub mod data_structure {
    /// generated by [term_specialized_gen::gen_heap]
    #[derive(Default)]
    pub struct Heap {
        set: crate::data_structure::heap::set::Bak,
        nat_lit: crate::data_structure::heap::nat_lit::Bak,
        idx_box: crate::data_structure::heap::idx_box::Bak,
    }
    /// generated by [term_specialized_gen::gen_heap]
    pub mod heap {
        /// generated by [term_specialized_gen::gen_modules_with_prefix]
        #[derive(Default)]
        pub struct Bak {
            pub set: crate::data_structure::heap::set::Bak,
            pub nat_lit: crate::data_structure::heap::nat_lit::Bak,
            pub idx_box: crate::data_structure::heap::idx_box::Bak,
        }
        /// generated by [term_specialized_gen::gen_modules_with_prefix]
        pub mod set {
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[derive(Default)]
            pub struct Bak {
                pub nat: crate::data_structure::heap::set::nat::Bak,
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod nat {
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[derive(Default)]
                pub struct Bak(
                    pub tymetafuncspec_core::SetHeapBak<
                        crate::data_structure::Heap,
                        crate::data_structure::Nat,
                    >,
                );
            }
        }
        /// generated by [term_specialized_gen::gen_modules_with_prefix]
        pub mod nat_lit {
            /// generated by [term_specialized_gen::gen_heapbak_module]
            #[derive(Default)]
            pub struct Bak(
                pub tymetafuncspec_core::BoundedNatHeapBak<crate::data_structure::Heap>,
            );
        }
        /// generated by [term_specialized_gen::gen_modules_with_prefix]
        pub mod idx_box {
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            #[derive(Default)]
            pub struct Bak {
                pub f: crate::data_structure::heap::idx_box::f::Bak,
                pub plus: crate::data_structure::heap::idx_box::plus::Bak,
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod f {
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[derive(Default)]
                pub struct Bak(
                    pub tymetafuncspec_core::IdxBoxHeapBak<
                        crate::data_structure::Heap,
                        crate::data_structure::F,
                    >,
                );
            }
            /// generated by [term_specialized_gen::gen_modules_with_prefix]
            pub mod plus {
                /// generated by [term_specialized_gen::gen_heapbak_module]
                #[derive(Default)]
                pub struct Bak(
                    pub tymetafuncspec_core::IdxBoxHeapBak<
                        crate::data_structure::Heap,
                        crate::data_structure::Plus,
                    >,
                );
            }
        }
    }
    /// generated by [term_specialized_gen::gen_heap]
    pub mod superheap {
        term::impl_superheap!(
            crate ::data_structure::Heap; tymetafuncspec_core::SetHeapBak < crate
            ::data_structure::Heap, crate ::data_structure::Nat >; set nat
        );
        term::impl_superheap!(
            crate ::data_structure::Heap; tymetafuncspec_core::BoundedNatHeapBak < crate
            ::data_structure::Heap, >; nat_lit
        );
        term::impl_superheap!(
            crate ::data_structure::Heap; tymetafuncspec_core::IdxBoxHeapBak < crate
            ::data_structure::Heap, crate ::data_structure::F >; idx_box f
        );
        term::impl_superheap!(
            crate ::data_structure::Heap; tymetafuncspec_core::IdxBoxHeapBak < crate
            ::data_structure::Heap, crate ::data_structure::Plus >; idx_box plus
        );
    }
    #[derive(Clone, Copy)]
    pub struct Plus {
        pub left_operand: crate::data_structure::LeftOperand,
        pub right_operand: crate::data_structure::RightOperand,
    }
    #[derive(Clone, Copy)]
    pub struct LeftOperand {
        pub nat: crate::data_structure::Nat,
    }
    #[derive(Clone, Copy)]
    pub struct RightOperand {
        pub nat: crate::data_structure::Nat,
    }
    #[derive(Clone, Copy)]
    pub struct F {
        pub nat: crate::data_structure::Nat,
    }
    #[derive(Clone, Copy)]
    pub struct Sum {
        pub set: tymetafuncspec_core::Set<
            crate::data_structure::Heap,
            crate::data_structure::Nat,
        >,
    }
    #[derive(Clone, Copy)]
    pub enum Nat {
        NatLit(tymetafuncspec_core::BoundedNat<crate::data_structure::Heap>),
        F(
            tymetafuncspec_core::IdxBox<
                crate::data_structure::Heap,
                crate::data_structure::F,
            >,
        ),
        Plus(
            tymetafuncspec_core::IdxBox<
                crate::data_structure::Heap,
                crate::data_structure::Plus,
            >,
        ),
    }
    /// generated by [term_specialized_gen::gen_heaped_impls]
    pub mod heaped {
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        impl term::Heaped for crate::data_structure::Plus {
            type Heap = crate::data_structure::Heap;
        }
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        impl term::Heaped for crate::data_structure::LeftOperand {
            type Heap = crate::data_structure::Heap;
        }
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        impl term::Heaped for crate::data_structure::RightOperand {
            type Heap = crate::data_structure::Heap;
        }
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        impl term::Heaped for crate::data_structure::F {
            type Heap = crate::data_structure::Heap;
        }
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        impl term::Heaped for crate::data_structure::Sum {
            type Heap = crate::data_structure::Heap;
        }
        /// generated by [term_specialized_gen::gen_heaped_impls::heaped_impl]
        impl term::Heaped for crate::data_structure::Nat {
            type Heap = crate::data_structure::Heap;
        }
    }
}
/// generated by [term_pattern_match_strategy_provider_impl_gen::generate]
pub mod pattern_match_strategy {
    impl<
        Heap: crate::extension_of::Heap,
        T,
    > term::case_split::HasPatternMatchStrategyFor<T>
    for PatternMatchStrategyProvider<Heap>
    where
        T: words::Implements<crate::words::L>,
        PatternMatchStrategyProvider<
            Heap,
        >: term::case_split::HasPatternMatchStrategyFor<T::LWord>,
    {
        type Strategy = <PatternMatchStrategyProvider<
            Heap,
        > as term::case_split::HasPatternMatchStrategyFor<T::LWord>>::Strategy;
    }
    pub struct PatternMatchStrategyProvider<Heap>(std::marker::PhantomData<Heap>);
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
    impl<
        Heap: crate::extension_of::Heap,
    > term::case_split::HasPatternMatchStrategyFor<crate::words::sorts::Plus>
    for PatternMatchStrategyProvider<Heap> {
        type Strategy = ((Heap::LeftOperand, (Heap::RightOperand, ())), ());
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
    impl<
        Heap: crate::extension_of::Heap,
    > term::case_split::HasPatternMatchStrategyFor<crate::words::sorts::LeftOperand>
    for PatternMatchStrategyProvider<Heap> {
        type Strategy = ((Heap::Nat, ()), ());
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
    impl<
        Heap: crate::extension_of::Heap,
    > term::case_split::HasPatternMatchStrategyFor<crate::words::sorts::RightOperand>
    for PatternMatchStrategyProvider<Heap> {
        type Strategy = ((Heap::Nat, ()), ());
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
    impl<
        Heap: crate::extension_of::Heap,
    > term::case_split::HasPatternMatchStrategyFor<crate::words::sorts::F>
    for PatternMatchStrategyProvider<Heap> {
        type Strategy = ((Heap::Nat, ()), ());
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
    impl<
        Heap: crate::extension_of::Heap,
    > term::case_split::HasPatternMatchStrategyFor<crate::words::sorts::Sum>
    for PatternMatchStrategyProvider<Heap> {
        type Strategy = ((tymetafuncspec_core::Set<Heap, Heap::Nat>, ()), ());
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_has_pattern_match_strategy_for]
    impl<
        Heap: crate::extension_of::Heap,
    > term::case_split::HasPatternMatchStrategyFor<crate::words::sorts::Nat>
    for PatternMatchStrategyProvider<Heap> {
        type Strategy = (
            (tymetafuncspec_core::BoundedNat<Heap>, ()),
            (
                (tymetafuncspec_core::IdxBox<Heap, Heap::F>, ()),
                ((tymetafuncspec_core::IdxBox<Heap, Heap::Plus>, ()), ()),
            ),
        );
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
    impl term::case_split::Adt for crate::data_structure::Plus {
        type PatternMatchStrategyProvider = crate::pattern_match_strategy::PatternMatchStrategyProvider<
            crate::data_structure::Heap,
        >;
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
    impl term::case_split::Adt for crate::data_structure::LeftOperand {
        type PatternMatchStrategyProvider = crate::pattern_match_strategy::PatternMatchStrategyProvider<
            crate::data_structure::Heap,
        >;
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
    impl term::case_split::Adt for crate::data_structure::RightOperand {
        type PatternMatchStrategyProvider = crate::pattern_match_strategy::PatternMatchStrategyProvider<
            crate::data_structure::Heap,
        >;
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
    impl term::case_split::Adt for crate::data_structure::F {
        type PatternMatchStrategyProvider = crate::pattern_match_strategy::PatternMatchStrategyProvider<
            crate::data_structure::Heap,
        >;
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
    impl term::case_split::Adt for crate::data_structure::Sum {
        type PatternMatchStrategyProvider = crate::pattern_match_strategy::PatternMatchStrategyProvider<
            crate::data_structure::Heap,
        >;
    }
    /// generated by [term_pattern_match_strategy_provider_impl_gen::impl_adt_for]
    impl term::case_split::Adt for crate::data_structure::Nat {
        type PatternMatchStrategyProvider = crate::pattern_match_strategy::PatternMatchStrategyProvider<
            crate::data_structure::Heap,
        >;
    }
}
/// generated by [term_trait_gen::generate]
pub mod extension_of {
    /// generated by [term_trait_gen::heap_trait]
    pub trait Heap: Sized {
        type Plus: crate::extension_of::owned::Plus<Heap = Self>;
        type LeftOperand: crate::extension_of::owned::LeftOperand<Heap = Self>;
        type RightOperand: crate::extension_of::owned::RightOperand<Heap = Self>;
        type F: crate::extension_of::owned::F<Heap = Self>;
        type Sum: crate::extension_of::owned::Sum<Heap = Self>;
        type Nat: crate::extension_of::owned::Nat<Heap = Self>;
    }
    /// generated by [term_trait_gen::owned::generate]
    pub mod owned {
        pub trait Plus: term::Heaped + term::CanonicallyConstructibleFrom<
                (
                    <<Self as term::Heaped>::Heap as crate::extension_of::Heap>::LeftOperand,
                    (
                        <<Self as term::Heaped>::Heap as crate::extension_of::Heap>::RightOperand,
                        (),
                    ),
                ),
            >
        where
            <Self as term::Heaped>::Heap: crate::extension_of::Heap,
        {}
        pub trait LeftOperand: term::Heaped + term::CanonicallyConstructibleFrom<
                (<<Self as term::Heaped>::Heap as crate::extension_of::Heap>::Nat, ()),
            >
        where
            <Self as term::Heaped>::Heap: crate::extension_of::Heap,
        {}
        pub trait RightOperand: term::Heaped + term::CanonicallyConstructibleFrom<
                (<<Self as term::Heaped>::Heap as crate::extension_of::Heap>::Nat, ()),
            >
        where
            <Self as term::Heaped>::Heap: crate::extension_of::Heap,
        {}
        pub trait F: term::Heaped + term::CanonicallyConstructibleFrom<
                (<<Self as term::Heaped>::Heap as crate::extension_of::Heap>::Nat, ()),
            >
        where
            <Self as term::Heaped>::Heap: crate::extension_of::Heap,
        {}
        pub trait Sum: term::Heaped + term::CanonicallyConstructibleFrom<
                (
                    tymetafuncspec_core::Set<
                        <Self as term::Heaped>::Heap,
                        <<Self as term::Heaped>::Heap as crate::extension_of::Heap>::Nat,
                    >,
                    (),
                ),
            >
        where
            <Self as term::Heaped>::Heap: crate::extension_of::Heap,
        {}
        pub trait Nat: term::Heaped + term::CanonicallyConstructibleFrom<
                (tymetafuncspec_core::BoundedNat<<Self as term::Heaped>::Heap>, ()),
            > + term::CanonicallyConstructibleFrom<
                (
                    tymetafuncspec_core::IdxBox<
                        <Self as term::Heaped>::Heap,
                        <<Self as term::Heaped>::Heap as crate::extension_of::Heap>::F,
                    >,
                    (),
                ),
            > + term::CanonicallyConstructibleFrom<
                (
                    tymetafuncspec_core::IdxBox<
                        <Self as term::Heaped>::Heap,
                        <<Self as term::Heaped>::Heap as crate::extension_of::Heap>::Plus,
                    >,
                    (),
                ),
            >
        where
            <Self as term::Heaped>::Heap: crate::extension_of::Heap,
        {}
    }
    /// generated by [term_trait_gen::reference::generate]
    pub mod reference {}
}
