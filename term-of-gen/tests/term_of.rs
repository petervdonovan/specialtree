/// generated by [term_of_gen::generate]
pub mod term {
    /// generated by [term_of_gen::gen_termref]
    pub struct TermRef<'a, LImpl, T, Marker> {
        ls: &'a LImpl,
        term: T,
        trait_: std::marker::PhantomData<Marker>,
    }
    /// generated by [term_of_gen::gen_products]
    impl<'a, RefTy: crate::extension_of::reference::Plus<'a>>
        term_of::Product<'a, langspec::flat::LangSpecFlat>
        for crate::term::TermRef<'a, RefTy::LImpl, RefTy, crate::term::marker::Plus>
    {
        fn ty_id(
            &self,
        ) -> <langspec::flat::LangSpecFlat as langspec::langspec::LangSpec>::ProductId {
            langspec::flat::ProductId(0usize)
        }
        fn fields(
            &self,
        ) -> Box<dyn Iterator<Item = term_of::Term<'a, langspec::flat::LangSpecFlat>> + 'a>
        {
            Box::new(
                vec![
                    {
                        let it =
                            <RefTy as crate::extension_of::Projection<RefTy::LImpl, 0>>::project(
                                self.term, self.ls,
                            );
                        term_of::Term::Algebraic(term_of::AlgebraicTerm::Sum(Box::new(
                            crate::term::TermRef {
                                ls: self.ls,
                                term: it,
                                trait_: std::marker::PhantomData,
                            },
                        )))
                    },
                    {
                        let it =
                            <RefTy as crate::extension_of::Projection<RefTy::LImpl, 1>>::project(
                                self.term, self.ls,
                            );
                        term_of::Term::Algebraic(term_of::AlgebraicTerm::Sum(Box::new(
                            crate::term::TermRef {
                                ls: self.ls,
                                term: it,
                                trait_: std::marker::PhantomData,
                            },
                        )))
                    },
                ]
                .into_iter(),
            )
        }
    }
    /// generated by [term_of_gen::gen_products]
    impl<'a, RefTy: crate::extension_of::reference::F<'a>>
        term_of::Product<'a, langspec::flat::LangSpecFlat>
        for crate::term::TermRef<'a, RefTy::LImpl, RefTy, crate::term::marker::F>
    {
        fn ty_id(
            &self,
        ) -> <langspec::flat::LangSpecFlat as langspec::langspec::LangSpec>::ProductId {
            langspec::flat::ProductId(1usize)
        }
        fn fields(
            &self,
        ) -> Box<dyn Iterator<Item = term_of::Term<'a, langspec::flat::LangSpecFlat>> + 'a>
        {
            Box::new(
                vec![{
                    let it = <RefTy as crate::extension_of::Projection<RefTy::LImpl, 0>>::project(
                        self.term, self.ls,
                    );
                    term_of::Term::Algebraic(term_of::AlgebraicTerm::Sum(Box::new(
                        crate::term::TermRef {
                            ls: self.ls,
                            term: it,
                            trait_: std::marker::PhantomData,
                        },
                    )))
                }]
                .into_iter(),
            )
        }
    }
    /// generated by [term_of_gen::gen_sums]
    impl<'a, RefTy: crate::extension_of::reference::Nat<'a>>
        term_of::Sum<'a, langspec::flat::LangSpecFlat>
        for crate::term::TermRef<'a, RefTy::LImpl, RefTy, crate::term::marker::Nat>
    {
        fn ty_id(&self) -> <langspec::flat::LangSpecFlat as langspec::langspec::LangSpec>::SumId {
            langspec::flat::SumId(0usize)
        }
        fn get(&self) -> Option<term_of::Term<'a, langspec::flat::LangSpecFlat>> {
            [
                self.term
                    .nat_lit(self.ls)
                    .map(|it| term_of::Term::NatLiteral(it.into())),
                self.term.f(self.ls).map(|it| {
                    term_of::Term::Algebraic(term_of::AlgebraicTerm::Product(Box::new(
                        crate::term::TermRef {
                            ls: self.ls,
                            term: it,
                            trait_: std::marker::PhantomData,
                        },
                    )))
                }),
                self.term.plus(self.ls).map(|it| {
                    term_of::Term::Algebraic(term_of::AlgebraicTerm::Product(Box::new(
                        crate::term::TermRef {
                            ls: self.ls,
                            term: it,
                            trait_: std::marker::PhantomData,
                        },
                    )))
                }),
            ]
            .into_iter()
            .find_map(|it| it)
        }
    }
    /// generated by [term_of_gen::gen_markers]
    pub mod marker {
        pub struct Plus;
        pub struct F;
        pub struct Nat;
    }
}
/// generated by [related_gen::generate]
pub mod extension_of {
    /// generated by [related_gen::limpl_trait]
    pub trait LImpl: core::default::Default {
        type NatLit: crate::extension_of::owned::NatLit<LImpl = Self>;
        type Plus: crate::extension_of::owned::Plus<LImpl = Self>;
        type F: crate::extension_of::owned::F<LImpl = Self>;
        type Nat: crate::extension_of::owned::Nat<LImpl = Self>;
    }
    pub trait Projection<LImpl, const N: u8> {
        type To;
        fn project(self, l: &LImpl) -> Self::To;
    }
    /// generated by [related_gen::owned::generate]
    pub mod owned {
        /// generated by [related_gen::owned::nat_lit]
        pub trait NatLit: From<u64> {
            type LImpl: crate::extension_of::LImpl;
            fn get_ref<'a, 'b: 'a>(
                &'a self,
                l: &'b Self::LImpl,
            ) -> impl crate::extension_of::reference::NatLit<'a, LImpl = Self::LImpl>;
            fn get_mut<'a, 'b: 'a>(
                &'a mut self,
                l: &'b mut Self::LImpl,
            ) -> impl crate::extension_of::mut_reference::NatLit<'a, LImpl = Self::LImpl>;
        }
        /// generated by [related_gen::owned::prods]
        pub trait Plus {
            type LImpl: crate::extension_of::LImpl;
            fn new(
                l: &mut Self::LImpl,
                args: (
                    <Self::LImpl as crate::extension_of::LImpl>::Nat,
                    <Self::LImpl as crate::extension_of::LImpl>::Nat,
                ),
            ) -> Self;
            fn get_ref<'a, 'b: 'a>(
                &'a self,
                l: &'b Self::LImpl,
            ) -> impl crate::extension_of::reference::Plus<'a, LImpl = Self::LImpl>;
            fn get_mut<'a, 'b: 'a>(
                &'a mut self,
                l: &'b mut Self::LImpl,
            ) -> impl crate::extension_of::mut_reference::Plus<'a, LImpl = Self::LImpl>;
        }
        /// generated by [related_gen::owned::prods]
        pub trait F {
            type LImpl: crate::extension_of::LImpl;
            fn new(
                l: &mut Self::LImpl,
                args: (<Self::LImpl as crate::extension_of::LImpl>::Nat,),
            ) -> Self;
            fn get_ref<'a, 'b: 'a>(
                &'a self,
                l: &'b Self::LImpl,
            ) -> impl crate::extension_of::reference::F<'a, LImpl = Self::LImpl>;
            fn get_mut<'a, 'b: 'a>(
                &'a mut self,
                l: &'b mut Self::LImpl,
            ) -> impl crate::extension_of::mut_reference::F<'a, LImpl = Self::LImpl>;
        }
        /// generated by [related_gen::owned::sums]
        pub trait Nat {
            type LImpl: crate::extension_of::LImpl;
            fn nat_lit(
                l: &mut Self::LImpl,
                from: <Self::LImpl as crate::extension_of::LImpl>::NatLit,
            ) -> Self;
            fn f(l: &mut Self::LImpl, from: <Self::LImpl as crate::extension_of::LImpl>::F)
                -> Self;
            fn plus(
                l: &mut Self::LImpl,
                from: <Self::LImpl as crate::extension_of::LImpl>::Plus,
            ) -> Self;
            fn get_ref(
                &self,
                l: &Self::LImpl,
            ) -> impl crate::extension_of::reference::Nat<'_, LImpl = Self::LImpl>;
            fn get_mut(
                &mut self,
                l: &mut Self::LImpl,
            ) -> impl crate::extension_of::mut_reference::Nat<'_, LImpl = Self::LImpl>;
        }
    }
    /// generated by [related_gen::reference::generate]
    pub mod reference {
        pub trait NatLit<'a>: Into<u64> {
            type LImpl: crate::extension_of::LImpl;
            fn is_eq<'b: 'a>(self, l: &'b Self::LImpl, other: Self) -> bool;
            fn convert<'b: 'a, 'c, O: crate::extension_of::owned::NatLit>(
                self,
                _l: &'b Self::LImpl,
                _lo: &'c mut O::LImpl,
            ) -> O {
                let intermediate: u64 = self.into();
                O::from(intermediate)
            }
        }
        /// generated by [related_gen::reference::prods]
        pub trait Plus<'a>:
            Copy
            + 'a
            + crate::extension_of::Projection<Self::LImpl, 0, To = Self::T0>
            + crate::extension_of::Projection<Self::LImpl, 1, To = Self::T1>
        where
            <Self::LImpl as crate::extension_of::LImpl>::Nat: 'a,
            <Self::LImpl as crate::extension_of::LImpl>::Nat: 'a,
        {
            type LImpl: crate::extension_of::LImpl;
            type T0: crate::extension_of::reference::Nat<'a, LImpl = Self::LImpl>;
            type T1: crate::extension_of::reference::Nat<'a, LImpl = Self::LImpl>;
            fn is_eq<'b: 'a>(self, l: &'b Self::LImpl, other: Self) -> bool;
            fn convert<'b: 'a, 'c, O: crate::extension_of::owned::Plus>(
                self,
                l: &'b Self::LImpl,
                lo: &'c mut O::LImpl,
            ) -> O {
                let args = (
                    <Self as crate::extension_of::Projection<Self::LImpl, 0>>::project(self, l)
                        .convert(l, lo),
                    <Self as crate::extension_of::Projection<Self::LImpl, 1>>::project(self, l)
                        .convert(l, lo),
                );
                O::new(lo, args)
            }
        }
        /// generated by [related_gen::reference::prods]
        pub trait F<'a>:
            Copy + 'a + crate::extension_of::Projection<Self::LImpl, 0, To = Self::T0>
        where
            <Self::LImpl as crate::extension_of::LImpl>::Nat: 'a,
        {
            type LImpl: crate::extension_of::LImpl;
            type T0: crate::extension_of::reference::Nat<'a, LImpl = Self::LImpl>;
            fn is_eq<'b: 'a>(self, l: &'b Self::LImpl, other: Self) -> bool;
            fn convert<'b: 'a, 'c, O: crate::extension_of::owned::F>(
                self,
                l: &'b Self::LImpl,
                lo: &'c mut O::LImpl,
            ) -> O {
                let args = (
                    <Self as crate::extension_of::Projection<Self::LImpl, 0>>::project(self, l)
                        .convert(l, lo),
                );
                O::new(lo, args)
            }
        }
        /// generated by [related_gen::reference::sums]
        pub trait Nat<'a>: Copy + 'a {
            type LImpl: crate::extension_of::LImpl;
            type NatLit: crate::extension_of::reference::NatLit<'a, LImpl = Self::LImpl>;
            type F: crate::extension_of::reference::F<'a, LImpl = Self::LImpl>;
            type Plus: crate::extension_of::reference::Plus<'a, LImpl = Self::LImpl>;
            fn nat_lit<'b: 'a>(self, l: &'b Self::LImpl) -> Option<Self::NatLit>;
            fn f<'b: 'a>(self, l: &'b Self::LImpl) -> Option<Self::F>;
            fn plus<'b: 'a>(self, l: &'b Self::LImpl) -> Option<Self::Plus>;
            fn is_eq<'b: 'a>(self, l: &'b Self::LImpl, other: Self) -> bool;
            fn convert<'b: 'a, 'c, O: crate::extension_of::owned::Nat>(
                self,
                l: &'b Self::LImpl,
                lo: &'c mut O::LImpl,
            ) -> O {
                if let Some(x) = self.nat_lit(l) {
                    let arg = x.convert(l, lo);
                    return O::nat_lit(lo, arg);
                }
                if let Some(x) = self.f(l) {
                    let arg = x.convert(l, lo);
                    return O::f(lo, arg);
                }
                if let Some(x) = self.plus(l) {
                    let arg = x.convert(l, lo);
                    return O::plus(lo, arg);
                }
                panic!("unreachable");
            }
        }
    }
    pub mod mut_reference {
        pub trait NatLit<'a> {
            type LImpl: crate::extension_of::LImpl;
        }
        /// generated by [related_gen::mut_reference::prods]
        pub trait Plus<'a>:
            crate::extension_of::Projection<Self::LImpl, 0, To = Self::T0>
            + crate::extension_of::Projection<Self::LImpl, 1, To = Self::T1>
        where
            <Self::LImpl as crate::extension_of::LImpl>::Nat: 'a,
            <Self::LImpl as crate::extension_of::LImpl>::Nat: 'a,
        {
            type LImpl: crate::extension_of::LImpl;
            type T0: crate::extension_of::mut_reference::Nat<'a>;
            type T1: crate::extension_of::mut_reference::Nat<'a>;
        }
        /// generated by [related_gen::mut_reference::prods]
        pub trait F<'a>: crate::extension_of::Projection<Self::LImpl, 0, To = Self::T0>
        where
            <Self::LImpl as crate::extension_of::LImpl>::Nat: 'a,
        {
            type LImpl: crate::extension_of::LImpl;
            type T0: crate::extension_of::mut_reference::Nat<'a>;
        }
        /// generated by [related_gen::mut_reference::sums]
        pub trait Nat<'a>: 'a {
            type LImpl: crate::extension_of::LImpl;
            type Owned: crate::extension_of::owned::Nat;
            type NatLit: crate::extension_of::mut_reference::NatLit<'a>;
            type F: crate::extension_of::mut_reference::F<'a>;
            type Plus: crate::extension_of::mut_reference::Plus<'a>;
            fn nat_lit<'b: 'a>(self, l: &'b Self::LImpl) -> Option<Self::NatLit>;
            fn f<'b: 'a>(self, l: &'b Self::LImpl) -> Option<Self::F>;
            fn plus<'b: 'a>(self, l: &'b Self::LImpl) -> Option<Self::Plus>;
            fn set<'b: 'a>(self, l: &'b mut Self::LImpl, value: Self::Owned);
        }
    }
}
